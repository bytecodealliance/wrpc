// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package types

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasi__clocks__monotonic_clock "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/clocks/monotonic_clock"
	wasi__io__error "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/error"
	wasi__io__poll "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/poll"
	wasi__io__streams "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/streams"
	wrpc "github.com/wrpc/wrpc/go"
	errgroup "golang.org/x/sync/errgroup"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
)

type Duration = wasi__clocks__monotonic_clock.Duration
type InputStream = wasi__io__streams.InputStream
type OutputStream = wasi__io__streams.OutputStream
type IoError = wasi__io__error.Error
type Pollable = wasi__io__poll.Pollable

// This type corresponds to HTTP standard Methods.
type Method struct {
	payload      any
	discriminant MethodDiscriminant
}

func (v *Method) Discriminant() MethodDiscriminant { return v.discriminant }

type MethodDiscriminant uint8

const (
	MethodDiscriminant_Get     MethodDiscriminant = 0
	MethodDiscriminant_Head    MethodDiscriminant = 1
	MethodDiscriminant_Post    MethodDiscriminant = 2
	MethodDiscriminant_Put     MethodDiscriminant = 3
	MethodDiscriminant_Delete  MethodDiscriminant = 4
	MethodDiscriminant_Connect MethodDiscriminant = 5
	MethodDiscriminant_Options MethodDiscriminant = 6
	MethodDiscriminant_Trace   MethodDiscriminant = 7
	MethodDiscriminant_Patch   MethodDiscriminant = 8
	MethodDiscriminant_Other   MethodDiscriminant = 9
)

func (v *Method) String() string {
	switch v.discriminant {
	case MethodDiscriminant_Get:
		return "get"
	case MethodDiscriminant_Head:
		return "head"
	case MethodDiscriminant_Post:
		return "post"
	case MethodDiscriminant_Put:
		return "put"
	case MethodDiscriminant_Delete:
		return "delete"
	case MethodDiscriminant_Connect:
		return "connect"
	case MethodDiscriminant_Options:
		return "options"
	case MethodDiscriminant_Trace:
		return "trace"
	case MethodDiscriminant_Patch:
		return "patch"
	case MethodDiscriminant_Other:
		return "other"
	default:
		panic("invalid variant")
	}
}
func (v *Method) GetGet() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Get); !ok {
		return
	}
	return
}
func (v *Method) SetGet() *Method {
	v.discriminant = MethodDiscriminant_Get
	v.payload = nil
	return v
}
func (Method) NewGet() *Method {
	return (&Method{}).SetGet()
}
func (v *Method) GetHead() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Head); !ok {
		return
	}
	return
}
func (v *Method) SetHead() *Method {
	v.discriminant = MethodDiscriminant_Head
	v.payload = nil
	return v
}
func (Method) NewHead() *Method {
	return (&Method{}).SetHead()
}
func (v *Method) GetPost() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Post); !ok {
		return
	}
	return
}
func (v *Method) SetPost() *Method {
	v.discriminant = MethodDiscriminant_Post
	v.payload = nil
	return v
}
func (Method) NewPost() *Method {
	return (&Method{}).SetPost()
}
func (v *Method) GetPut() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Put); !ok {
		return
	}
	return
}
func (v *Method) SetPut() *Method {
	v.discriminant = MethodDiscriminant_Put
	v.payload = nil
	return v
}
func (Method) NewPut() *Method {
	return (&Method{}).SetPut()
}
func (v *Method) GetDelete() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Delete); !ok {
		return
	}
	return
}
func (v *Method) SetDelete() *Method {
	v.discriminant = MethodDiscriminant_Delete
	v.payload = nil
	return v
}
func (Method) NewDelete() *Method {
	return (&Method{}).SetDelete()
}
func (v *Method) GetConnect() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Connect); !ok {
		return
	}
	return
}
func (v *Method) SetConnect() *Method {
	v.discriminant = MethodDiscriminant_Connect
	v.payload = nil
	return v
}
func (Method) NewConnect() *Method {
	return (&Method{}).SetConnect()
}
func (v *Method) GetOptions() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Options); !ok {
		return
	}
	return
}
func (v *Method) SetOptions() *Method {
	v.discriminant = MethodDiscriminant_Options
	v.payload = nil
	return v
}
func (Method) NewOptions() *Method {
	return (&Method{}).SetOptions()
}
func (v *Method) GetTrace() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Trace); !ok {
		return
	}
	return
}
func (v *Method) SetTrace() *Method {
	v.discriminant = MethodDiscriminant_Trace
	v.payload = nil
	return v
}
func (Method) NewTrace() *Method {
	return (&Method{}).SetTrace()
}
func (v *Method) GetPatch() (ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Patch); !ok {
		return
	}
	return
}
func (v *Method) SetPatch() *Method {
	v.discriminant = MethodDiscriminant_Patch
	v.payload = nil
	return v
}
func (Method) NewPatch() *Method {
	return (&Method{}).SetPatch()
}
func (v *Method) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == MethodDiscriminant_Other); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *Method) SetOther(payload string) *Method {
	v.discriminant = MethodDiscriminant_Other
	v.payload = payload
	return v
}
func (Method) NewOther(payload string) *Method {
	return (&Method{}).SetOther(
		payload)
}
func (v *Method) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w wrpc.ByteWriter) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case MethodDiscriminant_Get:
	case MethodDiscriminant_Head:
	case MethodDiscriminant_Post:
	case MethodDiscriminant_Put:
	case MethodDiscriminant_Delete:
	case MethodDiscriminant_Connect:
	case MethodDiscriminant_Options:
	case MethodDiscriminant_Trace:
	case MethodDiscriminant_Patch:
	case MethodDiscriminant_Other:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(9)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// This type corresponds to HTTP standard Related Schemes.
type Scheme struct {
	payload      any
	discriminant SchemeDiscriminant
}

func (v *Scheme) Discriminant() SchemeDiscriminant { return v.discriminant }

type SchemeDiscriminant uint8

const (
	SchemeDiscriminant_Http  SchemeDiscriminant = 0
	SchemeDiscriminant_Https SchemeDiscriminant = 1
	SchemeDiscriminant_Other SchemeDiscriminant = 2
)

func (v *Scheme) String() string {
	switch v.discriminant {
	case SchemeDiscriminant_Http:
		return "HTTP"
	case SchemeDiscriminant_Https:
		return "HTTPS"
	case SchemeDiscriminant_Other:
		return "other"
	default:
		panic("invalid variant")
	}
}
func (v *Scheme) GetHttp() (ok bool) {
	if ok = (v.discriminant == SchemeDiscriminant_Http); !ok {
		return
	}
	return
}
func (v *Scheme) SetHttp() *Scheme {
	v.discriminant = SchemeDiscriminant_Http
	v.payload = nil
	return v
}
func (Scheme) NewHttp() *Scheme {
	return (&Scheme{}).SetHttp()
}
func (v *Scheme) GetHttps() (ok bool) {
	if ok = (v.discriminant == SchemeDiscriminant_Https); !ok {
		return
	}
	return
}
func (v *Scheme) SetHttps() *Scheme {
	v.discriminant = SchemeDiscriminant_Https
	v.payload = nil
	return v
}
func (Scheme) NewHttps() *Scheme {
	return (&Scheme{}).SetHttps()
}
func (v *Scheme) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == SchemeDiscriminant_Other); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *Scheme) SetOther(payload string) *Scheme {
	v.discriminant = SchemeDiscriminant_Other
	v.payload = payload
	return v
}
func (Scheme) NewOther(payload string) *Scheme {
	return (&Scheme{}).SetOther(
		payload)
}
func (v *Scheme) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w wrpc.ByteWriter) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case SchemeDiscriminant_Http:
	case SchemeDiscriminant_Https:
	case SchemeDiscriminant_Other:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(2)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Defines the case payload type for `DNS-error` above:
type DnsErrorPayload struct {
	Rcode    *string
	InfoCode *uint16
}

func (v *DnsErrorPayload) String() string { return "DnsErrorPayload" }

func (v *DnsErrorPayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "rcode")
	write0, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Rcode, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `rcode` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "info-code")
	write1, err := func(v *uint16, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint16, w interface {
			io.ByteWriter
			io.Writer
		}) (err error) { b := make([]byte, binary.MaxVarintLen16); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u16"); _, err = w.Write(b[:i]); return err }(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.InfoCode, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `info-code` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// Defines the case payload type for `TLS-alert-received` above:
type TlsAlertReceivedPayload struct {
	AlertId      *uint8
	AlertMessage *string
}

func (v *TlsAlertReceivedPayload) String() string { return "TlsAlertReceivedPayload" }

func (v *TlsAlertReceivedPayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "alert-id")
	write0, err := func(v *uint8, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
			slog.Debug("writing u8 byte")
			return w.WriteByte(v)
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.AlertId, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `alert-id` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "alert-message")
	write1, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.AlertMessage, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `alert-message` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
type FieldSizePayload struct {
	FieldName *string
	FieldSize *uint32
}

func (v *FieldSizePayload) String() string { return "FieldSizePayload" }

func (v *FieldSizePayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "field-name")
	write0, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.FieldName, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `field-name` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "field-size")
	write1, err := func(v *uint32, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w interface {
			io.ByteWriter
			io.Writer
		}) (err error) { b := make([]byte, binary.MaxVarintLen32); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u32"); _, err = w.Write(b[:i]); return err }(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.FieldSize, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `field-size` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// These cases are inspired by the IANA HTTP Proxy Error Types:
// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
type ErrorCode struct {
	payload      any
	discriminant ErrorCodeDiscriminant
}

func (v *ErrorCode) Discriminant() ErrorCodeDiscriminant { return v.discriminant }

type ErrorCodeDiscriminant uint8

const (
	ErrorCodeDiscriminant_DnsTimeout                     ErrorCodeDiscriminant = 0
	ErrorCodeDiscriminant_DnsError                       ErrorCodeDiscriminant = 1
	ErrorCodeDiscriminant_DestinationNotFound            ErrorCodeDiscriminant = 2
	ErrorCodeDiscriminant_DestinationUnavailable         ErrorCodeDiscriminant = 3
	ErrorCodeDiscriminant_DestinationIpProhibited        ErrorCodeDiscriminant = 4
	ErrorCodeDiscriminant_DestinationIpUnroutable        ErrorCodeDiscriminant = 5
	ErrorCodeDiscriminant_ConnectionRefused              ErrorCodeDiscriminant = 6
	ErrorCodeDiscriminant_ConnectionTerminated           ErrorCodeDiscriminant = 7
	ErrorCodeDiscriminant_ConnectionTimeout              ErrorCodeDiscriminant = 8
	ErrorCodeDiscriminant_ConnectionReadTimeout          ErrorCodeDiscriminant = 9
	ErrorCodeDiscriminant_ConnectionWriteTimeout         ErrorCodeDiscriminant = 10
	ErrorCodeDiscriminant_ConnectionLimitReached         ErrorCodeDiscriminant = 11
	ErrorCodeDiscriminant_TlsProtocolError               ErrorCodeDiscriminant = 12
	ErrorCodeDiscriminant_TlsCertificateError            ErrorCodeDiscriminant = 13
	ErrorCodeDiscriminant_TlsAlertReceived               ErrorCodeDiscriminant = 14
	ErrorCodeDiscriminant_HttpRequestDenied              ErrorCodeDiscriminant = 15
	ErrorCodeDiscriminant_HttpRequestLengthRequired      ErrorCodeDiscriminant = 16
	ErrorCodeDiscriminant_HttpRequestBodySize            ErrorCodeDiscriminant = 17
	ErrorCodeDiscriminant_HttpRequestMethodInvalid       ErrorCodeDiscriminant = 18
	ErrorCodeDiscriminant_HttpRequestUriInvalid          ErrorCodeDiscriminant = 19
	ErrorCodeDiscriminant_HttpRequestUriTooLong          ErrorCodeDiscriminant = 20
	ErrorCodeDiscriminant_HttpRequestHeaderSectionSize   ErrorCodeDiscriminant = 21
	ErrorCodeDiscriminant_HttpRequestHeaderSize          ErrorCodeDiscriminant = 22
	ErrorCodeDiscriminant_HttpRequestTrailerSectionSize  ErrorCodeDiscriminant = 23
	ErrorCodeDiscriminant_HttpRequestTrailerSize         ErrorCodeDiscriminant = 24
	ErrorCodeDiscriminant_HttpResponseIncomplete         ErrorCodeDiscriminant = 25
	ErrorCodeDiscriminant_HttpResponseHeaderSectionSize  ErrorCodeDiscriminant = 26
	ErrorCodeDiscriminant_HttpResponseHeaderSize         ErrorCodeDiscriminant = 27
	ErrorCodeDiscriminant_HttpResponseBodySize           ErrorCodeDiscriminant = 28
	ErrorCodeDiscriminant_HttpResponseTrailerSectionSize ErrorCodeDiscriminant = 29
	ErrorCodeDiscriminant_HttpResponseTrailerSize        ErrorCodeDiscriminant = 30
	ErrorCodeDiscriminant_HttpResponseTransferCoding     ErrorCodeDiscriminant = 31
	ErrorCodeDiscriminant_HttpResponseContentCoding      ErrorCodeDiscriminant = 32
	ErrorCodeDiscriminant_HttpResponseTimeout            ErrorCodeDiscriminant = 33
	ErrorCodeDiscriminant_HttpUpgradeFailed              ErrorCodeDiscriminant = 34
	ErrorCodeDiscriminant_HttpProtocolError              ErrorCodeDiscriminant = 35
	ErrorCodeDiscriminant_LoopDetected                   ErrorCodeDiscriminant = 36
	ErrorCodeDiscriminant_ConfigurationError             ErrorCodeDiscriminant = 37
	// This is a catch-all error for anything that doesn't fit cleanly into a
	// more specific case. It also includes an optional string for an
	// unstructured description of the error. Users should not depend on the
	// string for diagnosing errors, as it's not required to be consistent
	// between implementations.
	ErrorCodeDiscriminant_InternalError ErrorCodeDiscriminant = 38
)

func (v *ErrorCode) String() string {
	switch v.discriminant {
	case ErrorCodeDiscriminant_DnsTimeout:
		return "DNS-timeout"
	case ErrorCodeDiscriminant_DnsError:
		return "DNS-error"
	case ErrorCodeDiscriminant_DestinationNotFound:
		return "destination-not-found"
	case ErrorCodeDiscriminant_DestinationUnavailable:
		return "destination-unavailable"
	case ErrorCodeDiscriminant_DestinationIpProhibited:
		return "destination-IP-prohibited"
	case ErrorCodeDiscriminant_DestinationIpUnroutable:
		return "destination-IP-unroutable"
	case ErrorCodeDiscriminant_ConnectionRefused:
		return "connection-refused"
	case ErrorCodeDiscriminant_ConnectionTerminated:
		return "connection-terminated"
	case ErrorCodeDiscriminant_ConnectionTimeout:
		return "connection-timeout"
	case ErrorCodeDiscriminant_ConnectionReadTimeout:
		return "connection-read-timeout"
	case ErrorCodeDiscriminant_ConnectionWriteTimeout:
		return "connection-write-timeout"
	case ErrorCodeDiscriminant_ConnectionLimitReached:
		return "connection-limit-reached"
	case ErrorCodeDiscriminant_TlsProtocolError:
		return "TLS-protocol-error"
	case ErrorCodeDiscriminant_TlsCertificateError:
		return "TLS-certificate-error"
	case ErrorCodeDiscriminant_TlsAlertReceived:
		return "TLS-alert-received"
	case ErrorCodeDiscriminant_HttpRequestDenied:
		return "HTTP-request-denied"
	case ErrorCodeDiscriminant_HttpRequestLengthRequired:
		return "HTTP-request-length-required"
	case ErrorCodeDiscriminant_HttpRequestBodySize:
		return "HTTP-request-body-size"
	case ErrorCodeDiscriminant_HttpRequestMethodInvalid:
		return "HTTP-request-method-invalid"
	case ErrorCodeDiscriminant_HttpRequestUriInvalid:
		return "HTTP-request-URI-invalid"
	case ErrorCodeDiscriminant_HttpRequestUriTooLong:
		return "HTTP-request-URI-too-long"
	case ErrorCodeDiscriminant_HttpRequestHeaderSectionSize:
		return "HTTP-request-header-section-size"
	case ErrorCodeDiscriminant_HttpRequestHeaderSize:
		return "HTTP-request-header-size"
	case ErrorCodeDiscriminant_HttpRequestTrailerSectionSize:
		return "HTTP-request-trailer-section-size"
	case ErrorCodeDiscriminant_HttpRequestTrailerSize:
		return "HTTP-request-trailer-size"
	case ErrorCodeDiscriminant_HttpResponseIncomplete:
		return "HTTP-response-incomplete"
	case ErrorCodeDiscriminant_HttpResponseHeaderSectionSize:
		return "HTTP-response-header-section-size"
	case ErrorCodeDiscriminant_HttpResponseHeaderSize:
		return "HTTP-response-header-size"
	case ErrorCodeDiscriminant_HttpResponseBodySize:
		return "HTTP-response-body-size"
	case ErrorCodeDiscriminant_HttpResponseTrailerSectionSize:
		return "HTTP-response-trailer-section-size"
	case ErrorCodeDiscriminant_HttpResponseTrailerSize:
		return "HTTP-response-trailer-size"
	case ErrorCodeDiscriminant_HttpResponseTransferCoding:
		return "HTTP-response-transfer-coding"
	case ErrorCodeDiscriminant_HttpResponseContentCoding:
		return "HTTP-response-content-coding"
	case ErrorCodeDiscriminant_HttpResponseTimeout:
		return "HTTP-response-timeout"
	case ErrorCodeDiscriminant_HttpUpgradeFailed:
		return "HTTP-upgrade-failed"
	case ErrorCodeDiscriminant_HttpProtocolError:
		return "HTTP-protocol-error"
	case ErrorCodeDiscriminant_LoopDetected:
		return "loop-detected"
	case ErrorCodeDiscriminant_ConfigurationError:
		return "configuration-error"
	case ErrorCodeDiscriminant_InternalError:
		return "internal-error"
	default:
		panic("invalid variant")
	}
}
func (v *ErrorCode) GetDnsTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DnsTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDnsTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DnsTimeout
	v.payload = nil
	return v
}
func (ErrorCode) NewDnsTimeout() *ErrorCode {
	return (&ErrorCode{}).SetDnsTimeout()
}
func (v *ErrorCode) GetDnsError() (payload DnsErrorPayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DnsError); !ok {
		return
	}
	payload, ok = v.payload.(DnsErrorPayload)
	return
}
func (v *ErrorCode) SetDnsError(payload *DnsErrorPayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DnsError
	v.payload = payload
	return v
}
func (ErrorCode) NewDnsError(payload *DnsErrorPayload) *ErrorCode {
	return (&ErrorCode{}).SetDnsError(
		payload)
}
func (v *ErrorCode) GetDestinationNotFound() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DestinationNotFound); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationNotFound() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DestinationNotFound
	v.payload = nil
	return v
}
func (ErrorCode) NewDestinationNotFound() *ErrorCode {
	return (&ErrorCode{}).SetDestinationNotFound()
}
func (v *ErrorCode) GetDestinationUnavailable() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DestinationUnavailable); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationUnavailable() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DestinationUnavailable
	v.payload = nil
	return v
}
func (ErrorCode) NewDestinationUnavailable() *ErrorCode {
	return (&ErrorCode{}).SetDestinationUnavailable()
}
func (v *ErrorCode) GetDestinationIpProhibited() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DestinationIpProhibited); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationIpProhibited() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DestinationIpProhibited
	v.payload = nil
	return v
}
func (ErrorCode) NewDestinationIpProhibited() *ErrorCode {
	return (&ErrorCode{}).SetDestinationIpProhibited()
}
func (v *ErrorCode) GetDestinationIpUnroutable() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_DestinationIpUnroutable); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationIpUnroutable() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_DestinationIpUnroutable
	v.payload = nil
	return v
}
func (ErrorCode) NewDestinationIpUnroutable() *ErrorCode {
	return (&ErrorCode{}).SetDestinationIpUnroutable()
}
func (v *ErrorCode) GetConnectionRefused() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionRefused); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionRefused() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionRefused
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionRefused() *ErrorCode {
	return (&ErrorCode{}).SetConnectionRefused()
}
func (v *ErrorCode) GetConnectionTerminated() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionTerminated); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionTerminated() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionTerminated
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionTerminated() *ErrorCode {
	return (&ErrorCode{}).SetConnectionTerminated()
}
func (v *ErrorCode) GetConnectionTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionTimeout
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionTimeout()
}
func (v *ErrorCode) GetConnectionReadTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionReadTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionReadTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionReadTimeout
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionReadTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionReadTimeout()
}
func (v *ErrorCode) GetConnectionWriteTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionWriteTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionWriteTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionWriteTimeout
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionWriteTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionWriteTimeout()
}
func (v *ErrorCode) GetConnectionLimitReached() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConnectionLimitReached); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionLimitReached() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConnectionLimitReached
	v.payload = nil
	return v
}
func (ErrorCode) NewConnectionLimitReached() *ErrorCode {
	return (&ErrorCode{}).SetConnectionLimitReached()
}
func (v *ErrorCode) GetTlsProtocolError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_TlsProtocolError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetTlsProtocolError() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_TlsProtocolError
	v.payload = nil
	return v
}
func (ErrorCode) NewTlsProtocolError() *ErrorCode {
	return (&ErrorCode{}).SetTlsProtocolError()
}
func (v *ErrorCode) GetTlsCertificateError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_TlsCertificateError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetTlsCertificateError() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_TlsCertificateError
	v.payload = nil
	return v
}
func (ErrorCode) NewTlsCertificateError() *ErrorCode {
	return (&ErrorCode{}).SetTlsCertificateError()
}
func (v *ErrorCode) GetTlsAlertReceived() (payload TlsAlertReceivedPayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_TlsAlertReceived); !ok {
		return
	}
	payload, ok = v.payload.(TlsAlertReceivedPayload)
	return
}
func (v *ErrorCode) SetTlsAlertReceived(payload *TlsAlertReceivedPayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_TlsAlertReceived
	v.payload = payload
	return v
}
func (ErrorCode) NewTlsAlertReceived(payload *TlsAlertReceivedPayload) *ErrorCode {
	return (&ErrorCode{}).SetTlsAlertReceived(
		payload)
}
func (v *ErrorCode) GetHttpRequestDenied() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestDenied); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestDenied() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestDenied
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpRequestDenied() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestDenied()
}
func (v *ErrorCode) GetHttpRequestLengthRequired() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestLengthRequired); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestLengthRequired() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestLengthRequired
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpRequestLengthRequired() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestLengthRequired()
}
func (v *ErrorCode) GetHttpRequestBodySize() (payload *uint64, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestBodySize); !ok {
		return
	}
	payload, ok = v.payload.(*uint64)
	return
}
func (v *ErrorCode) SetHttpRequestBodySize(payload *uint64) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestBodySize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpRequestBodySize(payload *uint64) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestBodySize(
		payload)
}
func (v *ErrorCode) GetHttpRequestMethodInvalid() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestMethodInvalid); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestMethodInvalid() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestMethodInvalid
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpRequestMethodInvalid() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestMethodInvalid()
}
func (v *ErrorCode) GetHttpRequestUriInvalid() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestUriInvalid); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestUriInvalid() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestUriInvalid
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpRequestUriInvalid() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestUriInvalid()
}
func (v *ErrorCode) GetHttpRequestUriTooLong() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestUriTooLong); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestUriTooLong() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestUriTooLong
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpRequestUriTooLong() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestUriTooLong()
}
func (v *ErrorCode) GetHttpRequestHeaderSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestHeaderSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpRequestHeaderSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestHeaderSectionSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpRequestHeaderSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestHeaderSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestHeaderSize() (payload *FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestHeaderSize); !ok {
		return
	}
	payload, ok = v.payload.(*FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpRequestHeaderSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestHeaderSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpRequestHeaderSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestHeaderSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestTrailerSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestTrailerSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpRequestTrailerSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestTrailerSectionSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpRequestTrailerSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestTrailerSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestTrailerSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpRequestTrailerSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpRequestTrailerSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpRequestTrailerSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpRequestTrailerSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestTrailerSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseIncomplete() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseIncomplete); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpResponseIncomplete() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseIncomplete
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpResponseIncomplete() *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseIncomplete()
}
func (v *ErrorCode) GetHttpResponseHeaderSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseHeaderSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpResponseHeaderSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseHeaderSectionSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseHeaderSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseHeaderSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseHeaderSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseHeaderSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpResponseHeaderSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseHeaderSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseHeaderSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseHeaderSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseBodySize() (payload *uint64, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseBodySize); !ok {
		return
	}
	payload, ok = v.payload.(*uint64)
	return
}
func (v *ErrorCode) SetHttpResponseBodySize(payload *uint64) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseBodySize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseBodySize(payload *uint64) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseBodySize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTrailerSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseTrailerSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpResponseTrailerSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseTrailerSectionSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseTrailerSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTrailerSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTrailerSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseTrailerSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpResponseTrailerSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseTrailerSize
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseTrailerSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTrailerSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTransferCoding() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseTransferCoding); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}
func (v *ErrorCode) SetHttpResponseTransferCoding(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseTransferCoding
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseTransferCoding(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTransferCoding(
		payload)
}
func (v *ErrorCode) GetHttpResponseContentCoding() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseContentCoding); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}
func (v *ErrorCode) SetHttpResponseContentCoding(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseContentCoding
	v.payload = payload
	return v
}
func (ErrorCode) NewHttpResponseContentCoding(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseContentCoding(
		payload)
}
func (v *ErrorCode) GetHttpResponseTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpResponseTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpResponseTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpResponseTimeout
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpResponseTimeout() *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTimeout()
}
func (v *ErrorCode) GetHttpUpgradeFailed() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpUpgradeFailed); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpUpgradeFailed() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpUpgradeFailed
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpUpgradeFailed() *ErrorCode {
	return (&ErrorCode{}).SetHttpUpgradeFailed()
}
func (v *ErrorCode) GetHttpProtocolError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_HttpProtocolError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpProtocolError() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_HttpProtocolError
	v.payload = nil
	return v
}
func (ErrorCode) NewHttpProtocolError() *ErrorCode {
	return (&ErrorCode{}).SetHttpProtocolError()
}
func (v *ErrorCode) GetLoopDetected() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_LoopDetected); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetLoopDetected() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_LoopDetected
	v.payload = nil
	return v
}
func (ErrorCode) NewLoopDetected() *ErrorCode {
	return (&ErrorCode{}).SetLoopDetected()
}
func (v *ErrorCode) GetConfigurationError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_ConfigurationError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConfigurationError() *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_ConfigurationError
	v.payload = nil
	return v
}
func (ErrorCode) NewConfigurationError() *ErrorCode {
	return (&ErrorCode{}).SetConfigurationError()
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func (v *ErrorCode) GetInternalError() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeDiscriminant_InternalError); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func (v *ErrorCode) SetInternalError(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeDiscriminant_InternalError
	v.payload = payload
	return v
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func (ErrorCode) NewInternalError(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetInternalError(
		payload)
}
func (v *ErrorCode) Error() string { return v.String() }
func (v *ErrorCode) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w wrpc.ByteWriter) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorCodeDiscriminant_DnsTimeout:
	case ErrorCodeDiscriminant_DnsError:
		payload, ok := v.payload.(*DnsErrorPayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(1)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_DestinationNotFound:
	case ErrorCodeDiscriminant_DestinationUnavailable:
	case ErrorCodeDiscriminant_DestinationIpProhibited:
	case ErrorCodeDiscriminant_DestinationIpUnroutable:
	case ErrorCodeDiscriminant_ConnectionRefused:
	case ErrorCodeDiscriminant_ConnectionTerminated:
	case ErrorCodeDiscriminant_ConnectionTimeout:
	case ErrorCodeDiscriminant_ConnectionReadTimeout:
	case ErrorCodeDiscriminant_ConnectionWriteTimeout:
	case ErrorCodeDiscriminant_ConnectionLimitReached:
	case ErrorCodeDiscriminant_TlsProtocolError:
	case ErrorCodeDiscriminant_TlsCertificateError:
	case ErrorCodeDiscriminant_TlsAlertReceived:
		payload, ok := v.payload.(*TlsAlertReceivedPayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(14)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpRequestDenied:
	case ErrorCodeDiscriminant_HttpRequestLengthRequired:
	case ErrorCodeDiscriminant_HttpRequestBodySize:
		payload, ok := v.payload.(*uint64)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint64, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen64); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u64"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(17)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpRequestMethodInvalid:
	case ErrorCodeDiscriminant_HttpRequestUriInvalid:
	case ErrorCodeDiscriminant_HttpRequestUriTooLong:
	case ErrorCodeDiscriminant_HttpRequestHeaderSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen32); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u32"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(21)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpRequestHeaderSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *FieldSizePayload, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (*v).WriteToIndex(w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(22)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpRequestTrailerSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen32); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u32"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(23)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpRequestTrailerSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(24)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseIncomplete:
	case ErrorCodeDiscriminant_HttpResponseHeaderSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen32); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u32"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(26)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseHeaderSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(27)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseBodySize:
		payload, ok := v.payload.(*uint64)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint64, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen64); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u64"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(28)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseTrailerSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w interface {
				io.ByteWriter
				io.Writer
			}) (err error) { b := make([]byte, binary.MaxVarintLen32); i := binary.PutUvarint(b, uint64(v)); slog.Debug("writing u32"); _, err = w.Write(b[:i]); return err }(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(29)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseTrailerSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(30)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseTransferCoding:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(31)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseContentCoding:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(32)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDiscriminant_HttpResponseTimeout:
	case ErrorCodeDiscriminant_HttpUpgradeFailed:
	case ErrorCodeDiscriminant_HttpProtocolError:
	case ErrorCodeDiscriminant_LoopDetected:
	case ErrorCodeDiscriminant_ConfigurationError:
	case ErrorCodeDiscriminant_InternalError:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(38)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// This type enumerates the different kinds of errors that may occur when
// setting or appending to a `fields` resource.
type HeaderError struct {
	payload      any
	discriminant HeaderErrorDiscriminant
}

func (v *HeaderError) Discriminant() HeaderErrorDiscriminant { return v.discriminant }

type HeaderErrorDiscriminant uint8

const (
	// This error indicates that a `field-key` or `field-value` was
	// syntactically invalid when used with an operation that sets headers in a
	// `fields`.
	HeaderErrorDiscriminant_InvalidSyntax HeaderErrorDiscriminant = 0
	// This error indicates that a forbidden `field-key` was used when trying
	// to set a header in a `fields`.
	HeaderErrorDiscriminant_Forbidden HeaderErrorDiscriminant = 1
	// This error indicates that the operation on the `fields` was not
	// permitted because the fields are immutable.
	HeaderErrorDiscriminant_Immutable HeaderErrorDiscriminant = 2
)

func (v *HeaderError) String() string {
	switch v.discriminant {
	case HeaderErrorDiscriminant_InvalidSyntax:
		return "invalid-syntax"
	case HeaderErrorDiscriminant_Forbidden:
		return "forbidden"
	case HeaderErrorDiscriminant_Immutable:
		return "immutable"
	default:
		panic("invalid variant")
	}
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func (v *HeaderError) GetInvalidSyntax() (ok bool) {
	if ok = (v.discriminant == HeaderErrorDiscriminant_InvalidSyntax); !ok {
		return
	}
	return
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func (v *HeaderError) SetInvalidSyntax() *HeaderError {
	v.discriminant = HeaderErrorDiscriminant_InvalidSyntax
	v.payload = nil
	return v
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func (HeaderError) NewInvalidSyntax() *HeaderError {
	return (&HeaderError{}).SetInvalidSyntax()
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func (v *HeaderError) GetForbidden() (ok bool) {
	if ok = (v.discriminant == HeaderErrorDiscriminant_Forbidden); !ok {
		return
	}
	return
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func (v *HeaderError) SetForbidden() *HeaderError {
	v.discriminant = HeaderErrorDiscriminant_Forbidden
	v.payload = nil
	return v
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func (HeaderError) NewForbidden() *HeaderError {
	return (&HeaderError{}).SetForbidden()
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func (v *HeaderError) GetImmutable() (ok bool) {
	if ok = (v.discriminant == HeaderErrorDiscriminant_Immutable); !ok {
		return
	}
	return
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func (v *HeaderError) SetImmutable() *HeaderError {
	v.discriminant = HeaderErrorDiscriminant_Immutable
	v.payload = nil
	return v
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func (HeaderError) NewImmutable() *HeaderError {
	return (&HeaderError{}).SetImmutable()
}
func (v *HeaderError) Error() string { return v.String() }
func (v *HeaderError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w wrpc.ByteWriter) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case HeaderErrorDiscriminant_InvalidSyntax:
	case HeaderErrorDiscriminant_Forbidden:
	case HeaderErrorDiscriminant_Immutable:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Field keys are always strings.
type FieldKey = string

// Field values should always be ASCII strings. However, in
// reality, HTTP implementations often have to interpret malformed values,
// so they are provided as a list of bytes.
type FieldValue = []uint8

// Headers is an alias for Fields.
type Headers = Fields

// Trailers is an alias for Fields.
type Trailers = Fields

// This type corresponds to the HTTP standard Status Code.
type StatusCode = uint16

// Attempts to extract a http-related `error` from the wasi:io `error`
// provided.
//
// Stream operations which return
// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
// type `wasi:io/error/error` with more information about the operation
// that failed. This payload can be passed through to this function to see
// if there's http-related information about the error to return.
//
// Note that this function is fallible because not all io-errors are
// http-related errors.
func HttpErrorCode(ctx__ context.Context, wrpc__ wrpc.Client, err IoError) (r0__ *ErrorCode, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "http-error-code", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing borrowed handles not supported yet") }(err)
		if err__ != nil {
			return fmt.Errorf("failed to write `err` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
					v := &ErrorCode{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch ErrorCodeDiscriminant(n) {
					case ErrorCodeDiscriminant_DnsTimeout:
						return v.SetDnsTimeout(), nil
					case ErrorCodeDiscriminant_DnsError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
							v := &DnsErrorPayload{}
							var err error
							slog.Debug("reading field", "name", "rcode")
							v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
							}
							slog.Debug("reading field", "name", "info-code")
							v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint16, error) {
										var x uint16
										var s uint
										for i := 0; i < 3; i++ {
											slog.Debug("reading u16 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u16 byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("varint overflows a 16-bit integer")
												}
												return x | uint16(b)<<s, nil
											}
											x |= uint16(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 16-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
						}
						return v.SetDnsError(payload), nil
					case ErrorCodeDiscriminant_DestinationNotFound:
						return v.SetDestinationNotFound(), nil
					case ErrorCodeDiscriminant_DestinationUnavailable:
						return v.SetDestinationUnavailable(), nil
					case ErrorCodeDiscriminant_DestinationIpProhibited:
						return v.SetDestinationIpProhibited(), nil
					case ErrorCodeDiscriminant_DestinationIpUnroutable:
						return v.SetDestinationIpUnroutable(), nil
					case ErrorCodeDiscriminant_ConnectionRefused:
						return v.SetConnectionRefused(), nil
					case ErrorCodeDiscriminant_ConnectionTerminated:
						return v.SetConnectionTerminated(), nil
					case ErrorCodeDiscriminant_ConnectionTimeout:
						return v.SetConnectionTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionReadTimeout:
						return v.SetConnectionReadTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionWriteTimeout:
						return v.SetConnectionWriteTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionLimitReached:
						return v.SetConnectionLimitReached(), nil
					case ErrorCodeDiscriminant_TlsProtocolError:
						return v.SetTlsProtocolError(), nil
					case ErrorCodeDiscriminant_TlsCertificateError:
						return v.SetTlsCertificateError(), nil
					case ErrorCodeDiscriminant_TlsAlertReceived:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
							v := &TlsAlertReceivedPayload{}
							var err error
							slog.Debug("reading field", "name", "alert-id")
							v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint8, error) {
										slog.Debug("reading u8 byte")
										v, err := r.ReadByte()
										if err != nil {
											return 0, fmt.Errorf("failed to read u8 byte: %w", err)
										}
										return v, nil
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
							}
							slog.Debug("reading field", "name", "alert-message")
							v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
						}
						return v.SetTlsAlertReceived(payload), nil
					case ErrorCodeDiscriminant_HttpRequestDenied:
						return v.SetHttpRequestDenied(), nil
					case ErrorCodeDiscriminant_HttpRequestLengthRequired:
						return v.SetHttpRequestLengthRequired(), nil
					case ErrorCodeDiscriminant_HttpRequestBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
						}
						return v.SetHttpRequestBodySize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestMethodInvalid:
						return v.SetHttpRequestMethodInvalid(), nil
					case ErrorCodeDiscriminant_HttpRequestUriInvalid:
						return v.SetHttpRequestUriInvalid(), nil
					case ErrorCodeDiscriminant_HttpRequestUriTooLong:
						return v.SetHttpRequestUriTooLong(), nil
					case ErrorCodeDiscriminant_HttpRequestHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
									v := &FieldSizePayload{}
									var err error
									slog.Debug("reading field", "name", "field-name")
									v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 0)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
									}
									slog.Debug("reading field", "name", "field-size")
									v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 1)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
									}
									return v, nil
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseIncomplete:
						return v.SetHttpResponseIncomplete(), nil
					case ErrorCodeDiscriminant_HttpResponseHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
						}
						return v.SetHttpResponseBodySize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTransferCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
						}
						return v.SetHttpResponseTransferCoding(payload), nil
					case ErrorCodeDiscriminant_HttpResponseContentCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
						}
						return v.SetHttpResponseContentCoding(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTimeout:
						return v.SetHttpResponseTimeout(), nil
					case ErrorCodeDiscriminant_HttpUpgradeFailed:
						return v.SetHttpUpgradeFailed(), nil
					case ErrorCodeDiscriminant_HttpProtocolError:
						return v.SetHttpProtocolError(), nil
					case ErrorCodeDiscriminant_LoopDetected:
						return v.SetLoopDetected(), nil
					case ErrorCodeDiscriminant_ConfigurationError:
						return v.SetConfigurationError(), nil
					case ErrorCodeDiscriminant_InternalError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
						}
						return v.SetInternalError(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `http-error-code`: %w", err__)
		return
	}
	return
}

// Construct an empty HTTP Fields.
//
// The resulting `fields` is mutable.
func NewFields(ctx__ context.Context, wrpc__ wrpc.Client) (r0__ any, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[constructor]fields", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = (Fields)(nil), errors.New("reading owned handles not supported yet")
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]fields`: %w", err__)
		return
	}
	return
}

// Construct an HTTP Fields.
//
// The resulting `fields` is mutable.
//
// The list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
//
// The tuple is a pair of the field key, represented as a string, and
// Value, represented as a list of bytes. In a valid Fields, all keys
// and values are valid UTF-8 strings. However, values are not always
// well-formed, so they are represented as a raw list of bytes.
//
// An error result will be returned if any header or value was
// syntactically invalid, or if a header was forbidden.
func Fields_FromList(ctx__ context.Context, wrpc__ wrpc.Client, entries []*wrpc.Tuple2[string, []uint8]) (r0__ *wrpc.Result[Fields, HeaderError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[static]fields.from-list", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := func(v []*wrpc.Tuple2[string, []uint8], w wrpc.ByteWriter) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := func(v *wrpc.Tuple2[string, []uint8], w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
					writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
					slog.Debug("writing tuple element 0")
					write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing string byte length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
						}
						slog.Debug("writing string bytes")
						_, err = w.Write([]byte(v))
						if err != nil {
							return fmt.Errorf("failed to write string bytes: %w", err)
						}
						return nil
					}(v.V0, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
					}
					if write0 != nil {
						writes[0] = write0
					}
					slog.Debug("writing tuple element 1")
					write1, err := func(v []uint8, w wrpc.ByteWriter) (write func(wrpc.IndexWriter) error, err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing list length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
						for i, e := range v {
							write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
								slog.Debug("writing u8 byte")
								return w.WriteByte(v)
							}(e, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
							}
							if write != nil {
								writes[uint32(i)] = write
							}
						}
						if len(writes) > 0 {
							return func(w wrpc.IndexWriter) error {
								var wg errgroup.Group
								for index, write := range writes {
									w, err := w.Index(index)
									if err != nil {
										return fmt.Errorf("failed to index writer: %w", err)
									}
									write := write
									wg.Go(func() error {
										return write(w)
									})
								}
								return wg.Wait()
							}, nil
						}
						return nil, nil
					}(v.V1, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
					}
					if write1 != nil {
						writes[1] = write1
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(entries, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `entries` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[Fields, HeaderError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := (Fields)(nil), errors.New("reading owned handles not supported yet")
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[Fields, HeaderError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*HeaderError, error) {
					v := &HeaderError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch HeaderErrorDiscriminant(n) {
					case HeaderErrorDiscriminant_InvalidSyntax:
						return v.SetInvalidSyntax(), nil
					case HeaderErrorDiscriminant_Forbidden:
						return v.SetForbidden(), nil
					case HeaderErrorDiscriminant_Immutable:
						return v.SetImmutable(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[Fields, HeaderError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]fields.from-list`: %w", err__)
		return
	}
	return
}

// Construct a new `outgoing-request` with a default `method` of `GET`, and
// `none` values for `path-with-query`, `scheme`, and `authority`.
//
// * `headers` is the HTTP Headers for the Request.
//
// It is possible to construct, or manipulate with the accessor functions
// below, an `outgoing-request` with an invalid combination of `scheme`
// and `authority`, or `headers` which are not permitted to be sent.
// It is the obligation of the `outgoing-handler.handle` implementation
// to reject invalid constructions of `outgoing-request`.
func NewOutgoingRequest(ctx__ context.Context, wrpc__ wrpc.Client, headers Headers) (r0__ any, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[constructor]outgoing-request", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(headers)
		if err__ != nil {
			return fmt.Errorf("failed to write `headers` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = (OutgoingRequest)(nil), errors.New("reading owned handles not supported yet")
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]outgoing-request`: %w", err__)
		return
	}
	return
}

// Construct a default `request-options` value.
func NewRequestOptions(ctx__ context.Context, wrpc__ wrpc.Client) (r0__ any, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[constructor]request-options", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = (RequestOptions)(nil), errors.New("reading owned handles not supported yet")
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]request-options`: %w", err__)
		return
	}
	return
}

// Set the value of the `response-outparam` to either send a response,
// or indicate an error.
//
// This method consumes the `response-outparam` to ensure that it is
// called at most once. If it is never called, the implementation
// will respond with an error.
//
// The user may provide an `error` to `response` to allow the
// implementation determine how to respond with an HTTP error response.
func ResponseOutparam_Set(ctx__ context.Context, wrpc__ wrpc.Client, param ResponseOutparam, response *wrpc.Result[OutgoingResponse, ErrorCode]) (close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[static]response-outparam.set", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(param)
		if err__ != nil {
			return fmt.Errorf("failed to write `param` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *wrpc.Result[OutgoingResponse, ErrorCode], w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(*v.Ok)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (*v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(response, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `response` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]response-outparam.set`: %w", err__)
		return
	}
	return
}

// Takes ownership of `incoming-body`, and returns a `future-trailers`.
// This function will trap if the `input-stream` child is still alive.
func IncomingBody_Finish(ctx__ context.Context, wrpc__ wrpc.Client, this IncomingBody) (r0__ FutureTrailers, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[static]incoming-body.finish", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(this)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = (FutureTrailers)(nil), errors.New("reading owned handles not supported yet")
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]incoming-body.finish`: %w", err__)
		return
	}
	return
}

// Construct an `outgoing-response`, with a default `status-code` of `200`.
// If a different `status-code` is needed, it must be set via the
// `set-status-code` method.
//
// * `headers` is the HTTP Headers for the Response.
func NewOutgoingResponse(ctx__ context.Context, wrpc__ wrpc.Client, headers Headers) (r0__ any, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[constructor]outgoing-response", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(headers)
		if err__ != nil {
			return fmt.Errorf("failed to write `headers` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = (OutgoingResponse)(nil), errors.New("reading owned handles not supported yet")
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]outgoing-response`: %w", err__)
		return
	}
	return
}

// Finalize an outgoing body, optionally providing trailers. This must be
// called to signal that the response is complete. If the `outgoing-body`
// is dropped without calling `outgoing-body.finalize`, the implementation
// should treat the body as corrupted.
//
// Fails if the body's `outgoing-request` or `outgoing-response` was
// constructed with a Content-Length header, and the contents written
// to the body (via `write`) does not match the value given in the
// Content-Length.
func OutgoingBody_Finish(ctx__ context.Context, wrpc__ wrpc.Client, this OutgoingBody, trailers *Trailers) (r0__ *wrpc.Result[struct{}, ErrorCode], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "[static]outgoing-body.finish", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(this)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *Trailers, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(any) error { return errors.New("writing owned handles not supported yet") }(*v)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(trailers, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `trailers` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, ErrorCode], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, ErrorCode]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
					v := &ErrorCode{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch ErrorCodeDiscriminant(n) {
					case ErrorCodeDiscriminant_DnsTimeout:
						return v.SetDnsTimeout(), nil
					case ErrorCodeDiscriminant_DnsError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
							v := &DnsErrorPayload{}
							var err error
							slog.Debug("reading field", "name", "rcode")
							v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
							}
							slog.Debug("reading field", "name", "info-code")
							v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint16, error) {
										var x uint16
										var s uint
										for i := 0; i < 3; i++ {
											slog.Debug("reading u16 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u16 byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("varint overflows a 16-bit integer")
												}
												return x | uint16(b)<<s, nil
											}
											x |= uint16(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 16-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
						}
						return v.SetDnsError(payload), nil
					case ErrorCodeDiscriminant_DestinationNotFound:
						return v.SetDestinationNotFound(), nil
					case ErrorCodeDiscriminant_DestinationUnavailable:
						return v.SetDestinationUnavailable(), nil
					case ErrorCodeDiscriminant_DestinationIpProhibited:
						return v.SetDestinationIpProhibited(), nil
					case ErrorCodeDiscriminant_DestinationIpUnroutable:
						return v.SetDestinationIpUnroutable(), nil
					case ErrorCodeDiscriminant_ConnectionRefused:
						return v.SetConnectionRefused(), nil
					case ErrorCodeDiscriminant_ConnectionTerminated:
						return v.SetConnectionTerminated(), nil
					case ErrorCodeDiscriminant_ConnectionTimeout:
						return v.SetConnectionTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionReadTimeout:
						return v.SetConnectionReadTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionWriteTimeout:
						return v.SetConnectionWriteTimeout(), nil
					case ErrorCodeDiscriminant_ConnectionLimitReached:
						return v.SetConnectionLimitReached(), nil
					case ErrorCodeDiscriminant_TlsProtocolError:
						return v.SetTlsProtocolError(), nil
					case ErrorCodeDiscriminant_TlsCertificateError:
						return v.SetTlsCertificateError(), nil
					case ErrorCodeDiscriminant_TlsAlertReceived:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
							v := &TlsAlertReceivedPayload{}
							var err error
							slog.Debug("reading field", "name", "alert-id")
							v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint8, error) {
										slog.Debug("reading u8 byte")
										v, err := r.ReadByte()
										if err != nil {
											return 0, fmt.Errorf("failed to read u8 byte: %w", err)
										}
										return v, nil
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
							}
							slog.Debug("reading field", "name", "alert-message")
							v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
						}
						return v.SetTlsAlertReceived(payload), nil
					case ErrorCodeDiscriminant_HttpRequestDenied:
						return v.SetHttpRequestDenied(), nil
					case ErrorCodeDiscriminant_HttpRequestLengthRequired:
						return v.SetHttpRequestLengthRequired(), nil
					case ErrorCodeDiscriminant_HttpRequestBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
						}
						return v.SetHttpRequestBodySize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestMethodInvalid:
						return v.SetHttpRequestMethodInvalid(), nil
					case ErrorCodeDiscriminant_HttpRequestUriInvalid:
						return v.SetHttpRequestUriInvalid(), nil
					case ErrorCodeDiscriminant_HttpRequestUriTooLong:
						return v.SetHttpRequestUriTooLong(), nil
					case ErrorCodeDiscriminant_HttpRequestHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
									v := &FieldSizePayload{}
									var err error
									slog.Debug("reading field", "name", "field-name")
									v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 0)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
									}
									slog.Debug("reading field", "name", "field-size")
									v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 1)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
									}
									return v, nil
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpRequestTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseIncomplete:
						return v.SetHttpResponseIncomplete(), nil
					case ErrorCodeDiscriminant_HttpResponseHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
						}
						return v.SetHttpResponseBodySize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSectionSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSize(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTransferCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
						}
						return v.SetHttpResponseTransferCoding(payload), nil
					case ErrorCodeDiscriminant_HttpResponseContentCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
						}
						return v.SetHttpResponseContentCoding(payload), nil
					case ErrorCodeDiscriminant_HttpResponseTimeout:
						return v.SetHttpResponseTimeout(), nil
					case ErrorCodeDiscriminant_HttpUpgradeFailed:
						return v.SetHttpUpgradeFailed(), nil
					case ErrorCodeDiscriminant_HttpProtocolError:
						return v.SetHttpProtocolError(), nil
					case ErrorCodeDiscriminant_LoopDetected:
						return v.SetLoopDetected(), nil
					case ErrorCodeDiscriminant_ConfigurationError:
						return v.SetConfigurationError(), nil
					case ErrorCodeDiscriminant_InternalError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
						}
						return v.SetInternalError(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, ErrorCode]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]outgoing-body.finish`: %w", err__)
		return
	}
	return
}

type Fields interface {
	// Get all of the values corresponding to a key. If the key is not present
	// in this `fields`, an empty list is returned. However, if the key is
	// present but empty, this is represented by a list with one or more
	// empty field-values present.
	Get(ctx__ context.Context, wrpc__ wrpc.Client, name string) ([][]uint8, func() error, error)
	// Returns `true` when the key is present in this `fields`. If the key is
	// syntactically invalid, `false` is returned.
	Has(ctx__ context.Context, wrpc__ wrpc.Client, name string) (bool, func() error, error)
	// Set all of the values for a key. Clears any existing values for that
	// key, if they have been set.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Set(ctx__ context.Context, wrpc__ wrpc.Client, name string, value [][]uint8) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Delete all values for a key. Does nothing if no values for the key
	// exist.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Delete(ctx__ context.Context, wrpc__ wrpc.Client, name string) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Append a value for a key. Does not change or delete any existing
	// values for that key.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Append(ctx__ context.Context, wrpc__ wrpc.Client, name string, value []uint8) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Retrieve the full set of keys and values in the Fields. Like the
	// constructor, the list represents each key-value pair.
	//
	// The outer list represents each key-value pair in the Fields. Keys
	// which have multiple values are represented by multiple entries in this
	// list with the same key.
	Entries(ctx__ context.Context, wrpc__ wrpc.Client) ([]*wrpc.Tuple2[string, []uint8], func() error, error)
	// Make a deep copy of the Fields. Equivelant in behavior to calling the
	// `fields` constructor on the return value of `entries`. The resulting
	// `fields` is mutable.
	Clone(ctx__ context.Context, wrpc__ wrpc.Client) (Fields, func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type IncomingRequest interface {
	// Returns the method of the incoming request.
	Method(ctx__ context.Context, wrpc__ wrpc.Client) (*Method, func() error, error)
	// Returns the path with query parameters from the request, as a string.
	PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Returns the protocol scheme from the request.
	Scheme(ctx__ context.Context, wrpc__ wrpc.Client) (*Scheme, func() error, error)
	// Returns the authority from the request, if it was present.
	Authority(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Get the `headers` associated with the request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// The `headers` returned are a child resource: it must be dropped before
	// the parent `incoming-request` is dropped. Dropping this
	// `incoming-request` before all children are dropped will trap.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (Headers, func() error, error)
	// Gives the `incoming-body` associated with this request. Will only
	// return success at most once, and subsequent calls will return error.
	Consume(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[IncomingBody, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type OutgoingRequest interface {
	// Returns the resource corresponding to the outgoing Body for this
	// Request.
	//
	// Returns success on the first call: the `outgoing-body` resource for
	// this `outgoing-request` can be retrieved at most once. Subsequent
	// calls will return error.
	Body(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[OutgoingBody, struct{}], func() error, error)
	// Get the Method for the Request.
	Method(ctx__ context.Context, wrpc__ wrpc.Client) (*Method, func() error, error)
	// Set the Method for the Request. Fails if the string present in a
	// `method.other` argument is not a syntactically valid method.
	SetMethod(ctx__ context.Context, wrpc__ wrpc.Client, method *Method) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the combination of the HTTP Path and Query for the Request.
	// When `none`, this represents an empty Path and empty Query.
	PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Set the combination of the HTTP Path and Query for the Request.
	// When `none`, this represents an empty Path and empty Query. Fails is the
	// string given is not a syntactically valid path and query uri component.
	SetPathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client, pathWithQuery *string) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the HTTP Related Scheme for the Request. When `none`, the
	// implementation may choose an appropriate default scheme.
	Scheme(ctx__ context.Context, wrpc__ wrpc.Client) (*Scheme, func() error, error)
	// Set the HTTP Related Scheme for the Request. When `none`, the
	// implementation may choose an appropriate default scheme. Fails if the
	// string given is not a syntactically valid uri scheme.
	SetScheme(ctx__ context.Context, wrpc__ wrpc.Client, scheme *Scheme) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the HTTP Authority for the Request. A value of `none` may be used
	// with Related Schemes which do not require an Authority. The HTTP and
	// HTTPS schemes always require an authority.
	Authority(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Set the HTTP Authority for the Request. A value of `none` may be used
	// with Related Schemes which do not require an Authority. The HTTP and
	// HTTPS schemes always require an authority. Fails if the string given is
	// not a syntactically valid uri authority.
	SetAuthority(ctx__ context.Context, wrpc__ wrpc.Client, authority *string) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the headers associated with the Request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `outgoing-request` is dropped, or its ownership is transfered to
	// another component by e.g. `outgoing-handler.handle`.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (Headers, func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type RequestOptions interface {
	// The timeout for the initial connect to the HTTP Server.
	ConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for the initial connect to the HTTP Server. An error
	// return value indicates that this timeout is not supported.
	SetConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// The timeout for receiving the first byte of the Response body.
	FirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for receiving the first byte of the Response body. An
	// error return value indicates that this timeout is not supported.
	SetFirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// The timeout for receiving subsequent chunks of bytes in the Response
	// body stream.
	BetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for receiving subsequent chunks of bytes in the Response
	// body stream. An error return value indicates that this timeout is not
	// supported.
	SetBetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type ResponseOutparam interface {
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type IncomingResponse interface {
	// Returns the status code from the incoming response.
	Status(ctx__ context.Context, wrpc__ wrpc.Client) (uint16, func() error, error)
	// Returns the headers from the incoming response.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `incoming-response` is dropped.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (Headers, func() error, error)
	// Returns the incoming body. May be called at most once. Returns error
	// if called additional times.
	Consume(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[IncomingBody, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type IncomingBody interface {
	// Returns the contents of the body, as a stream of bytes.
	//
	// Returns success on first call: the stream representing the contents
	// can be retrieved at most once. Subsequent calls will return error.
	//
	// The returned `input-stream` resource is a child: it must be dropped
	// before the parent `incoming-body` is dropped, or consumed by
	// `incoming-body.finish`.
	//
	// This invariant ensures that the implementation can determine whether
	// the user is consuming the contents of the body, waiting on the
	// `future-trailers` to be ready, or neither. This allows for network
	// backpressure is to be applied when the user is consuming the body,
	// and for that backpressure to not inhibit delivery of the trailers if
	// the user does not read the entire body.
	Stream(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[InputStream, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type FutureTrailers interface {
	// Returns a pollable which becomes ready when either the trailers have
	// been received, or an error has occured. When this pollable is ready,
	// the `get` method will return `some`.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (Pollable, func() error, error)
	// Returns the contents of the trailers, or an error which occured,
	// once the future is ready.
	//
	// The outer `option` represents future readiness. Users can wait on this
	// `option` to become `some` using the `subscribe` method.
	//
	// The outer `result` is used to retrieve the trailers or error at most
	// once. It will be success on the first call in which the outer option
	// is `some`, and error on subsequent calls.
	//
	// The inner `result` represents that either the HTTP Request or Response
	// body, as well as any trailers, were received successfully, or that an
	// error occured receiving them. The optional `trailers` indicates whether
	// or not trailers were present in the body.
	//
	// When some `trailers` are returned by this method, the `trailers`
	// resource is immutable, and a child. Use of the `set`, `append`, or
	// `delete` methods will return an error, and the resource must be
	// dropped before the parent `future-trailers` is dropped.
	Get(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Result[*Trailers, ErrorCode], struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type OutgoingResponse interface {
	// Get the HTTP Status Code for the Response.
	StatusCode(ctx__ context.Context, wrpc__ wrpc.Client) (uint16, func() error, error)
	// Set the HTTP Status Code for the Response. Fails if the status-code
	// given is not a valid http status code.
	SetStatusCode(ctx__ context.Context, wrpc__ wrpc.Client, statusCode uint16) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the headers associated with the Request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `outgoing-request` is dropped, or its ownership is transfered to
	// another component by e.g. `outgoing-handler.handle`.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (Headers, func() error, error)
	// Returns the resource corresponding to the outgoing Body for this Response.
	//
	// Returns success on the first call: the `outgoing-body` resource for
	// this `outgoing-response` can be retrieved at most once. Subsequent
	// calls will return error.
	Body(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[OutgoingBody, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type OutgoingBody interface {
	// Returns a stream for writing the body contents.
	//
	// The returned `output-stream` is a child resource: it must be dropped
	// before the parent `outgoing-body` resource is dropped (or finished),
	// otherwise the `outgoing-body` drop or `finish` will trap.
	//
	// Returns success on the first call: the `output-stream` resource for
	// this `outgoing-body` may be retrieved at most once. Subsequent calls
	// will return error.
	Write(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[OutputStream, struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
type FutureIncomingResponse interface {
	// Returns a pollable which becomes ready when either the Response has
	// been received, or an error has occured. When this pollable is ready,
	// the `get` method will return `some`.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (Pollable, func() error, error)
	// Returns the incoming HTTP Response, or an error, once one is ready.
	//
	// The outer `option` represents future readiness. Users can wait on this
	// `option` to become `some` using the `subscribe` method.
	//
	// The outer `result` is used to retrieve the response or error at most
	// once. It will be success on the first call in which the outer option
	// is `some`, and error on subsequent calls.
	//
	// The inner `result` represents that either the incoming HTTP Response
	// status and headers have recieved successfully, or that an error
	// occured. Errors may also occur while consuming the response body,
	// but those will be reported by the `incoming-body` and its
	// `output-stream` child.
	Get(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Result[IncomingResponse, ErrorCode], struct{}], func() error, error)
	Drop(ctx__ context.Context, wrpc__ wrpc.Client) error
}
