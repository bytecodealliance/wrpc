// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package types

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasi__clocks__monotonic_clock "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/clocks/monotonic_clock"
	wasi__io__error "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/error"
	wasi__io__poll "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/poll"
	wasi__io__streams "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/io/streams"
	wrpc "github.com/wrpc/wrpc/go"
	errgroup "golang.org/x/sync/errgroup"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
)

type Duration = wasi__clocks__monotonic_clock.Duration
type InputStream = wasi__io__streams.InputStream
type OutputStream = wasi__io__streams.OutputStream
type IoError = wasi__io__error.Error
type Pollable = wasi__io__poll.Pollable

// This type corresponds to HTTP standard Methods.
type Method struct {
	payload      any
	discriminant MethodDiscriminant
}

func (v *Method) Discriminant() MethodDiscriminant { return v.discriminant }

type MethodDiscriminant uint8

const (
	MethodGet     MethodDiscriminant = 0
	MethodHead    MethodDiscriminant = 1
	MethodPost    MethodDiscriminant = 2
	MethodPut     MethodDiscriminant = 3
	MethodDelete  MethodDiscriminant = 4
	MethodConnect MethodDiscriminant = 5
	MethodOptions MethodDiscriminant = 6
	MethodTrace   MethodDiscriminant = 7
	MethodPatch   MethodDiscriminant = 8
	MethodOther   MethodDiscriminant = 9
)

func (v *Method) String() string {
	switch v.discriminant {
	case MethodGet:
		return "get"
	case MethodHead:
		return "head"
	case MethodPost:
		return "post"
	case MethodPut:
		return "put"
	case MethodDelete:
		return "delete"
	case MethodConnect:
		return "connect"
	case MethodOptions:
		return "options"
	case MethodTrace:
		return "trace"
	case MethodPatch:
		return "patch"
	case MethodOther:
		return "other"
	default:
		panic("invalid variant")
	}
}
func (v *Method) GetGet() (ok bool) {
	if ok = (v.discriminant == MethodGet); !ok {
		return
	}
	return
}
func (v *Method) SetGet() *Method {
	v.discriminant = MethodGet
	v.payload = nil
	return v
}
func NewMethodGet() *Method {
	return (&Method{}).SetGet()
}
func (v *Method) GetHead() (ok bool) {
	if ok = (v.discriminant == MethodHead); !ok {
		return
	}
	return
}
func (v *Method) SetHead() *Method {
	v.discriminant = MethodHead
	v.payload = nil
	return v
}
func NewMethodHead() *Method {
	return (&Method{}).SetHead()
}
func (v *Method) GetPost() (ok bool) {
	if ok = (v.discriminant == MethodPost); !ok {
		return
	}
	return
}
func (v *Method) SetPost() *Method {
	v.discriminant = MethodPost
	v.payload = nil
	return v
}
func NewMethodPost() *Method {
	return (&Method{}).SetPost()
}
func (v *Method) GetPut() (ok bool) {
	if ok = (v.discriminant == MethodPut); !ok {
		return
	}
	return
}
func (v *Method) SetPut() *Method {
	v.discriminant = MethodPut
	v.payload = nil
	return v
}
func NewMethodPut() *Method {
	return (&Method{}).SetPut()
}
func (v *Method) GetDelete() (ok bool) {
	if ok = (v.discriminant == MethodDelete); !ok {
		return
	}
	return
}
func (v *Method) SetDelete() *Method {
	v.discriminant = MethodDelete
	v.payload = nil
	return v
}
func NewMethodDelete() *Method {
	return (&Method{}).SetDelete()
}
func (v *Method) GetConnect() (ok bool) {
	if ok = (v.discriminant == MethodConnect); !ok {
		return
	}
	return
}
func (v *Method) SetConnect() *Method {
	v.discriminant = MethodConnect
	v.payload = nil
	return v
}
func NewMethodConnect() *Method {
	return (&Method{}).SetConnect()
}
func (v *Method) GetOptions() (ok bool) {
	if ok = (v.discriminant == MethodOptions); !ok {
		return
	}
	return
}
func (v *Method) SetOptions() *Method {
	v.discriminant = MethodOptions
	v.payload = nil
	return v
}
func NewMethodOptions() *Method {
	return (&Method{}).SetOptions()
}
func (v *Method) GetTrace() (ok bool) {
	if ok = (v.discriminant == MethodTrace); !ok {
		return
	}
	return
}
func (v *Method) SetTrace() *Method {
	v.discriminant = MethodTrace
	v.payload = nil
	return v
}
func NewMethodTrace() *Method {
	return (&Method{}).SetTrace()
}
func (v *Method) GetPatch() (ok bool) {
	if ok = (v.discriminant == MethodPatch); !ok {
		return
	}
	return
}
func (v *Method) SetPatch() *Method {
	v.discriminant = MethodPatch
	v.payload = nil
	return v
}
func NewMethodPatch() *Method {
	return (&Method{}).SetPatch()
}
func (v *Method) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == MethodOther); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *Method) SetOther(payload string) *Method {
	v.discriminant = MethodOther
	v.payload = payload
	return v
}
func NewMethodOther(payload string) *Method {
	return (&Method{}).SetOther(
		payload)
}
func (v *Method) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case MethodGet:
	case MethodHead:
	case MethodPost:
	case MethodPut:
	case MethodDelete:
	case MethodConnect:
	case MethodOptions:
	case MethodTrace:
	case MethodPatch:
	case MethodOther:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(9)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// This type corresponds to HTTP standard Related Schemes.
type Scheme struct {
	payload      any
	discriminant SchemeDiscriminant
}

func (v *Scheme) Discriminant() SchemeDiscriminant { return v.discriminant }

type SchemeDiscriminant uint8

const (
	SchemeHttp  SchemeDiscriminant = 0
	SchemeHttps SchemeDiscriminant = 1
	SchemeOther SchemeDiscriminant = 2
)

func (v *Scheme) String() string {
	switch v.discriminant {
	case SchemeHttp:
		return "HTTP"
	case SchemeHttps:
		return "HTTPS"
	case SchemeOther:
		return "other"
	default:
		panic("invalid variant")
	}
}
func (v *Scheme) GetHttp() (ok bool) {
	if ok = (v.discriminant == SchemeHttp); !ok {
		return
	}
	return
}
func (v *Scheme) SetHttp() *Scheme {
	v.discriminant = SchemeHttp
	v.payload = nil
	return v
}
func NewSchemeHttp() *Scheme {
	return (&Scheme{}).SetHttp()
}
func (v *Scheme) GetHttps() (ok bool) {
	if ok = (v.discriminant == SchemeHttps); !ok {
		return
	}
	return
}
func (v *Scheme) SetHttps() *Scheme {
	v.discriminant = SchemeHttps
	v.payload = nil
	return v
}
func NewSchemeHttps() *Scheme {
	return (&Scheme{}).SetHttps()
}
func (v *Scheme) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == SchemeOther); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *Scheme) SetOther(payload string) *Scheme {
	v.discriminant = SchemeOther
	v.payload = payload
	return v
}
func NewSchemeOther(payload string) *Scheme {
	return (&Scheme{}).SetOther(
		payload)
}
func (v *Scheme) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case SchemeHttp:
	case SchemeHttps:
	case SchemeOther:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(2)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Defines the case payload type for `DNS-error` above:
type DnsErrorPayload struct {
	Rcode    *string
	InfoCode *uint16
}

func (v *DnsErrorPayload) String() string { return "DnsErrorPayload" }

func (v *DnsErrorPayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "rcode")
	write0, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Rcode, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `rcode` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "info-code")
	write1, err := func(v *uint16, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint16, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen16)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u16")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.InfoCode, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `info-code` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// Defines the case payload type for `TLS-alert-received` above:
type TlsAlertReceivedPayload struct {
	AlertId      *uint8
	AlertMessage *string
}

func (v *TlsAlertReceivedPayload) String() string { return "TlsAlertReceivedPayload" }

func (v *TlsAlertReceivedPayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "alert-id")
	write0, err := func(v *uint8, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
			slog.Debug("writing u8 byte")
			return w.WriteByte(v)
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.AlertId, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `alert-id` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "alert-message")
	write1, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.AlertMessage, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `alert-message` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
type FieldSizePayload struct {
	FieldName *string
	FieldSize *uint32
}

func (v *FieldSizePayload) String() string { return "FieldSizePayload" }

func (v *FieldSizePayload) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "field-name")
	write0, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.FieldName, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `field-name` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "field-size")
	write1, err := func(v *uint32, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u32")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.FieldSize, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `field-size` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

// These cases are inspired by the IANA HTTP Proxy Error Types:
// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
type ErrorCode struct {
	payload      any
	discriminant ErrorCodeDiscriminant
}

func (v *ErrorCode) Discriminant() ErrorCodeDiscriminant { return v.discriminant }

type ErrorCodeDiscriminant uint8

const (
	ErrorCodeDnsTimeout                     ErrorCodeDiscriminant = 0
	ErrorCodeDnsError                       ErrorCodeDiscriminant = 1
	ErrorCodeDestinationNotFound            ErrorCodeDiscriminant = 2
	ErrorCodeDestinationUnavailable         ErrorCodeDiscriminant = 3
	ErrorCodeDestinationIpProhibited        ErrorCodeDiscriminant = 4
	ErrorCodeDestinationIpUnroutable        ErrorCodeDiscriminant = 5
	ErrorCodeConnectionRefused              ErrorCodeDiscriminant = 6
	ErrorCodeConnectionTerminated           ErrorCodeDiscriminant = 7
	ErrorCodeConnectionTimeout              ErrorCodeDiscriminant = 8
	ErrorCodeConnectionReadTimeout          ErrorCodeDiscriminant = 9
	ErrorCodeConnectionWriteTimeout         ErrorCodeDiscriminant = 10
	ErrorCodeConnectionLimitReached         ErrorCodeDiscriminant = 11
	ErrorCodeTlsProtocolError               ErrorCodeDiscriminant = 12
	ErrorCodeTlsCertificateError            ErrorCodeDiscriminant = 13
	ErrorCodeTlsAlertReceived               ErrorCodeDiscriminant = 14
	ErrorCodeHttpRequestDenied              ErrorCodeDiscriminant = 15
	ErrorCodeHttpRequestLengthRequired      ErrorCodeDiscriminant = 16
	ErrorCodeHttpRequestBodySize            ErrorCodeDiscriminant = 17
	ErrorCodeHttpRequestMethodInvalid       ErrorCodeDiscriminant = 18
	ErrorCodeHttpRequestUriInvalid          ErrorCodeDiscriminant = 19
	ErrorCodeHttpRequestUriTooLong          ErrorCodeDiscriminant = 20
	ErrorCodeHttpRequestHeaderSectionSize   ErrorCodeDiscriminant = 21
	ErrorCodeHttpRequestHeaderSize          ErrorCodeDiscriminant = 22
	ErrorCodeHttpRequestTrailerSectionSize  ErrorCodeDiscriminant = 23
	ErrorCodeHttpRequestTrailerSize         ErrorCodeDiscriminant = 24
	ErrorCodeHttpResponseIncomplete         ErrorCodeDiscriminant = 25
	ErrorCodeHttpResponseHeaderSectionSize  ErrorCodeDiscriminant = 26
	ErrorCodeHttpResponseHeaderSize         ErrorCodeDiscriminant = 27
	ErrorCodeHttpResponseBodySize           ErrorCodeDiscriminant = 28
	ErrorCodeHttpResponseTrailerSectionSize ErrorCodeDiscriminant = 29
	ErrorCodeHttpResponseTrailerSize        ErrorCodeDiscriminant = 30
	ErrorCodeHttpResponseTransferCoding     ErrorCodeDiscriminant = 31
	ErrorCodeHttpResponseContentCoding      ErrorCodeDiscriminant = 32
	ErrorCodeHttpResponseTimeout            ErrorCodeDiscriminant = 33
	ErrorCodeHttpUpgradeFailed              ErrorCodeDiscriminant = 34
	ErrorCodeHttpProtocolError              ErrorCodeDiscriminant = 35
	ErrorCodeLoopDetected                   ErrorCodeDiscriminant = 36
	ErrorCodeConfigurationError             ErrorCodeDiscriminant = 37
	// This is a catch-all error for anything that doesn't fit cleanly into a
	// more specific case. It also includes an optional string for an
	// unstructured description of the error. Users should not depend on the
	// string for diagnosing errors, as it's not required to be consistent
	// between implementations.
	ErrorCodeInternalError ErrorCodeDiscriminant = 38
)

func (v *ErrorCode) String() string {
	switch v.discriminant {
	case ErrorCodeDnsTimeout:
		return "DNS-timeout"
	case ErrorCodeDnsError:
		return "DNS-error"
	case ErrorCodeDestinationNotFound:
		return "destination-not-found"
	case ErrorCodeDestinationUnavailable:
		return "destination-unavailable"
	case ErrorCodeDestinationIpProhibited:
		return "destination-IP-prohibited"
	case ErrorCodeDestinationIpUnroutable:
		return "destination-IP-unroutable"
	case ErrorCodeConnectionRefused:
		return "connection-refused"
	case ErrorCodeConnectionTerminated:
		return "connection-terminated"
	case ErrorCodeConnectionTimeout:
		return "connection-timeout"
	case ErrorCodeConnectionReadTimeout:
		return "connection-read-timeout"
	case ErrorCodeConnectionWriteTimeout:
		return "connection-write-timeout"
	case ErrorCodeConnectionLimitReached:
		return "connection-limit-reached"
	case ErrorCodeTlsProtocolError:
		return "TLS-protocol-error"
	case ErrorCodeTlsCertificateError:
		return "TLS-certificate-error"
	case ErrorCodeTlsAlertReceived:
		return "TLS-alert-received"
	case ErrorCodeHttpRequestDenied:
		return "HTTP-request-denied"
	case ErrorCodeHttpRequestLengthRequired:
		return "HTTP-request-length-required"
	case ErrorCodeHttpRequestBodySize:
		return "HTTP-request-body-size"
	case ErrorCodeHttpRequestMethodInvalid:
		return "HTTP-request-method-invalid"
	case ErrorCodeHttpRequestUriInvalid:
		return "HTTP-request-URI-invalid"
	case ErrorCodeHttpRequestUriTooLong:
		return "HTTP-request-URI-too-long"
	case ErrorCodeHttpRequestHeaderSectionSize:
		return "HTTP-request-header-section-size"
	case ErrorCodeHttpRequestHeaderSize:
		return "HTTP-request-header-size"
	case ErrorCodeHttpRequestTrailerSectionSize:
		return "HTTP-request-trailer-section-size"
	case ErrorCodeHttpRequestTrailerSize:
		return "HTTP-request-trailer-size"
	case ErrorCodeHttpResponseIncomplete:
		return "HTTP-response-incomplete"
	case ErrorCodeHttpResponseHeaderSectionSize:
		return "HTTP-response-header-section-size"
	case ErrorCodeHttpResponseHeaderSize:
		return "HTTP-response-header-size"
	case ErrorCodeHttpResponseBodySize:
		return "HTTP-response-body-size"
	case ErrorCodeHttpResponseTrailerSectionSize:
		return "HTTP-response-trailer-section-size"
	case ErrorCodeHttpResponseTrailerSize:
		return "HTTP-response-trailer-size"
	case ErrorCodeHttpResponseTransferCoding:
		return "HTTP-response-transfer-coding"
	case ErrorCodeHttpResponseContentCoding:
		return "HTTP-response-content-coding"
	case ErrorCodeHttpResponseTimeout:
		return "HTTP-response-timeout"
	case ErrorCodeHttpUpgradeFailed:
		return "HTTP-upgrade-failed"
	case ErrorCodeHttpProtocolError:
		return "HTTP-protocol-error"
	case ErrorCodeLoopDetected:
		return "loop-detected"
	case ErrorCodeConfigurationError:
		return "configuration-error"
	case ErrorCodeInternalError:
		return "internal-error"
	default:
		panic("invalid variant")
	}
}
func (v *ErrorCode) GetDnsTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDnsTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDnsTimeout() *ErrorCode {
	v.discriminant = ErrorCodeDnsTimeout
	v.payload = nil
	return v
}
func NewErrorCodeDnsTimeout() *ErrorCode {
	return (&ErrorCode{}).SetDnsTimeout()
}
func (v *ErrorCode) GetDnsError() (payload DnsErrorPayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeDnsError); !ok {
		return
	}
	payload, ok = v.payload.(DnsErrorPayload)
	return
}
func (v *ErrorCode) SetDnsError(payload *DnsErrorPayload) *ErrorCode {
	v.discriminant = ErrorCodeDnsError
	v.payload = payload
	return v
}
func NewErrorCodeDnsError(payload *DnsErrorPayload) *ErrorCode {
	return (&ErrorCode{}).SetDnsError(
		payload)
}
func (v *ErrorCode) GetDestinationNotFound() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDestinationNotFound); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationNotFound() *ErrorCode {
	v.discriminant = ErrorCodeDestinationNotFound
	v.payload = nil
	return v
}
func NewErrorCodeDestinationNotFound() *ErrorCode {
	return (&ErrorCode{}).SetDestinationNotFound()
}
func (v *ErrorCode) GetDestinationUnavailable() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDestinationUnavailable); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationUnavailable() *ErrorCode {
	v.discriminant = ErrorCodeDestinationUnavailable
	v.payload = nil
	return v
}
func NewErrorCodeDestinationUnavailable() *ErrorCode {
	return (&ErrorCode{}).SetDestinationUnavailable()
}
func (v *ErrorCode) GetDestinationIpProhibited() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDestinationIpProhibited); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationIpProhibited() *ErrorCode {
	v.discriminant = ErrorCodeDestinationIpProhibited
	v.payload = nil
	return v
}
func NewErrorCodeDestinationIpProhibited() *ErrorCode {
	return (&ErrorCode{}).SetDestinationIpProhibited()
}
func (v *ErrorCode) GetDestinationIpUnroutable() (ok bool) {
	if ok = (v.discriminant == ErrorCodeDestinationIpUnroutable); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetDestinationIpUnroutable() *ErrorCode {
	v.discriminant = ErrorCodeDestinationIpUnroutable
	v.payload = nil
	return v
}
func NewErrorCodeDestinationIpUnroutable() *ErrorCode {
	return (&ErrorCode{}).SetDestinationIpUnroutable()
}
func (v *ErrorCode) GetConnectionRefused() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionRefused); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionRefused() *ErrorCode {
	v.discriminant = ErrorCodeConnectionRefused
	v.payload = nil
	return v
}
func NewErrorCodeConnectionRefused() *ErrorCode {
	return (&ErrorCode{}).SetConnectionRefused()
}
func (v *ErrorCode) GetConnectionTerminated() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionTerminated); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionTerminated() *ErrorCode {
	v.discriminant = ErrorCodeConnectionTerminated
	v.payload = nil
	return v
}
func NewErrorCodeConnectionTerminated() *ErrorCode {
	return (&ErrorCode{}).SetConnectionTerminated()
}
func (v *ErrorCode) GetConnectionTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionTimeout() *ErrorCode {
	v.discriminant = ErrorCodeConnectionTimeout
	v.payload = nil
	return v
}
func NewErrorCodeConnectionTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionTimeout()
}
func (v *ErrorCode) GetConnectionReadTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionReadTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionReadTimeout() *ErrorCode {
	v.discriminant = ErrorCodeConnectionReadTimeout
	v.payload = nil
	return v
}
func NewErrorCodeConnectionReadTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionReadTimeout()
}
func (v *ErrorCode) GetConnectionWriteTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionWriteTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionWriteTimeout() *ErrorCode {
	v.discriminant = ErrorCodeConnectionWriteTimeout
	v.payload = nil
	return v
}
func NewErrorCodeConnectionWriteTimeout() *ErrorCode {
	return (&ErrorCode{}).SetConnectionWriteTimeout()
}
func (v *ErrorCode) GetConnectionLimitReached() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConnectionLimitReached); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConnectionLimitReached() *ErrorCode {
	v.discriminant = ErrorCodeConnectionLimitReached
	v.payload = nil
	return v
}
func NewErrorCodeConnectionLimitReached() *ErrorCode {
	return (&ErrorCode{}).SetConnectionLimitReached()
}
func (v *ErrorCode) GetTlsProtocolError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeTlsProtocolError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetTlsProtocolError() *ErrorCode {
	v.discriminant = ErrorCodeTlsProtocolError
	v.payload = nil
	return v
}
func NewErrorCodeTlsProtocolError() *ErrorCode {
	return (&ErrorCode{}).SetTlsProtocolError()
}
func (v *ErrorCode) GetTlsCertificateError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeTlsCertificateError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetTlsCertificateError() *ErrorCode {
	v.discriminant = ErrorCodeTlsCertificateError
	v.payload = nil
	return v
}
func NewErrorCodeTlsCertificateError() *ErrorCode {
	return (&ErrorCode{}).SetTlsCertificateError()
}
func (v *ErrorCode) GetTlsAlertReceived() (payload TlsAlertReceivedPayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeTlsAlertReceived); !ok {
		return
	}
	payload, ok = v.payload.(TlsAlertReceivedPayload)
	return
}
func (v *ErrorCode) SetTlsAlertReceived(payload *TlsAlertReceivedPayload) *ErrorCode {
	v.discriminant = ErrorCodeTlsAlertReceived
	v.payload = payload
	return v
}
func NewErrorCodeTlsAlertReceived(payload *TlsAlertReceivedPayload) *ErrorCode {
	return (&ErrorCode{}).SetTlsAlertReceived(
		payload)
}
func (v *ErrorCode) GetHttpRequestDenied() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestDenied); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestDenied() *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestDenied
	v.payload = nil
	return v
}
func NewErrorCodeHttpRequestDenied() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestDenied()
}
func (v *ErrorCode) GetHttpRequestLengthRequired() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestLengthRequired); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestLengthRequired() *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestLengthRequired
	v.payload = nil
	return v
}
func NewErrorCodeHttpRequestLengthRequired() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestLengthRequired()
}
func (v *ErrorCode) GetHttpRequestBodySize() (payload *uint64, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestBodySize); !ok {
		return
	}
	payload, ok = v.payload.(*uint64)
	return
}
func (v *ErrorCode) SetHttpRequestBodySize(payload *uint64) *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestBodySize
	v.payload = payload
	return v
}
func NewErrorCodeHttpRequestBodySize(payload *uint64) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestBodySize(
		payload)
}
func (v *ErrorCode) GetHttpRequestMethodInvalid() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestMethodInvalid); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestMethodInvalid() *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestMethodInvalid
	v.payload = nil
	return v
}
func NewErrorCodeHttpRequestMethodInvalid() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestMethodInvalid()
}
func (v *ErrorCode) GetHttpRequestUriInvalid() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestUriInvalid); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestUriInvalid() *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestUriInvalid
	v.payload = nil
	return v
}
func NewErrorCodeHttpRequestUriInvalid() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestUriInvalid()
}
func (v *ErrorCode) GetHttpRequestUriTooLong() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestUriTooLong); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpRequestUriTooLong() *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestUriTooLong
	v.payload = nil
	return v
}
func NewErrorCodeHttpRequestUriTooLong() *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestUriTooLong()
}
func (v *ErrorCode) GetHttpRequestHeaderSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestHeaderSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpRequestHeaderSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestHeaderSectionSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpRequestHeaderSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestHeaderSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestHeaderSize() (payload *FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestHeaderSize); !ok {
		return
	}
	payload, ok = v.payload.(*FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpRequestHeaderSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestHeaderSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpRequestHeaderSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestHeaderSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestTrailerSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestTrailerSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpRequestTrailerSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestTrailerSectionSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpRequestTrailerSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestTrailerSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpRequestTrailerSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpRequestTrailerSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpRequestTrailerSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeHttpRequestTrailerSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpRequestTrailerSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpRequestTrailerSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseIncomplete() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseIncomplete); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpResponseIncomplete() *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseIncomplete
	v.payload = nil
	return v
}
func NewErrorCodeHttpResponseIncomplete() *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseIncomplete()
}
func (v *ErrorCode) GetHttpResponseHeaderSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseHeaderSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpResponseHeaderSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseHeaderSectionSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseHeaderSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseHeaderSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseHeaderSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseHeaderSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpResponseHeaderSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseHeaderSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseHeaderSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseHeaderSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseBodySize() (payload *uint64, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseBodySize); !ok {
		return
	}
	payload, ok = v.payload.(*uint64)
	return
}
func (v *ErrorCode) SetHttpResponseBodySize(payload *uint64) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseBodySize
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseBodySize(payload *uint64) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseBodySize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTrailerSectionSize() (payload *uint32, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseTrailerSectionSize); !ok {
		return
	}
	payload, ok = v.payload.(*uint32)
	return
}
func (v *ErrorCode) SetHttpResponseTrailerSectionSize(payload *uint32) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseTrailerSectionSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseTrailerSectionSize(payload *uint32) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTrailerSectionSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTrailerSize() (payload FieldSizePayload, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseTrailerSize); !ok {
		return
	}
	payload, ok = v.payload.(FieldSizePayload)
	return
}
func (v *ErrorCode) SetHttpResponseTrailerSize(payload *FieldSizePayload) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseTrailerSize
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseTrailerSize(payload *FieldSizePayload) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTrailerSize(
		payload)
}
func (v *ErrorCode) GetHttpResponseTransferCoding() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseTransferCoding); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}
func (v *ErrorCode) SetHttpResponseTransferCoding(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseTransferCoding
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseTransferCoding(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTransferCoding(
		payload)
}
func (v *ErrorCode) GetHttpResponseContentCoding() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseContentCoding); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}
func (v *ErrorCode) SetHttpResponseContentCoding(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseContentCoding
	v.payload = payload
	return v
}
func NewErrorCodeHttpResponseContentCoding(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseContentCoding(
		payload)
}
func (v *ErrorCode) GetHttpResponseTimeout() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpResponseTimeout); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpResponseTimeout() *ErrorCode {
	v.discriminant = ErrorCodeHttpResponseTimeout
	v.payload = nil
	return v
}
func NewErrorCodeHttpResponseTimeout() *ErrorCode {
	return (&ErrorCode{}).SetHttpResponseTimeout()
}
func (v *ErrorCode) GetHttpUpgradeFailed() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpUpgradeFailed); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpUpgradeFailed() *ErrorCode {
	v.discriminant = ErrorCodeHttpUpgradeFailed
	v.payload = nil
	return v
}
func NewErrorCodeHttpUpgradeFailed() *ErrorCode {
	return (&ErrorCode{}).SetHttpUpgradeFailed()
}
func (v *ErrorCode) GetHttpProtocolError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeHttpProtocolError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetHttpProtocolError() *ErrorCode {
	v.discriminant = ErrorCodeHttpProtocolError
	v.payload = nil
	return v
}
func NewErrorCodeHttpProtocolError() *ErrorCode {
	return (&ErrorCode{}).SetHttpProtocolError()
}
func (v *ErrorCode) GetLoopDetected() (ok bool) {
	if ok = (v.discriminant == ErrorCodeLoopDetected); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetLoopDetected() *ErrorCode {
	v.discriminant = ErrorCodeLoopDetected
	v.payload = nil
	return v
}
func NewErrorCodeLoopDetected() *ErrorCode {
	return (&ErrorCode{}).SetLoopDetected()
}
func (v *ErrorCode) GetConfigurationError() (ok bool) {
	if ok = (v.discriminant == ErrorCodeConfigurationError); !ok {
		return
	}
	return
}
func (v *ErrorCode) SetConfigurationError() *ErrorCode {
	v.discriminant = ErrorCodeConfigurationError
	v.payload = nil
	return v
}
func NewErrorCodeConfigurationError() *ErrorCode {
	return (&ErrorCode{}).SetConfigurationError()
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func (v *ErrorCode) GetInternalError() (payload *string, ok bool) {
	if ok = (v.discriminant == ErrorCodeInternalError); !ok {
		return
	}
	payload, ok = v.payload.(*string)
	return
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func (v *ErrorCode) SetInternalError(payload *string) *ErrorCode {
	v.discriminant = ErrorCodeInternalError
	v.payload = payload
	return v
}

// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func NewErrorCodeInternalError(payload *string) *ErrorCode {
	return (&ErrorCode{}).SetInternalError(
		payload)
}
func (v *ErrorCode) Error() string { return v.String() }
func (v *ErrorCode) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorCodeDnsTimeout:
	case ErrorCodeDnsError:
		payload, ok := v.payload.(*DnsErrorPayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(1)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeDestinationNotFound:
	case ErrorCodeDestinationUnavailable:
	case ErrorCodeDestinationIpProhibited:
	case ErrorCodeDestinationIpUnroutable:
	case ErrorCodeConnectionRefused:
	case ErrorCodeConnectionTerminated:
	case ErrorCodeConnectionTimeout:
	case ErrorCodeConnectionReadTimeout:
	case ErrorCodeConnectionWriteTimeout:
	case ErrorCodeConnectionLimitReached:
	case ErrorCodeTlsProtocolError:
	case ErrorCodeTlsCertificateError:
	case ErrorCodeTlsAlertReceived:
		payload, ok := v.payload.(*TlsAlertReceivedPayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(14)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpRequestDenied:
	case ErrorCodeHttpRequestLengthRequired:
	case ErrorCodeHttpRequestBodySize:
		payload, ok := v.payload.(*uint64)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint64, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(17)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpRequestMethodInvalid:
	case ErrorCodeHttpRequestUriInvalid:
	case ErrorCodeHttpRequestUriTooLong:
	case ErrorCodeHttpRequestHeaderSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u32")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(21)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpRequestHeaderSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *FieldSizePayload, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (v).WriteToIndex(w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(22)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpRequestTrailerSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u32")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(23)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpRequestTrailerSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(24)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseIncomplete:
	case ErrorCodeHttpResponseHeaderSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u32")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(26)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseHeaderSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(27)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseBodySize:
		payload, ok := v.payload.(*uint64)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint64, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(28)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseTrailerSectionSize:
		payload, ok := v.payload.(*uint32)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *uint32, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u32")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(29)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseTrailerSize:
		payload, ok := v.payload.(*FieldSizePayload)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (payload).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(30)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseTransferCoding:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(31)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseContentCoding:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(32)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorCodeHttpResponseTimeout:
	case ErrorCodeHttpUpgradeFailed:
	case ErrorCodeHttpProtocolError:
	case ErrorCodeLoopDetected:
	case ErrorCodeConfigurationError:
	case ErrorCodeInternalError:
		payload, ok := v.payload.(*string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *string, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(38)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// This type enumerates the different kinds of errors that may occur when
// setting or appending to a `fields` resource.
type HeaderError struct {
	payload      any
	discriminant HeaderErrorDiscriminant
}

func (v *HeaderError) Discriminant() HeaderErrorDiscriminant { return v.discriminant }

type HeaderErrorDiscriminant uint8

const (
	// This error indicates that a `field-key` or `field-value` was
	// syntactically invalid when used with an operation that sets headers in a
	// `fields`.
	HeaderErrorInvalidSyntax HeaderErrorDiscriminant = 0
	// This error indicates that a forbidden `field-key` was used when trying
	// to set a header in a `fields`.
	HeaderErrorForbidden HeaderErrorDiscriminant = 1
	// This error indicates that the operation on the `fields` was not
	// permitted because the fields are immutable.
	HeaderErrorImmutable HeaderErrorDiscriminant = 2
)

func (v *HeaderError) String() string {
	switch v.discriminant {
	case HeaderErrorInvalidSyntax:
		return "invalid-syntax"
	case HeaderErrorForbidden:
		return "forbidden"
	case HeaderErrorImmutable:
		return "immutable"
	default:
		panic("invalid variant")
	}
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func (v *HeaderError) GetInvalidSyntax() (ok bool) {
	if ok = (v.discriminant == HeaderErrorInvalidSyntax); !ok {
		return
	}
	return
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func (v *HeaderError) SetInvalidSyntax() *HeaderError {
	v.discriminant = HeaderErrorInvalidSyntax
	v.payload = nil
	return v
}

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
func NewHeaderErrorInvalidSyntax() *HeaderError {
	return (&HeaderError{}).SetInvalidSyntax()
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func (v *HeaderError) GetForbidden() (ok bool) {
	if ok = (v.discriminant == HeaderErrorForbidden); !ok {
		return
	}
	return
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func (v *HeaderError) SetForbidden() *HeaderError {
	v.discriminant = HeaderErrorForbidden
	v.payload = nil
	return v
}

// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
func NewHeaderErrorForbidden() *HeaderError {
	return (&HeaderError{}).SetForbidden()
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func (v *HeaderError) GetImmutable() (ok bool) {
	if ok = (v.discriminant == HeaderErrorImmutable); !ok {
		return
	}
	return
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func (v *HeaderError) SetImmutable() *HeaderError {
	v.discriminant = HeaderErrorImmutable
	v.payload = nil
	return v
}

// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
func NewHeaderErrorImmutable() *HeaderError {
	return (&HeaderError{}).SetImmutable()
}
func (v *HeaderError) Error() string { return v.String() }
func (v *HeaderError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case HeaderErrorInvalidSyntax:
	case HeaderErrorForbidden:
	case HeaderErrorImmutable:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Field keys are always strings.
type FieldKey = string

// Field values should always be ASCII strings. However, in
// reality, HTTP implementations often have to interpret malformed values,
// so they are provided as a list of bytes.
type FieldValue = []uint8

// Headers is an alias for Fields.
type Headers = Fields

// Trailers is an alias for Fields.
type Trailers = Fields

// This type corresponds to the HTTP standard Status Code.
type StatusCode = uint16

// Attempts to extract a http-related `error` from the wasi:io `error`
// provided.
//
// Stream operations which return
// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
// type `wasi:io/error/error` with more information about the operation
// that failed. This payload can be passed through to this function to see
// if there's http-related information about the error to return.
//
// Note that this function is fallible because not all io-errors are
// http-related errors.
func HttpErrorCode(ctx__ context.Context, wrpc__ wrpc.Client, err wrpc.Borrow[IoError]) (r0__ *ErrorCode, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "http-error-code", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(err), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `err` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
					v := &ErrorCode{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch ErrorCodeDiscriminant(n) {
					case ErrorCodeDnsTimeout:
						return v.SetDnsTimeout(), nil
					case ErrorCodeDnsError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
							v := &DnsErrorPayload{}
							var err error
							slog.Debug("reading field", "name", "rcode")
							v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
							}
							slog.Debug("reading field", "name", "info-code")
							v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint16, error) {
										var x uint16
										var s uint
										for i := 0; i < 3; i++ {
											slog.Debug("reading u16 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u16 byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("varint overflows a 16-bit integer")
												}
												return x | uint16(b)<<s, nil
											}
											x |= uint16(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 16-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
						}
						return v.SetDnsError(payload), nil
					case ErrorCodeDestinationNotFound:
						return v.SetDestinationNotFound(), nil
					case ErrorCodeDestinationUnavailable:
						return v.SetDestinationUnavailable(), nil
					case ErrorCodeDestinationIpProhibited:
						return v.SetDestinationIpProhibited(), nil
					case ErrorCodeDestinationIpUnroutable:
						return v.SetDestinationIpUnroutable(), nil
					case ErrorCodeConnectionRefused:
						return v.SetConnectionRefused(), nil
					case ErrorCodeConnectionTerminated:
						return v.SetConnectionTerminated(), nil
					case ErrorCodeConnectionTimeout:
						return v.SetConnectionTimeout(), nil
					case ErrorCodeConnectionReadTimeout:
						return v.SetConnectionReadTimeout(), nil
					case ErrorCodeConnectionWriteTimeout:
						return v.SetConnectionWriteTimeout(), nil
					case ErrorCodeConnectionLimitReached:
						return v.SetConnectionLimitReached(), nil
					case ErrorCodeTlsProtocolError:
						return v.SetTlsProtocolError(), nil
					case ErrorCodeTlsCertificateError:
						return v.SetTlsCertificateError(), nil
					case ErrorCodeTlsAlertReceived:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
							v := &TlsAlertReceivedPayload{}
							var err error
							slog.Debug("reading field", "name", "alert-id")
							v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint8, error) {
										slog.Debug("reading u8 byte")
										v, err := r.ReadByte()
										if err != nil {
											return 0, fmt.Errorf("failed to read u8 byte: %w", err)
										}
										return v, nil
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
							}
							slog.Debug("reading field", "name", "alert-message")
							v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
						}
						return v.SetTlsAlertReceived(payload), nil
					case ErrorCodeHttpRequestDenied:
						return v.SetHttpRequestDenied(), nil
					case ErrorCodeHttpRequestLengthRequired:
						return v.SetHttpRequestLengthRequired(), nil
					case ErrorCodeHttpRequestBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
						}
						return v.SetHttpRequestBodySize(payload), nil
					case ErrorCodeHttpRequestMethodInvalid:
						return v.SetHttpRequestMethodInvalid(), nil
					case ErrorCodeHttpRequestUriInvalid:
						return v.SetHttpRequestUriInvalid(), nil
					case ErrorCodeHttpRequestUriTooLong:
						return v.SetHttpRequestUriTooLong(), nil
					case ErrorCodeHttpRequestHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSectionSize(payload), nil
					case ErrorCodeHttpRequestHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
									v := &FieldSizePayload{}
									var err error
									slog.Debug("reading field", "name", "field-name")
									v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 0)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
									}
									slog.Debug("reading field", "name", "field-size")
									v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 1)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
									}
									return v, nil
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSize(payload), nil
					case ErrorCodeHttpRequestTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSectionSize(payload), nil
					case ErrorCodeHttpRequestTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSize(payload), nil
					case ErrorCodeHttpResponseIncomplete:
						return v.SetHttpResponseIncomplete(), nil
					case ErrorCodeHttpResponseHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSectionSize(payload), nil
					case ErrorCodeHttpResponseHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSize(payload), nil
					case ErrorCodeHttpResponseBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
						}
						return v.SetHttpResponseBodySize(payload), nil
					case ErrorCodeHttpResponseTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSectionSize(payload), nil
					case ErrorCodeHttpResponseTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSize(payload), nil
					case ErrorCodeHttpResponseTransferCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
						}
						return v.SetHttpResponseTransferCoding(payload), nil
					case ErrorCodeHttpResponseContentCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
						}
						return v.SetHttpResponseContentCoding(payload), nil
					case ErrorCodeHttpResponseTimeout:
						return v.SetHttpResponseTimeout(), nil
					case ErrorCodeHttpUpgradeFailed:
						return v.SetHttpUpgradeFailed(), nil
					case ErrorCodeHttpProtocolError:
						return v.SetHttpProtocolError(), nil
					case ErrorCodeLoopDetected:
						return v.SetLoopDetected(), nil
					case ErrorCodeConfigurationError:
						return v.SetConfigurationError(), nil
					case ErrorCodeInternalError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
						}
						return v.SetInternalError(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `http-error-code`: %w", err__)
		return
	}
	return
}

// Construct an empty HTTP Fields.
//
// The resulting `fields` is mutable.
func NewFields(ctx__ context.Context, wrpc__ wrpc.Client) (r0__ wrpc.Own[Fields], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "fields", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Fields], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Fields](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]fields`: %w", err__)
		return
	}
	return
}

// Construct an HTTP Fields.
//
// The resulting `fields` is mutable.
//
// The list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
//
// The tuple is a pair of the field key, represented as a string, and
// Value, represented as a list of bytes. In a valid Fields, all keys
// and values are valid UTF-8 strings. However, values are not always
// well-formed, so they are represented as a raw list of bytes.
//
// An error result will be returned if any header or value was
// syntactically invalid, or if a header was forbidden.
func Fields_FromList(ctx__ context.Context, wrpc__ wrpc.Client, entries []*wrpc.Tuple2[string, []uint8]) (r0__ *wrpc.Result[wrpc.Own[Fields], HeaderError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "fields.from-list", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := func(v []*wrpc.Tuple2[string, []uint8], w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := func(v *wrpc.Tuple2[string, []uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (func(wrpc.IndexWriter) error, error) {
					writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
					slog.Debug("writing tuple element 0")
					write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing string byte length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
						}
						slog.Debug("writing string bytes")
						_, err = w.Write([]byte(v))
						if err != nil {
							return fmt.Errorf("failed to write string bytes: %w", err)
						}
						return nil
					}(v.V0, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
					}
					if write0 != nil {
						writes[0] = write0
					}
					slog.Debug("writing tuple element 1")
					write1, err := func(v []uint8, w interface {
						io.ByteWriter
						io.Writer
					}) (write func(wrpc.IndexWriter) error, err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing list length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
						for i, e := range v {
							write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
								slog.Debug("writing u8 byte")
								return w.WriteByte(v)
							}(e, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
							}
							if write != nil {
								writes[uint32(i)] = write
							}
						}
						if len(writes) > 0 {
							return func(w wrpc.IndexWriter) error {
								var wg errgroup.Group
								for index, write := range writes {
									w, err := w.Index(index)
									if err != nil {
										return fmt.Errorf("failed to index writer: %w", err)
									}
									write := write
									wg.Go(func() error {
										return write(w)
									})
								}
								return wg.Wait()
							}, nil
						}
						return nil, nil
					}(v.V1, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
					}
					if write1 != nil {
						writes[1] = write1
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(entries, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `entries` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[Fields], HeaderError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[Fields], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[Fields](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[Fields], HeaderError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*HeaderError, error) {
					v := &HeaderError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch HeaderErrorDiscriminant(n) {
					case HeaderErrorInvalidSyntax:
						return v.SetInvalidSyntax(), nil
					case HeaderErrorForbidden:
						return v.SetForbidden(), nil
					case HeaderErrorImmutable:
						return v.SetImmutable(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[Fields], HeaderError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]fields.from-list`: %w", err__)
		return
	}
	return
}

// Get all of the values corresponding to a key. If the key is not present
// in this `fields`, an empty list is returned. However, if the key is
// present but empty, this is represented by a list with one or more
// empty field-values present.
func Fields_Get(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields], name string) (r0__ [][]uint8, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "get", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading list length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return nil, fmt.Errorf("failed to read list length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return nil, errors.New("list length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					vs := make([][]uint8, x)
					for i := range vs {
						slog.Debug("reading list element", "i", i)
						vs[i], err = func(r interface {
							io.ByteReader
							io.Reader
						}) ([]byte, error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading byte list length", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return nil, errors.New("byte list length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading byte list contents", "len", x)
									_, err = io.ReadFull(r, buf)
									if err != nil {
										return nil, fmt.Errorf("failed to read byte list contents: %w", err)
									}
									return buf, nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return nil, errors.New("byte length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
						}
					}
					return vs, nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return nil, errors.New("list length overflows a 32-bit integer")
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.get`: %w", err__)
		return
	}
	return
}

// Returns `true` when the key is present in this `fields`. If the key is
// syntactically invalid, `false` is returned.
func Fields_Has(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields], name string) (r0__ bool, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "has", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r io.ByteReader) (bool, error) {
			slog.Debug("reading bool byte")
			v, err := r.ReadByte()
			if err != nil {
				slog.Debug("reading bool", "value", false)
				return false, fmt.Errorf("failed to read bool byte: %w", err)
			}
			switch v {
			case 0:
				return false, nil
			case 1:
				return true, nil
			default:
				return false, fmt.Errorf("invalid bool value %d", v)
			}
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.has`: %w", err__)
		return
	}
	return
}

// Set all of the values for a key. Clears any existing values for that
// key, if they have been set.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
func Fields_Set(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields], name string, value [][]uint8) (r0__ *wrpc.Result[struct{}, HeaderError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 3)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := func(v [][]uint8, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := func(v []uint8, w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
							slog.Debug("writing u8 byte")
							return w.WriteByte(v)
						}(e, w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(value, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `value` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, HeaderError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, HeaderError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*HeaderError, error) {
					v := &HeaderError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch HeaderErrorDiscriminant(n) {
					case HeaderErrorInvalidSyntax:
						return v.SetInvalidSyntax(), nil
					case HeaderErrorForbidden:
						return v.SetForbidden(), nil
					case HeaderErrorImmutable:
						return v.SetImmutable(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, HeaderError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.set`: %w", err__)
		return
	}
	return
}

// Delete all values for a key. Does nothing if no values for the key
// exist.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
func Fields_Delete(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields], name string) (r0__ *wrpc.Result[struct{}, HeaderError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "delete", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, HeaderError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, HeaderError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*HeaderError, error) {
					v := &HeaderError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch HeaderErrorDiscriminant(n) {
					case HeaderErrorInvalidSyntax:
						return v.SetInvalidSyntax(), nil
					case HeaderErrorForbidden:
						return v.SetForbidden(), nil
					case HeaderErrorImmutable:
						return v.SetImmutable(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, HeaderError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.delete`: %w", err__)
		return
	}
	return
}

// Append a value for a key. Does not change or delete any existing
// values for that key.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
func Fields_Append(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields], name string, value []uint8) (r0__ *wrpc.Result[struct{}, HeaderError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "append", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 3)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := func(v []uint8, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
					slog.Debug("writing u8 byte")
					return w.WriteByte(v)
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(value, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `value` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, HeaderError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, HeaderError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*HeaderError, error) {
					v := &HeaderError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch HeaderErrorDiscriminant(n) {
					case HeaderErrorInvalidSyntax:
						return v.SetInvalidSyntax(), nil
					case HeaderErrorForbidden:
						return v.SetForbidden(), nil
					case HeaderErrorImmutable:
						return v.SetImmutable(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, HeaderError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.append`: %w", err__)
		return
	}
	return
}

// Retrieve the full set of keys and values in the Fields. Like the
// constructor, the list represents each key-value pair.
//
// The outer list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
func Fields_Entries(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields]) (r0__ []*wrpc.Tuple2[string, []uint8], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "entries", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, []uint8], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading list length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return nil, fmt.Errorf("failed to read list length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return nil, errors.New("list length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					vs := make([]*wrpc.Tuple2[string, []uint8], x)
					for i := range vs {
						slog.Debug("reading list element", "i", i)
						vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, []uint8], error) {
							v := &wrpc.Tuple2[string, []uint8]{}
							var err error
							slog.Debug("reading tuple element 0")
							v.V0, err = func() (FieldKey, error) {
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								return (FieldKey)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
							}
							slog.Debug("reading tuple element 1")
							v.V1, err = func(r interface {
								io.ByteReader
								io.Reader
							}) ([]byte, error) {
								var x uint32
								var s uint
								for i := 0; i < 5; i++ {
									slog.Debug("reading byte list length", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
									}
									if b < 0x80 {
										if i == 4 && b > 1 {
											return nil, errors.New("byte list length overflows a 32-bit integer")
										}
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading byte list contents", "len", x)
										_, err = io.ReadFull(r, buf)
										if err != nil {
											return nil, fmt.Errorf("failed to read byte list contents: %w", err)
										}
										return buf, nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return nil, errors.New("byte length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
							}
							return v, nil
						}(r, append(path, uint32(i))...)
						if err != nil {
							return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
						}
					}
					return vs, nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return nil, errors.New("list length overflows a 32-bit integer")
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.entries`: %w", err__)
		return
	}
	return
}

// Make a deep copy of the Fields. Equivelant in behavior to calling the
// `fields` constructor on the return value of `entries`. The resulting
// `fields` is mutable.
func Fields_Clone(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[Fields]) (r0__ wrpc.Own[Fields], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "clone", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Fields], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Fields](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]fields.clone`: %w", err__)
		return
	}
	return
}

// Returns the method of the incoming request.
func IncomingRequest_Method(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ *Method, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "method", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Method, error) {
			v := &Method{}
			n, err := func(r io.ByteReader) (uint8, error) {
				var x uint8
				var s uint
				for i := 0; i < 2; i++ {
					slog.Debug("reading u8 discriminant byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
					}
					if b < 0x80 {
						if i == 2 && b > 1 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						return x | uint8(b)<<s, nil
					}
					x |= uint8(b&0x7f) << s
					s += 7
				}
				return x, errors.New("discriminant overflows an 8-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read discriminant: %w", err)
			}
			switch MethodDiscriminant(n) {
			case MethodGet:
				return v.SetGet(), nil
			case MethodHead:
				return v.SetHead(), nil
			case MethodPost:
				return v.SetPost(), nil
			case MethodPut:
				return v.SetPut(), nil
			case MethodDelete:
				return v.SetDelete(), nil
			case MethodConnect:
				return v.SetConnect(), nil
			case MethodOptions:
				return v.SetOptions(), nil
			case MethodTrace:
				return v.SetTrace(), nil
			case MethodPatch:
				return v.SetPatch(), nil
			case MethodOther:
				payload, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `other` payload: %w", err)
				}
				return v.SetOther(payload), nil
			default:
				return nil, fmt.Errorf("unknown discriminant value %d", n)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.method`: %w", err__)
		return
	}
	return
}

// Returns the path with query parameters from the request, as a string.
func IncomingRequest_PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ *string, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "path-with-query", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.path-with-query`: %w", err__)
		return
	}
	return
}

// Returns the protocol scheme from the request.
func IncomingRequest_Scheme(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ *Scheme, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "scheme", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Scheme, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*Scheme, error) {
					v := &Scheme{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch SchemeDiscriminant(n) {
					case SchemeHttp:
						return v.SetHttp(), nil
					case SchemeHttps:
						return v.SetHttps(), nil
					case SchemeOther:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `other` payload: %w", err)
						}
						return v.SetOther(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.scheme`: %w", err__)
		return
	}
	return
}

// Returns the authority from the request, if it was present.
func IncomingRequest_Authority(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ *string, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "authority", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.authority`: %w", err__)
		return
	}
	return
}

// Get the `headers` associated with the request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// The `headers` returned are a child resource: it must be dropped before
// the parent `incoming-request` is dropped. Dropping this
// `incoming-request` before all children are dropped will trap.
func IncomingRequest_Headers(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ wrpc.Own[Headers], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "headers", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Headers], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Headers](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.headers`: %w", err__)
		return
	}
	return
}

// Gives the `incoming-body` associated with this request. Will only
// return success at most once, and subsequent calls will return error.
func IncomingRequest_Consume(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingRequest]) (r0__ *wrpc.Result[wrpc.Own[IncomingBody], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "consume", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[IncomingBody], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[IncomingBody], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[IncomingBody](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingBody], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[IncomingBody], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-request.consume`: %w", err__)
		return
	}
	return
}

// Construct a new `outgoing-request` with a default `method` of `GET`, and
// `none` values for `path-with-query`, `scheme`, and `authority`.
//
// * `headers` is the HTTP Headers for the Request.
//
// It is possible to construct, or manipulate with the accessor functions
// below, an `outgoing-request` with an invalid combination of `scheme`
// and `authority`, or `headers` which are not permitted to be sent.
// It is the obligation of the `outgoing-handler.handle` implementation
// to reject invalid constructions of `outgoing-request`.
func NewOutgoingRequest(ctx__ context.Context, wrpc__ wrpc.Client, headers wrpc.Own[Headers]) (r0__ wrpc.Own[OutgoingRequest], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "outgoing-request", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(headers), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `headers` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[OutgoingRequest], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[OutgoingRequest](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]outgoing-request`: %w", err__)
		return
	}
	return
}

// Returns the resource corresponding to the outgoing Body for this
// Request.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-request` can be retrieved at most once. Subsequent
// calls will return error.
func OutgoingRequest_Body(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ *wrpc.Result[wrpc.Own[OutgoingBody], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "body", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[OutgoingBody], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[OutgoingBody], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[OutgoingBody](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[OutgoingBody], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[OutgoingBody], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.body`: %w", err__)
		return
	}
	return
}

// Get the Method for the Request.
func OutgoingRequest_Method(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ *Method, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "method", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Method, error) {
			v := &Method{}
			n, err := func(r io.ByteReader) (uint8, error) {
				var x uint8
				var s uint
				for i := 0; i < 2; i++ {
					slog.Debug("reading u8 discriminant byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
					}
					if b < 0x80 {
						if i == 2 && b > 1 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						return x | uint8(b)<<s, nil
					}
					x |= uint8(b&0x7f) << s
					s += 7
				}
				return x, errors.New("discriminant overflows an 8-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read discriminant: %w", err)
			}
			switch MethodDiscriminant(n) {
			case MethodGet:
				return v.SetGet(), nil
			case MethodHead:
				return v.SetHead(), nil
			case MethodPost:
				return v.SetPost(), nil
			case MethodPut:
				return v.SetPut(), nil
			case MethodDelete:
				return v.SetDelete(), nil
			case MethodConnect:
				return v.SetConnect(), nil
			case MethodOptions:
				return v.SetOptions(), nil
			case MethodTrace:
				return v.SetTrace(), nil
			case MethodPatch:
				return v.SetPatch(), nil
			case MethodOther:
				payload, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `other` payload: %w", err)
				}
				return v.SetOther(payload), nil
			default:
				return nil, fmt.Errorf("unknown discriminant value %d", n)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.method`: %w", err__)
		return
	}
	return
}

// Set the Method for the Request. Fails if the string present in a
// `method.other` argument is not a syntactically valid method.
func OutgoingRequest_SetMethod(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest], method *Method) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-method", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (method).WriteToIndex(&buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `method` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.set-method`: %w", err__)
		return
	}
	return
}

// Get the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query.
func OutgoingRequest_PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ *string, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "path-with-query", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.path-with-query`: %w", err__)
		return
	}
	return
}

// Set the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query. Fails is the
// string given is not a syntactically valid path and query uri component.
func OutgoingRequest_SetPathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest], pathWithQuery *string) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-path-with-query", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *string, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(pathWithQuery, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `path-with-query` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.set-path-with-query`: %w", err__)
		return
	}
	return
}

// Get the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme.
func OutgoingRequest_Scheme(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ *Scheme, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "scheme", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Scheme, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*Scheme, error) {
					v := &Scheme{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch SchemeDiscriminant(n) {
					case SchemeHttp:
						return v.SetHttp(), nil
					case SchemeHttps:
						return v.SetHttps(), nil
					case SchemeOther:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `other` payload: %w", err)
						}
						return v.SetOther(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.scheme`: %w", err__)
		return
	}
	return
}

// Set the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme. Fails if the
// string given is not a syntactically valid uri scheme.
func OutgoingRequest_SetScheme(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest], scheme *Scheme) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-scheme", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *Scheme, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (v).WriteToIndex(w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(scheme, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `scheme` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.set-scheme`: %w", err__)
		return
	}
	return
}

// Get the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority.
func OutgoingRequest_Authority(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ *string, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "authority", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.authority`: %w", err__)
		return
	}
	return
}

// Set the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority. Fails if the string given is
// not a syntactically valid uri authority.
func OutgoingRequest_SetAuthority(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest], authority *string) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-authority", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *string, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(authority, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `authority` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.set-authority`: %w", err__)
		return
	}
	return
}

// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
func OutgoingRequest_Headers(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingRequest]) (r0__ wrpc.Own[Headers], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "headers", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Headers], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Headers](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-request.headers`: %w", err__)
		return
	}
	return
}

// Construct a default `request-options` value.
func NewRequestOptions(ctx__ context.Context, wrpc__ wrpc.Client) (r0__ wrpc.Own[RequestOptions], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "request-options", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[RequestOptions], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[RequestOptions](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]request-options`: %w", err__)
		return
	}
	return
}

// The timeout for the initial connect to the HTTP Server.
func RequestOptions_ConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions]) (r0__ *Duration, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "connect-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Duration, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func() (Duration, error) {
					v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
						v, err := func(r io.ByteReader) (uint64, error) {
							var x uint64
							var s uint
							for i := 0; i < 10; i++ {
								slog.Debug("reading u64 byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u64 byte: %w", err)
								}
								if b < 0x80 {
									if i == 9 && b > 1 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									return x | uint64(b)<<s, nil
								}
								x |= uint64(b&0x7f) << s
								s += 7
							}
							return x, errors.New("varint overflows a 64-bit integer")
						}(r)
						return (wasi__clocks__monotonic_clock.Duration)(v), err
					}()

					return (Duration)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.connect-timeout`: %w", err__)
		return
	}
	return
}

// Set the timeout for the initial connect to the HTTP Server. An error
// return value indicates that this timeout is not supported.
func RequestOptions_SetConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions], duration *Duration) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-connect-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *Duration, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(duration, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `duration` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.set-connect-timeout`: %w", err__)
		return
	}
	return
}

// The timeout for receiving the first byte of the Response body.
func RequestOptions_FirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions]) (r0__ *Duration, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "first-byte-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Duration, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func() (Duration, error) {
					v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
						v, err := func(r io.ByteReader) (uint64, error) {
							var x uint64
							var s uint
							for i := 0; i < 10; i++ {
								slog.Debug("reading u64 byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u64 byte: %w", err)
								}
								if b < 0x80 {
									if i == 9 && b > 1 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									return x | uint64(b)<<s, nil
								}
								x |= uint64(b&0x7f) << s
								s += 7
							}
							return x, errors.New("varint overflows a 64-bit integer")
						}(r)
						return (wasi__clocks__monotonic_clock.Duration)(v), err
					}()

					return (Duration)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.first-byte-timeout`: %w", err__)
		return
	}
	return
}

// Set the timeout for receiving the first byte of the Response body. An
// error return value indicates that this timeout is not supported.
func RequestOptions_SetFirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions], duration *Duration) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-first-byte-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *Duration, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(duration, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `duration` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.set-first-byte-timeout`: %w", err__)
		return
	}
	return
}

// The timeout for receiving subsequent chunks of bytes in the Response
// body stream.
func RequestOptions_BetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions]) (r0__ *Duration, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "between-bytes-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*Duration, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func() (Duration, error) {
					v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
						v, err := func(r io.ByteReader) (uint64, error) {
							var x uint64
							var s uint
							for i := 0; i < 10; i++ {
								slog.Debug("reading u64 byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u64 byte: %w", err)
								}
								if b < 0x80 {
									if i == 9 && b > 1 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									return x | uint64(b)<<s, nil
								}
								x |= uint64(b&0x7f) << s
								s += 7
							}
							return x, errors.New("varint overflows a 64-bit integer")
						}(r)
						return (wasi__clocks__monotonic_clock.Duration)(v), err
					}()

					return (Duration)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.between-bytes-timeout`: %w", err__)
		return
	}
	return
}

// Set the timeout for receiving subsequent chunks of bytes in the Response
// body stream. An error return value indicates that this timeout is not
// supported.
func RequestOptions_SetBetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[RequestOptions], duration *Duration) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-between-bytes-timeout", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *Duration, w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(*v, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(duration, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `duration` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]request-options.set-between-bytes-timeout`: %w", err__)
		return
	}
	return
}

// Set the value of the `response-outparam` to either send a response,
// or indicate an error.
//
// This method consumes the `response-outparam` to ensure that it is
// called at most once. If it is never called, the implementation
// will respond with an error.
//
// The user may provide an `error` to `response` to allow the
// implementation determine how to respond with an HTTP error response.
func ResponseOutparam_Set(ctx__ context.Context, wrpc__ wrpc.Client, param wrpc.Own[ResponseOutparam], response *wrpc.Result[wrpc.Own[OutgoingResponse], ErrorCode]) (close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "response-outparam.set", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(param), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `param` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *wrpc.Result[wrpc.Own[OutgoingResponse], ErrorCode], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(string(*v.Ok), w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(response, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `response` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]response-outparam.set`: %w", err__)
		return
	}
	return
}

// Returns the status code from the incoming response.
func IncomingResponse_Status(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingResponse]) (r0__ uint16, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "status", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func() (StatusCode, error) {
			v, err := func(r io.ByteReader) (uint16, error) {
				var x uint16
				var s uint
				for i := 0; i < 3; i++ {
					slog.Debug("reading u16 byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return x, fmt.Errorf("failed to read u16 byte: %w", err)
					}
					if b < 0x80 {
						if i == 2 && b > 1 {
							return x, errors.New("varint overflows a 16-bit integer")
						}
						return x | uint16(b)<<s, nil
					}
					x |= uint16(b&0x7f) << s
					s += 7
				}
				return x, errors.New("varint overflows a 16-bit integer")
			}(r__)
			return (StatusCode)(v), err
		}()

		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-response.status`: %w", err__)
		return
	}
	return
}

// Returns the headers from the incoming response.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `incoming-response` is dropped.
func IncomingResponse_Headers(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingResponse]) (r0__ wrpc.Own[Headers], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "headers", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Headers], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Headers](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-response.headers`: %w", err__)
		return
	}
	return
}

// Returns the incoming body. May be called at most once. Returns error
// if called additional times.
func IncomingResponse_Consume(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingResponse]) (r0__ *wrpc.Result[wrpc.Own[IncomingBody], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "consume", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[IncomingBody], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[IncomingBody], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[IncomingBody](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingBody], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[IncomingBody], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-response.consume`: %w", err__)
		return
	}
	return
}

// Returns the contents of the body, as a stream of bytes.
//
// Returns success on first call: the stream representing the contents
// can be retrieved at most once. Subsequent calls will return error.
//
// The returned `input-stream` resource is a child: it must be dropped
// before the parent `incoming-body` is dropped, or consumed by
// `incoming-body.finish`.
//
// This invariant ensures that the implementation can determine whether
// the user is consuming the contents of the body, waiting on the
// `future-trailers` to be ready, or neither. This allows for network
// backpressure is to be applied when the user is consuming the body,
// and for that backpressure to not inhibit delivery of the trailers if
// the user does not read the entire body.
func IncomingBody_Stream(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[IncomingBody]) (r0__ *wrpc.Result[wrpc.Own[InputStream], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "stream", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[InputStream], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[InputStream], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[InputStream](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[InputStream], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[InputStream], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-body.stream`: %w", err__)
		return
	}
	return
}

// Takes ownership of `incoming-body`, and returns a `future-trailers`.
// This function will trap if the `input-stream` child is still alive.
func IncomingBody_Finish(ctx__ context.Context, wrpc__ wrpc.Client, this wrpc.Own[IncomingBody]) (r0__ wrpc.Own[FutureTrailers], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "incoming-body.finish", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(this), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[FutureTrailers], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[FutureTrailers](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]incoming-body.finish`: %w", err__)
		return
	}
	return
}

// Returns a pollable which becomes ready when either the trailers have
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
func FutureTrailers_Subscribe(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[FutureTrailers]) (r0__ wrpc.Own[Pollable], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "subscribe", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Pollable], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Pollable](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]future-trailers.subscribe`: %w", err__)
		return
	}
	return
}

// Returns the contents of the trailers, or an error which occured,
// once the future is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the trailers or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the HTTP Request or Response
// body, as well as any trailers, were received successfully, or that an
// error occured receiving them. The optional `trailers` indicates whether
// or not trailers were present in the body.
//
// When some `trailers` are returned by this method, the `trailers`
// resource is immutable, and a child. Use of the `set`, `append`, or
// `delete` methods will return an error, and the resource must be
// dropped before the parent `future-trailers` is dropped.
func FutureTrailers_Get(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[FutureTrailers]) (r0__ *wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "get", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}], error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}], error) {
					slog.Debug("reading result status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read result status byte: %w", err)
					}
					switch status {
					case 0:
						slog.Debug("reading `result::ok` payload")
						v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[*wrpc.Own[Trailers], ErrorCode], error) {
							slog.Debug("reading result status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read result status byte: %w", err)
							}
							switch status {
							case 0:
								slog.Debug("reading `result::ok` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Own[Trailers], error) {
									slog.Debug("reading option status byte")
									status, err := r.ReadByte()
									if err != nil {
										return nil, fmt.Errorf("failed to read option status byte: %w", err)
									}
									switch status {
									case 0:
										return nil, nil
									case 1:
										slog.Debug("reading `option::some` payload")
										v, err := func(r interface {
											io.ByteReader
											io.Reader
										}) (wrpc.Own[Trailers], error) {
											var x uint32
											var s uint
											for i := 0; i < 5; i++ {
												slog.Debug("reading owned resource ID length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
												}
												if b < 0x80 {
													if i == 4 && b > 1 {
														return "", errors.New("owned resource ID length overflows a 32-bit integer")
													}
													x = x | uint32(b)<<s
													buf := make([]byte, x)
													slog.Debug("reading owned resource ID bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return "", errors.New("owned resource ID is not valid UTF-8")
													}
													return wrpc.Own[Trailers](buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("owned resource ID length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
										}
										return &v, nil
									default:
										return nil, fmt.Errorf("invalid option status byte %d", status)
									}
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
								}
								return &wrpc.Result[*wrpc.Own[Trailers], ErrorCode]{Ok: &v}, nil
							case 1:
								slog.Debug("reading `result::err` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
									v := &ErrorCode{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("discriminant overflows an 8-bit integer")
												}
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch ErrorCodeDiscriminant(n) {
									case ErrorCodeDnsTimeout:
										return v.SetDnsTimeout(), nil
									case ErrorCodeDnsError:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
											v := &DnsErrorPayload{}
											var err error
											slog.Debug("reading field", "name", "rcode")
											v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
											}
											slog.Debug("reading field", "name", "info-code")
											v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint16, error) {
														var x uint16
														var s uint
														for i := 0; i < 3; i++ {
															slog.Debug("reading u16 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u16 byte: %w", err)
															}
															if b < 0x80 {
																if i == 2 && b > 1 {
																	return x, errors.New("varint overflows a 16-bit integer")
																}
																return x | uint16(b)<<s, nil
															}
															x |= uint16(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 16-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
										}
										return v.SetDnsError(payload), nil
									case ErrorCodeDestinationNotFound:
										return v.SetDestinationNotFound(), nil
									case ErrorCodeDestinationUnavailable:
										return v.SetDestinationUnavailable(), nil
									case ErrorCodeDestinationIpProhibited:
										return v.SetDestinationIpProhibited(), nil
									case ErrorCodeDestinationIpUnroutable:
										return v.SetDestinationIpUnroutable(), nil
									case ErrorCodeConnectionRefused:
										return v.SetConnectionRefused(), nil
									case ErrorCodeConnectionTerminated:
										return v.SetConnectionTerminated(), nil
									case ErrorCodeConnectionTimeout:
										return v.SetConnectionTimeout(), nil
									case ErrorCodeConnectionReadTimeout:
										return v.SetConnectionReadTimeout(), nil
									case ErrorCodeConnectionWriteTimeout:
										return v.SetConnectionWriteTimeout(), nil
									case ErrorCodeConnectionLimitReached:
										return v.SetConnectionLimitReached(), nil
									case ErrorCodeTlsProtocolError:
										return v.SetTlsProtocolError(), nil
									case ErrorCodeTlsCertificateError:
										return v.SetTlsCertificateError(), nil
									case ErrorCodeTlsAlertReceived:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
											v := &TlsAlertReceivedPayload{}
											var err error
											slog.Debug("reading field", "name", "alert-id")
											v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint8, error) {
														slog.Debug("reading u8 byte")
														v, err := r.ReadByte()
														if err != nil {
															return 0, fmt.Errorf("failed to read u8 byte: %w", err)
														}
														return v, nil
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
											}
											slog.Debug("reading field", "name", "alert-message")
											v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
										}
										return v.SetTlsAlertReceived(payload), nil
									case ErrorCodeHttpRequestDenied:
										return v.SetHttpRequestDenied(), nil
									case ErrorCodeHttpRequestLengthRequired:
										return v.SetHttpRequestLengthRequired(), nil
									case ErrorCodeHttpRequestBodySize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint64, error) {
													var x uint64
													var s uint
													for i := 0; i < 10; i++ {
														slog.Debug("reading u64 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u64 byte: %w", err)
														}
														if b < 0x80 {
															if i == 9 && b > 1 {
																return x, errors.New("varint overflows a 64-bit integer")
															}
															return x | uint64(b)<<s, nil
														}
														x |= uint64(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 64-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
										}
										return v.SetHttpRequestBodySize(payload), nil
									case ErrorCodeHttpRequestMethodInvalid:
										return v.SetHttpRequestMethodInvalid(), nil
									case ErrorCodeHttpRequestUriInvalid:
										return v.SetHttpRequestUriInvalid(), nil
									case ErrorCodeHttpRequestUriTooLong:
										return v.SetHttpRequestUriTooLong(), nil
									case ErrorCodeHttpRequestHeaderSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
										}
										return v.SetHttpRequestHeaderSectionSize(payload), nil
									case ErrorCodeHttpRequestHeaderSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
													v := &FieldSizePayload{}
													var err error
													slog.Debug("reading field", "name", "field-name")
													v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
														slog.Debug("reading option status byte")
														status, err := r.ReadByte()
														if err != nil {
															return nil, fmt.Errorf("failed to read option status byte: %w", err)
														}
														switch status {
														case 0:
															return nil, nil
														case 1:
															slog.Debug("reading `option::some` payload")
															v, err := func(r interface {
																io.ByteReader
																io.Reader
															}) (string, error) {
																var x uint32
																var s uint
																for i := 0; i < 5; i++ {
																	slog.Debug("reading string length byte", "i", i)
																	b, err := r.ReadByte()
																	if err != nil {
																		if i > 0 && err == io.EOF {
																			err = io.ErrUnexpectedEOF
																		}
																		return "", fmt.Errorf("failed to read string length byte: %w", err)
																	}
																	if b < 0x80 {
																		if i == 4 && b > 1 {
																			return "", errors.New("string length overflows a 32-bit integer")
																		}
																		x = x | uint32(b)<<s
																		buf := make([]byte, x)
																		slog.Debug("reading string bytes", "len", x)
																		_, err = r.Read(buf)
																		if err != nil {
																			return "", fmt.Errorf("failed to read string bytes: %w", err)
																		}
																		if !utf8.Valid(buf) {
																			return string(buf), errors.New("string is not valid UTF-8")
																		}
																		return string(buf), nil
																	}
																	x |= uint32(b&0x7f) << s
																	s += 7
																}
																return "", errors.New("string length overflows a 32-bit integer")
															}(r)
															if err != nil {
																return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
															}
															return &v, nil
														default:
															return nil, fmt.Errorf("invalid option status byte %d", status)
														}
													}(r, append(path, 0)...)
													if err != nil {
														return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
													}
													slog.Debug("reading field", "name", "field-size")
													v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
														slog.Debug("reading option status byte")
														status, err := r.ReadByte()
														if err != nil {
															return nil, fmt.Errorf("failed to read option status byte: %w", err)
														}
														switch status {
														case 0:
															return nil, nil
														case 1:
															slog.Debug("reading `option::some` payload")
															v, err := func(r io.ByteReader) (uint32, error) {
																var x uint32
																var s uint
																for i := 0; i < 5; i++ {
																	slog.Debug("reading u32 byte", "i", i)
																	b, err := r.ReadByte()
																	if err != nil {
																		if i > 0 && err == io.EOF {
																			err = io.ErrUnexpectedEOF
																		}
																		return x, fmt.Errorf("failed to read u32 byte: %w", err)
																	}
																	if b < 0x80 {
																		if i == 4 && b > 1 {
																			return x, errors.New("varint overflows a 32-bit integer")
																		}
																		return x | uint32(b)<<s, nil
																	}
																	x |= uint32(b&0x7f) << s
																	s += 7
																}
																return x, errors.New("varint overflows a 32-bit integer")
															}(r)
															if err != nil {
																return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
															}
															return &v, nil
														default:
															return nil, fmt.Errorf("invalid option status byte %d", status)
														}
													}(r, append(path, 1)...)
													if err != nil {
														return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
													}
													return v, nil
												}(r, path...)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
										}
										return v.SetHttpRequestHeaderSize(payload), nil
									case ErrorCodeHttpRequestTrailerSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
										}
										return v.SetHttpRequestTrailerSectionSize(payload), nil
									case ErrorCodeHttpRequestTrailerSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
										}
										return v.SetHttpRequestTrailerSize(payload), nil
									case ErrorCodeHttpResponseIncomplete:
										return v.SetHttpResponseIncomplete(), nil
									case ErrorCodeHttpResponseHeaderSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
										}
										return v.SetHttpResponseHeaderSectionSize(payload), nil
									case ErrorCodeHttpResponseHeaderSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
										}
										return v.SetHttpResponseHeaderSize(payload), nil
									case ErrorCodeHttpResponseBodySize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint64, error) {
													var x uint64
													var s uint
													for i := 0; i < 10; i++ {
														slog.Debug("reading u64 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u64 byte: %w", err)
														}
														if b < 0x80 {
															if i == 9 && b > 1 {
																return x, errors.New("varint overflows a 64-bit integer")
															}
															return x | uint64(b)<<s, nil
														}
														x |= uint64(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 64-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
										}
										return v.SetHttpResponseBodySize(payload), nil
									case ErrorCodeHttpResponseTrailerSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
										}
										return v.SetHttpResponseTrailerSectionSize(payload), nil
									case ErrorCodeHttpResponseTrailerSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
										}
										return v.SetHttpResponseTrailerSize(payload), nil
									case ErrorCodeHttpResponseTransferCoding:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
										}
										return v.SetHttpResponseTransferCoding(payload), nil
									case ErrorCodeHttpResponseContentCoding:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
										}
										return v.SetHttpResponseContentCoding(payload), nil
									case ErrorCodeHttpResponseTimeout:
										return v.SetHttpResponseTimeout(), nil
									case ErrorCodeHttpUpgradeFailed:
										return v.SetHttpUpgradeFailed(), nil
									case ErrorCodeHttpProtocolError:
										return v.SetHttpProtocolError(), nil
									case ErrorCodeLoopDetected:
										return v.SetLoopDetected(), nil
									case ErrorCodeConfigurationError:
										return v.SetConfigurationError(), nil
									case ErrorCodeInternalError:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
										}
										return v.SetInternalError(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
								}
								return &wrpc.Result[*wrpc.Own[Trailers], ErrorCode]{Err: v}, nil
							default:
								return nil, fmt.Errorf("invalid result status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
						}
						return &wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}]{Ok: v}, nil
					case 1:
						var v struct{}
						return &wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}]{Err: &v}, nil
					default:
						return nil, fmt.Errorf("invalid result status byte %d", status)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]future-trailers.get`: %w", err__)
		return
	}
	return
}

// Construct an `outgoing-response`, with a default `status-code` of `200`.
// If a different `status-code` is needed, it must be set via the
// `set-status-code` method.
//
// * `headers` is the HTTP Headers for the Response.
func NewOutgoingResponse(ctx__ context.Context, wrpc__ wrpc.Client, headers wrpc.Own[Headers]) (r0__ wrpc.Own[OutgoingResponse], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "outgoing-response", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(headers), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `headers` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[OutgoingResponse], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[OutgoingResponse](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]outgoing-response`: %w", err__)
		return
	}
	return
}

// Get the HTTP Status Code for the Response.
func OutgoingResponse_StatusCode(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingResponse]) (r0__ uint16, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "status-code", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func() (StatusCode, error) {
			v, err := func(r io.ByteReader) (uint16, error) {
				var x uint16
				var s uint
				for i := 0; i < 3; i++ {
					slog.Debug("reading u16 byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return x, fmt.Errorf("failed to read u16 byte: %w", err)
					}
					if b < 0x80 {
						if i == 2 && b > 1 {
							return x, errors.New("varint overflows a 16-bit integer")
						}
						return x | uint16(b)<<s, nil
					}
					x |= uint16(b&0x7f) << s
					s += 7
				}
				return x, errors.New("varint overflows a 16-bit integer")
			}(r__)
			return (StatusCode)(v), err
		}()

		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-response.status-code`: %w", err__)
		return
	}
	return
}

// Set the HTTP Status Code for the Response. Fails if the status-code
// given is not a valid http status code.
func OutgoingResponse_SetStatusCode(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingResponse], statusCode uint16) (r0__ *wrpc.Result[struct{}, struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "set-status-code", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint16, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen16)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u16")
			_, err = w.Write(b[:i])
			return err
		}(statusCode, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `status-code` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[struct{}, struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-response.set-status-code`: %w", err__)
		return
	}
	return
}

// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
func OutgoingResponse_Headers(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingResponse]) (r0__ wrpc.Own[Headers], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "headers", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Headers], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Headers](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-response.headers`: %w", err__)
		return
	}
	return
}

// Returns the resource corresponding to the outgoing Body for this Response.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-response` can be retrieved at most once. Subsequent
// calls will return error.
func OutgoingResponse_Body(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingResponse]) (r0__ *wrpc.Result[wrpc.Own[OutgoingBody], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "body", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[OutgoingBody], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[OutgoingBody], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[OutgoingBody](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[OutgoingBody], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[OutgoingBody], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-response.body`: %w", err__)
		return
	}
	return
}

// Returns a stream for writing the body contents.
//
// The returned `output-stream` is a child resource: it must be dropped
// before the parent `outgoing-body` resource is dropped (or finished),
// otherwise the `outgoing-body` drop or `finish` will trap.
//
// Returns success on the first call: the `output-stream` resource for
// this `outgoing-body` may be retrieved at most once. Subsequent calls
// will return error.
func OutgoingBody_Write(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutgoingBody]) (r0__ *wrpc.Result[wrpc.Own[OutputStream], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "write", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[OutputStream], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[OutputStream], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[OutputStream](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[OutputStream], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[OutputStream], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-body.write`: %w", err__)
		return
	}
	return
}

// Finalize an outgoing body, optionally providing trailers. This must be
// called to signal that the response is complete. If the `outgoing-body`
// is dropped without calling `outgoing-body.finalize`, the implementation
// should treat the body as corrupted.
//
// Fails if the body's `outgoing-request` or `outgoing-response` was
// constructed with a Content-Length header, and the contents written
// to the body (via `write`) does not match the value given in the
// Content-Length.
func OutgoingBody_Finish(ctx__ context.Context, wrpc__ wrpc.Client, this wrpc.Own[OutgoingBody], trailers *wrpc.Own[Trailers]) (r0__ *wrpc.Result[struct{}, ErrorCode], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:http/types@0.2.0", "outgoing-body.finish", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(this), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *wrpc.Own[Trailers], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(string(*v), w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(trailers, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `trailers` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, ErrorCode], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, ErrorCode]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
					v := &ErrorCode{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch ErrorCodeDiscriminant(n) {
					case ErrorCodeDnsTimeout:
						return v.SetDnsTimeout(), nil
					case ErrorCodeDnsError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
							v := &DnsErrorPayload{}
							var err error
							slog.Debug("reading field", "name", "rcode")
							v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
							}
							slog.Debug("reading field", "name", "info-code")
							v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint16, error) {
										var x uint16
										var s uint
										for i := 0; i < 3; i++ {
											slog.Debug("reading u16 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u16 byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("varint overflows a 16-bit integer")
												}
												return x | uint16(b)<<s, nil
											}
											x |= uint16(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 16-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
						}
						return v.SetDnsError(payload), nil
					case ErrorCodeDestinationNotFound:
						return v.SetDestinationNotFound(), nil
					case ErrorCodeDestinationUnavailable:
						return v.SetDestinationUnavailable(), nil
					case ErrorCodeDestinationIpProhibited:
						return v.SetDestinationIpProhibited(), nil
					case ErrorCodeDestinationIpUnroutable:
						return v.SetDestinationIpUnroutable(), nil
					case ErrorCodeConnectionRefused:
						return v.SetConnectionRefused(), nil
					case ErrorCodeConnectionTerminated:
						return v.SetConnectionTerminated(), nil
					case ErrorCodeConnectionTimeout:
						return v.SetConnectionTimeout(), nil
					case ErrorCodeConnectionReadTimeout:
						return v.SetConnectionReadTimeout(), nil
					case ErrorCodeConnectionWriteTimeout:
						return v.SetConnectionWriteTimeout(), nil
					case ErrorCodeConnectionLimitReached:
						return v.SetConnectionLimitReached(), nil
					case ErrorCodeTlsProtocolError:
						return v.SetTlsProtocolError(), nil
					case ErrorCodeTlsCertificateError:
						return v.SetTlsCertificateError(), nil
					case ErrorCodeTlsAlertReceived:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
							v := &TlsAlertReceivedPayload{}
							var err error
							slog.Debug("reading field", "name", "alert-id")
							v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint8, error) {
										slog.Debug("reading u8 byte")
										v, err := r.ReadByte()
										if err != nil {
											return 0, fmt.Errorf("failed to read u8 byte: %w", err)
										}
										return v, nil
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
							}
							slog.Debug("reading field", "name", "alert-message")
							v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
						}
						return v.SetTlsAlertReceived(payload), nil
					case ErrorCodeHttpRequestDenied:
						return v.SetHttpRequestDenied(), nil
					case ErrorCodeHttpRequestLengthRequired:
						return v.SetHttpRequestLengthRequired(), nil
					case ErrorCodeHttpRequestBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
						}
						return v.SetHttpRequestBodySize(payload), nil
					case ErrorCodeHttpRequestMethodInvalid:
						return v.SetHttpRequestMethodInvalid(), nil
					case ErrorCodeHttpRequestUriInvalid:
						return v.SetHttpRequestUriInvalid(), nil
					case ErrorCodeHttpRequestUriTooLong:
						return v.SetHttpRequestUriTooLong(), nil
					case ErrorCodeHttpRequestHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSectionSize(payload), nil
					case ErrorCodeHttpRequestHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
									v := &FieldSizePayload{}
									var err error
									slog.Debug("reading field", "name", "field-name")
									v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 0)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
									}
									slog.Debug("reading field", "name", "field-size")
									v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 1)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
									}
									return v, nil
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
						}
						return v.SetHttpRequestHeaderSize(payload), nil
					case ErrorCodeHttpRequestTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSectionSize(payload), nil
					case ErrorCodeHttpRequestTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
						}
						return v.SetHttpRequestTrailerSize(payload), nil
					case ErrorCodeHttpResponseIncomplete:
						return v.SetHttpResponseIncomplete(), nil
					case ErrorCodeHttpResponseHeaderSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSectionSize(payload), nil
					case ErrorCodeHttpResponseHeaderSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
						}
						return v.SetHttpResponseHeaderSize(payload), nil
					case ErrorCodeHttpResponseBodySize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint64, error) {
									var x uint64
									var s uint
									for i := 0; i < 10; i++ {
										slog.Debug("reading u64 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u64 byte: %w", err)
										}
										if b < 0x80 {
											if i == 9 && b > 1 {
												return x, errors.New("varint overflows a 64-bit integer")
											}
											return x | uint64(b)<<s, nil
										}
										x |= uint64(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 64-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
						}
						return v.SetHttpResponseBodySize(payload), nil
					case ErrorCodeHttpResponseTrailerSectionSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r io.ByteReader) (uint32, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading u32 byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u32 byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return x, errors.New("varint overflows a 32-bit integer")
											}
											return x | uint32(b)<<s, nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return x, errors.New("varint overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSectionSize(payload), nil
					case ErrorCodeHttpResponseTrailerSize:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
							v := &FieldSizePayload{}
							var err error
							slog.Debug("reading field", "name", "field-name")
							v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 0)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
							}
							slog.Debug("reading field", "name", "field-size")
							v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r io.ByteReader) (uint32, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading u32 byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u32 byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return x, errors.New("varint overflows a 32-bit integer")
												}
												return x | uint32(b)<<s, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return x, errors.New("varint overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return &v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, append(path, 1)...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
							}
							return v, nil
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
						}
						return v.SetHttpResponseTrailerSize(payload), nil
					case ErrorCodeHttpResponseTransferCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
						}
						return v.SetHttpResponseTransferCoding(payload), nil
					case ErrorCodeHttpResponseContentCoding:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
						}
						return v.SetHttpResponseContentCoding(payload), nil
					case ErrorCodeHttpResponseTimeout:
						return v.SetHttpResponseTimeout(), nil
					case ErrorCodeHttpUpgradeFailed:
						return v.SetHttpUpgradeFailed(), nil
					case ErrorCodeHttpProtocolError:
						return v.SetHttpProtocolError(), nil
					case ErrorCodeLoopDetected:
						return v.SetLoopDetected(), nil
					case ErrorCodeConfigurationError:
						return v.SetConfigurationError(), nil
					case ErrorCodeInternalError:
						payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
						}
						return v.SetInternalError(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, ErrorCode]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]outgoing-body.finish`: %w", err__)
		return
	}
	return
}

// Returns a pollable which becomes ready when either the Response has
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
func FutureIncomingResponse_Subscribe(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[FutureIncomingResponse]) (r0__ wrpc.Own[Pollable], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "subscribe", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Pollable], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Pollable](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]future-incoming-response.subscribe`: %w", err__)
		return
	}
	return
}

// Returns the incoming HTTP Response, or an error, once one is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the response or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the incoming HTTP Response
// status and headers have recieved successfully, or that an error
// occured. Errors may also occur while consuming the response body,
// but those will be reported by the `incoming-body` and its
// `output-stream` child.
func FutureIncomingResponse_Get(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[FutureIncomingResponse]) (r0__ *wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "get", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}], error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}], error) {
					slog.Debug("reading result status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read result status byte: %w", err)
					}
					switch status {
					case 0:
						slog.Debug("reading `result::ok` payload")
						v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], error) {
							slog.Debug("reading result status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read result status byte: %w", err)
							}
							switch status {
							case 0:
								slog.Debug("reading `result::ok` payload")
								v, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (wrpc.Own[IncomingResponse], error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading owned resource ID length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("owned resource ID length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading owned resource ID bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return "", errors.New("owned resource ID is not valid UTF-8")
											}
											return wrpc.Own[IncomingResponse](buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("owned resource ID length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
								}
								return &wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode]{Ok: &v}, nil
							case 1:
								slog.Debug("reading `result::err` payload")
								v, err := func(r wrpc.IndexReader, path ...uint32) (*ErrorCode, error) {
									v := &ErrorCode{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("discriminant overflows an 8-bit integer")
												}
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch ErrorCodeDiscriminant(n) {
									case ErrorCodeDnsTimeout:
										return v.SetDnsTimeout(), nil
									case ErrorCodeDnsError:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*DnsErrorPayload, error) {
											v := &DnsErrorPayload{}
											var err error
											slog.Debug("reading field", "name", "rcode")
											v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
											}
											slog.Debug("reading field", "name", "info-code")
											v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint16, error) {
														var x uint16
														var s uint
														for i := 0; i < 3; i++ {
															slog.Debug("reading u16 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u16 byte: %w", err)
															}
															if b < 0x80 {
																if i == 2 && b > 1 {
																	return x, errors.New("varint overflows a 16-bit integer")
																}
																return x | uint16(b)<<s, nil
															}
															x |= uint16(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 16-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
										}
										return v.SetDnsError(payload), nil
									case ErrorCodeDestinationNotFound:
										return v.SetDestinationNotFound(), nil
									case ErrorCodeDestinationUnavailable:
										return v.SetDestinationUnavailable(), nil
									case ErrorCodeDestinationIpProhibited:
										return v.SetDestinationIpProhibited(), nil
									case ErrorCodeDestinationIpUnroutable:
										return v.SetDestinationIpUnroutable(), nil
									case ErrorCodeConnectionRefused:
										return v.SetConnectionRefused(), nil
									case ErrorCodeConnectionTerminated:
										return v.SetConnectionTerminated(), nil
									case ErrorCodeConnectionTimeout:
										return v.SetConnectionTimeout(), nil
									case ErrorCodeConnectionReadTimeout:
										return v.SetConnectionReadTimeout(), nil
									case ErrorCodeConnectionWriteTimeout:
										return v.SetConnectionWriteTimeout(), nil
									case ErrorCodeConnectionLimitReached:
										return v.SetConnectionLimitReached(), nil
									case ErrorCodeTlsProtocolError:
										return v.SetTlsProtocolError(), nil
									case ErrorCodeTlsCertificateError:
										return v.SetTlsCertificateError(), nil
									case ErrorCodeTlsAlertReceived:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*TlsAlertReceivedPayload, error) {
											v := &TlsAlertReceivedPayload{}
											var err error
											slog.Debug("reading field", "name", "alert-id")
											v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint8, error) {
														slog.Debug("reading u8 byte")
														v, err := r.ReadByte()
														if err != nil {
															return 0, fmt.Errorf("failed to read u8 byte: %w", err)
														}
														return v, nil
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
											}
											slog.Debug("reading field", "name", "alert-message")
											v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
										}
										return v.SetTlsAlertReceived(payload), nil
									case ErrorCodeHttpRequestDenied:
										return v.SetHttpRequestDenied(), nil
									case ErrorCodeHttpRequestLengthRequired:
										return v.SetHttpRequestLengthRequired(), nil
									case ErrorCodeHttpRequestBodySize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint64, error) {
													var x uint64
													var s uint
													for i := 0; i < 10; i++ {
														slog.Debug("reading u64 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u64 byte: %w", err)
														}
														if b < 0x80 {
															if i == 9 && b > 1 {
																return x, errors.New("varint overflows a 64-bit integer")
															}
															return x | uint64(b)<<s, nil
														}
														x |= uint64(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 64-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
										}
										return v.SetHttpRequestBodySize(payload), nil
									case ErrorCodeHttpRequestMethodInvalid:
										return v.SetHttpRequestMethodInvalid(), nil
									case ErrorCodeHttpRequestUriInvalid:
										return v.SetHttpRequestUriInvalid(), nil
									case ErrorCodeHttpRequestUriTooLong:
										return v.SetHttpRequestUriTooLong(), nil
									case ErrorCodeHttpRequestHeaderSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
										}
										return v.SetHttpRequestHeaderSectionSize(payload), nil
									case ErrorCodeHttpRequestHeaderSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
													v := &FieldSizePayload{}
													var err error
													slog.Debug("reading field", "name", "field-name")
													v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
														slog.Debug("reading option status byte")
														status, err := r.ReadByte()
														if err != nil {
															return nil, fmt.Errorf("failed to read option status byte: %w", err)
														}
														switch status {
														case 0:
															return nil, nil
														case 1:
															slog.Debug("reading `option::some` payload")
															v, err := func(r interface {
																io.ByteReader
																io.Reader
															}) (string, error) {
																var x uint32
																var s uint
																for i := 0; i < 5; i++ {
																	slog.Debug("reading string length byte", "i", i)
																	b, err := r.ReadByte()
																	if err != nil {
																		if i > 0 && err == io.EOF {
																			err = io.ErrUnexpectedEOF
																		}
																		return "", fmt.Errorf("failed to read string length byte: %w", err)
																	}
																	if b < 0x80 {
																		if i == 4 && b > 1 {
																			return "", errors.New("string length overflows a 32-bit integer")
																		}
																		x = x | uint32(b)<<s
																		buf := make([]byte, x)
																		slog.Debug("reading string bytes", "len", x)
																		_, err = r.Read(buf)
																		if err != nil {
																			return "", fmt.Errorf("failed to read string bytes: %w", err)
																		}
																		if !utf8.Valid(buf) {
																			return string(buf), errors.New("string is not valid UTF-8")
																		}
																		return string(buf), nil
																	}
																	x |= uint32(b&0x7f) << s
																	s += 7
																}
																return "", errors.New("string length overflows a 32-bit integer")
															}(r)
															if err != nil {
																return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
															}
															return &v, nil
														default:
															return nil, fmt.Errorf("invalid option status byte %d", status)
														}
													}(r, append(path, 0)...)
													if err != nil {
														return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
													}
													slog.Debug("reading field", "name", "field-size")
													v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
														slog.Debug("reading option status byte")
														status, err := r.ReadByte()
														if err != nil {
															return nil, fmt.Errorf("failed to read option status byte: %w", err)
														}
														switch status {
														case 0:
															return nil, nil
														case 1:
															slog.Debug("reading `option::some` payload")
															v, err := func(r io.ByteReader) (uint32, error) {
																var x uint32
																var s uint
																for i := 0; i < 5; i++ {
																	slog.Debug("reading u32 byte", "i", i)
																	b, err := r.ReadByte()
																	if err != nil {
																		if i > 0 && err == io.EOF {
																			err = io.ErrUnexpectedEOF
																		}
																		return x, fmt.Errorf("failed to read u32 byte: %w", err)
																	}
																	if b < 0x80 {
																		if i == 4 && b > 1 {
																			return x, errors.New("varint overflows a 32-bit integer")
																		}
																		return x | uint32(b)<<s, nil
																	}
																	x |= uint32(b&0x7f) << s
																	s += 7
																}
																return x, errors.New("varint overflows a 32-bit integer")
															}(r)
															if err != nil {
																return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
															}
															return &v, nil
														default:
															return nil, fmt.Errorf("invalid option status byte %d", status)
														}
													}(r, append(path, 1)...)
													if err != nil {
														return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
													}
													return v, nil
												}(r, path...)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
										}
										return v.SetHttpRequestHeaderSize(payload), nil
									case ErrorCodeHttpRequestTrailerSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
										}
										return v.SetHttpRequestTrailerSectionSize(payload), nil
									case ErrorCodeHttpRequestTrailerSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
										}
										return v.SetHttpRequestTrailerSize(payload), nil
									case ErrorCodeHttpResponseIncomplete:
										return v.SetHttpResponseIncomplete(), nil
									case ErrorCodeHttpResponseHeaderSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
										}
										return v.SetHttpResponseHeaderSectionSize(payload), nil
									case ErrorCodeHttpResponseHeaderSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
										}
										return v.SetHttpResponseHeaderSize(payload), nil
									case ErrorCodeHttpResponseBodySize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint64, error) {
													var x uint64
													var s uint
													for i := 0; i < 10; i++ {
														slog.Debug("reading u64 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u64 byte: %w", err)
														}
														if b < 0x80 {
															if i == 9 && b > 1 {
																return x, errors.New("varint overflows a 64-bit integer")
															}
															return x | uint64(b)<<s, nil
														}
														x |= uint64(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 64-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
										}
										return v.SetHttpResponseBodySize(payload), nil
									case ErrorCodeHttpResponseTrailerSectionSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
										}
										return v.SetHttpResponseTrailerSectionSize(payload), nil
									case ErrorCodeHttpResponseTrailerSize:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*FieldSizePayload, error) {
											v := &FieldSizePayload{}
											var err error
											slog.Debug("reading field", "name", "field-name")
											v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r interface {
														io.ByteReader
														io.Reader
													}) (string, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading string length byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return "", fmt.Errorf("failed to read string length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return "", errors.New("string length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading string bytes", "len", x)
																_, err = r.Read(buf)
																if err != nil {
																	return "", fmt.Errorf("failed to read string bytes: %w", err)
																}
																if !utf8.Valid(buf) {
																	return string(buf), errors.New("string is not valid UTF-8")
																}
																return string(buf), nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return "", errors.New("string length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 0)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
											}
											slog.Debug("reading field", "name", "field-size")
											v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
												slog.Debug("reading option status byte")
												status, err := r.ReadByte()
												if err != nil {
													return nil, fmt.Errorf("failed to read option status byte: %w", err)
												}
												switch status {
												case 0:
													return nil, nil
												case 1:
													slog.Debug("reading `option::some` payload")
													v, err := func(r io.ByteReader) (uint32, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading u32 byte", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return x, fmt.Errorf("failed to read u32 byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return x, errors.New("varint overflows a 32-bit integer")
																}
																return x | uint32(b)<<s, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return x, errors.New("varint overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
													}
													return &v, nil
												default:
													return nil, fmt.Errorf("invalid option status byte %d", status)
												}
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
										}
										return v.SetHttpResponseTrailerSize(payload), nil
									case ErrorCodeHttpResponseTransferCoding:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
										}
										return v.SetHttpResponseTransferCoding(payload), nil
									case ErrorCodeHttpResponseContentCoding:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
										}
										return v.SetHttpResponseContentCoding(payload), nil
									case ErrorCodeHttpResponseTimeout:
										return v.SetHttpResponseTimeout(), nil
									case ErrorCodeHttpUpgradeFailed:
										return v.SetHttpUpgradeFailed(), nil
									case ErrorCodeHttpProtocolError:
										return v.SetHttpProtocolError(), nil
									case ErrorCodeLoopDetected:
										return v.SetLoopDetected(), nil
									case ErrorCodeConfigurationError:
										return v.SetConfigurationError(), nil
									case ErrorCodeInternalError:
										payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
										}
										return v.SetInternalError(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
								}
								return &wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode]{Err: v}, nil
							default:
								return nil, fmt.Errorf("invalid result status byte %d", status)
							}
						}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
						}
						return &wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}]{Ok: v}, nil
					case 1:
						var v struct{}
						return &wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}]{Err: &v}, nil
					default:
						return nil, fmt.Errorf("invalid result status byte %d", status)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]future-incoming-response.get`: %w", err__)
		return
	}
	return
}

type Fields interface {
	// Get all of the values corresponding to a key. If the key is not present
	// in this `fields`, an empty list is returned. However, if the key is
	// present but empty, this is represented by a list with one or more
	// empty field-values present.
	Get(ctx__ context.Context, wrpc__ wrpc.Client, name string) ([][]uint8, func() error, error)
	// Returns `true` when the key is present in this `fields`. If the key is
	// syntactically invalid, `false` is returned.
	Has(ctx__ context.Context, wrpc__ wrpc.Client, name string) (bool, func() error, error)
	// Set all of the values for a key. Clears any existing values for that
	// key, if they have been set.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Set(ctx__ context.Context, wrpc__ wrpc.Client, name string, value [][]uint8) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Delete all values for a key. Does nothing if no values for the key
	// exist.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Delete(ctx__ context.Context, wrpc__ wrpc.Client, name string) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Append a value for a key. Does not change or delete any existing
	// values for that key.
	//
	// Fails with `header-error.immutable` if the `fields` are immutable.
	Append(ctx__ context.Context, wrpc__ wrpc.Client, name string, value []uint8) (*wrpc.Result[struct{}, HeaderError], func() error, error)
	// Retrieve the full set of keys and values in the Fields. Like the
	// constructor, the list represents each key-value pair.
	//
	// The outer list represents each key-value pair in the Fields. Keys
	// which have multiple values are represented by multiple entries in this
	// list with the same key.
	Entries(ctx__ context.Context, wrpc__ wrpc.Client) ([]*wrpc.Tuple2[string, []uint8], func() error, error)
	// Make a deep copy of the Fields. Equivelant in behavior to calling the
	// `fields` constructor on the return value of `entries`. The resulting
	// `fields` is mutable.
	Clone(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Fields], func() error, error)
}
type IncomingRequest interface {
	// Returns the method of the incoming request.
	Method(ctx__ context.Context, wrpc__ wrpc.Client) (*Method, func() error, error)
	// Returns the path with query parameters from the request, as a string.
	PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Returns the protocol scheme from the request.
	Scheme(ctx__ context.Context, wrpc__ wrpc.Client) (*Scheme, func() error, error)
	// Returns the authority from the request, if it was present.
	Authority(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Get the `headers` associated with the request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// The `headers` returned are a child resource: it must be dropped before
	// the parent `incoming-request` is dropped. Dropping this
	// `incoming-request` before all children are dropped will trap.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Headers], func() error, error)
	// Gives the `incoming-body` associated with this request. Will only
	// return success at most once, and subsequent calls will return error.
	Consume(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[IncomingBody], struct{}], func() error, error)
}
type OutgoingRequest interface {
	// Returns the resource corresponding to the outgoing Body for this
	// Request.
	//
	// Returns success on the first call: the `outgoing-body` resource for
	// this `outgoing-request` can be retrieved at most once. Subsequent
	// calls will return error.
	Body(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[OutgoingBody], struct{}], func() error, error)
	// Get the Method for the Request.
	Method(ctx__ context.Context, wrpc__ wrpc.Client) (*Method, func() error, error)
	// Set the Method for the Request. Fails if the string present in a
	// `method.other` argument is not a syntactically valid method.
	SetMethod(ctx__ context.Context, wrpc__ wrpc.Client, method *Method) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the combination of the HTTP Path and Query for the Request.
	// When `none`, this represents an empty Path and empty Query.
	PathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Set the combination of the HTTP Path and Query for the Request.
	// When `none`, this represents an empty Path and empty Query. Fails is the
	// string given is not a syntactically valid path and query uri component.
	SetPathWithQuery(ctx__ context.Context, wrpc__ wrpc.Client, pathWithQuery *string) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the HTTP Related Scheme for the Request. When `none`, the
	// implementation may choose an appropriate default scheme.
	Scheme(ctx__ context.Context, wrpc__ wrpc.Client) (*Scheme, func() error, error)
	// Set the HTTP Related Scheme for the Request. When `none`, the
	// implementation may choose an appropriate default scheme. Fails if the
	// string given is not a syntactically valid uri scheme.
	SetScheme(ctx__ context.Context, wrpc__ wrpc.Client, scheme *Scheme) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the HTTP Authority for the Request. A value of `none` may be used
	// with Related Schemes which do not require an Authority. The HTTP and
	// HTTPS schemes always require an authority.
	Authority(ctx__ context.Context, wrpc__ wrpc.Client) (*string, func() error, error)
	// Set the HTTP Authority for the Request. A value of `none` may be used
	// with Related Schemes which do not require an Authority. The HTTP and
	// HTTPS schemes always require an authority. Fails if the string given is
	// not a syntactically valid uri authority.
	SetAuthority(ctx__ context.Context, wrpc__ wrpc.Client, authority *string) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the headers associated with the Request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `outgoing-request` is dropped, or its ownership is transfered to
	// another component by e.g. `outgoing-handler.handle`.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Headers], func() error, error)
}
type RequestOptions interface {
	// The timeout for the initial connect to the HTTP Server.
	ConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for the initial connect to the HTTP Server. An error
	// return value indicates that this timeout is not supported.
	SetConnectTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// The timeout for receiving the first byte of the Response body.
	FirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for receiving the first byte of the Response body. An
	// error return value indicates that this timeout is not supported.
	SetFirstByteTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// The timeout for receiving subsequent chunks of bytes in the Response
	// body stream.
	BetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client) (*Duration, func() error, error)
	// Set the timeout for receiving subsequent chunks of bytes in the Response
	// body stream. An error return value indicates that this timeout is not
	// supported.
	SetBetweenBytesTimeout(ctx__ context.Context, wrpc__ wrpc.Client, duration *Duration) (*wrpc.Result[struct{}, struct{}], func() error, error)
}
type ResponseOutparam interface {
}
type IncomingResponse interface {
	// Returns the status code from the incoming response.
	Status(ctx__ context.Context, wrpc__ wrpc.Client) (uint16, func() error, error)
	// Returns the headers from the incoming response.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `incoming-response` is dropped.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Headers], func() error, error)
	// Returns the incoming body. May be called at most once. Returns error
	// if called additional times.
	Consume(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[IncomingBody], struct{}], func() error, error)
}
type IncomingBody interface {
	// Returns the contents of the body, as a stream of bytes.
	//
	// Returns success on first call: the stream representing the contents
	// can be retrieved at most once. Subsequent calls will return error.
	//
	// The returned `input-stream` resource is a child: it must be dropped
	// before the parent `incoming-body` is dropped, or consumed by
	// `incoming-body.finish`.
	//
	// This invariant ensures that the implementation can determine whether
	// the user is consuming the contents of the body, waiting on the
	// `future-trailers` to be ready, or neither. This allows for network
	// backpressure is to be applied when the user is consuming the body,
	// and for that backpressure to not inhibit delivery of the trailers if
	// the user does not read the entire body.
	Stream(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[InputStream], struct{}], func() error, error)
}
type FutureTrailers interface {
	// Returns a pollable which becomes ready when either the trailers have
	// been received, or an error has occured. When this pollable is ready,
	// the `get` method will return `some`.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Pollable], func() error, error)
	// Returns the contents of the trailers, or an error which occured,
	// once the future is ready.
	//
	// The outer `option` represents future readiness. Users can wait on this
	// `option` to become `some` using the `subscribe` method.
	//
	// The outer `result` is used to retrieve the trailers or error at most
	// once. It will be success on the first call in which the outer option
	// is `some`, and error on subsequent calls.
	//
	// The inner `result` represents that either the HTTP Request or Response
	// body, as well as any trailers, were received successfully, or that an
	// error occured receiving them. The optional `trailers` indicates whether
	// or not trailers were present in the body.
	//
	// When some `trailers` are returned by this method, the `trailers`
	// resource is immutable, and a child. Use of the `set`, `append`, or
	// `delete` methods will return an error, and the resource must be
	// dropped before the parent `future-trailers` is dropped.
	Get(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Result[*wrpc.Own[Trailers], ErrorCode], struct{}], func() error, error)
}
type OutgoingResponse interface {
	// Get the HTTP Status Code for the Response.
	StatusCode(ctx__ context.Context, wrpc__ wrpc.Client) (uint16, func() error, error)
	// Set the HTTP Status Code for the Response. Fails if the status-code
	// given is not a valid http status code.
	SetStatusCode(ctx__ context.Context, wrpc__ wrpc.Client, statusCode uint16) (*wrpc.Result[struct{}, struct{}], func() error, error)
	// Get the headers associated with the Request.
	//
	// The returned `headers` resource is immutable: `set`, `append`, and
	// `delete` operations will fail with `header-error.immutable`.
	//
	// This headers resource is a child: it must be dropped before the parent
	// `outgoing-request` is dropped, or its ownership is transfered to
	// another component by e.g. `outgoing-handler.handle`.
	Headers(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Headers], func() error, error)
	// Returns the resource corresponding to the outgoing Body for this Response.
	//
	// Returns success on the first call: the `outgoing-body` resource for
	// this `outgoing-response` can be retrieved at most once. Subsequent
	// calls will return error.
	Body(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[OutgoingBody], struct{}], func() error, error)
}
type OutgoingBody interface {
	// Returns a stream for writing the body contents.
	//
	// The returned `output-stream` is a child resource: it must be dropped
	// before the parent `outgoing-body` resource is dropped (or finished),
	// otherwise the `outgoing-body` drop or `finish` will trap.
	//
	// Returns success on the first call: the `output-stream` resource for
	// this `outgoing-body` may be retrieved at most once. Subsequent calls
	// will return error.
	Write(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Own[OutputStream], struct{}], func() error, error)
}
type FutureIncomingResponse interface {
	// Returns a pollable which becomes ready when either the Response has
	// been received, or an error has occured. When this pollable is ready,
	// the `get` method will return `some`.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Pollable], func() error, error)
	// Returns the incoming HTTP Response, or an error, once one is ready.
	//
	// The outer `option` represents future readiness. Users can wait on this
	// `option` to become `some` using the `subscribe` method.
	//
	// The outer `result` is used to retrieve the response or error at most
	// once. It will be success on the first call in which the outer option
	// is `some`, and error on subsequent calls.
	//
	// The inner `result` represents that either the incoming HTTP Response
	// status and headers have recieved successfully, or that an error
	// occured. Errors may also occur while consuming the response body,
	// but those will be reported by the `incoming-body` and its
	// `output-stream` child.
	Get(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[wrpc.Result[wrpc.Own[IncomingResponse], ErrorCode], struct{}], func() error, error)
}
