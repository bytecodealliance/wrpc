// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package outgoing_handler

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	wasi__clocks__monotonic_clock "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/clocks/monotonic_clock"
	wasi__http__types "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/http/types"
	wrpc__http__types "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wrpc/http/types"
	wrpc "github.com/wrpc/wrpc/go"
	errgroup "golang.org/x/sync/errgroup"
	io "io"
	slog "log/slog"
	utf8 "unicode/utf8"
)

type Request = wrpc__http__types.Request
type Response = wrpc__http__types.Response
type ErrorCode = wrpc__http__types.ErrorCode
type RequestOptions = wrpc__http__types.RequestOptions
type Handler interface {
	Handle(ctx__ context.Context, request *wrpc__http__types.Request, options *RequestOptions) (*wrpc.Result[Response, ErrorCode], error)
}

func ServeInterface(c wrpc.Client, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 1)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}
	stop0, err := c.Serve("wrpc:http/outgoing-handler@0.1.0", "handle", func(ctx context.Context, w wrpc.IndexWriter, r wrpc.IndexReadCloser) error {
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (*Request, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Request, error) {
				v := &wrpc__http__types.Request{}
				var err error
				slog.Debug("reading field", "name", "body")
				v.Body, err = func(r wrpc.IndexReader, path ...uint32) (wrpc.ReadCompleter, error) {
					slog.Debug("reading byte stream status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read byte stream status byte: %w", err)
					}
					switch status {
					case 0:
						if len(path) > 0 {
							r, err = r.Index(path...)
							if err != nil {
								return nil, fmt.Errorf("failed to index reader: %w", err)
							}
						}
						return wrpc.NewByteStreamReader(wrpc.NewPendingByteReader(r)), nil
					case 1:
						slog.Debug("reading ready byte stream contents")
						buf, err :=
							func(r interface {
								io.ByteReader
								io.Reader
							}) ([]byte, error) {
								var x uint32
								var s uint
								for i := 0; i < 5; i++ {
									slog.Debug("reading byte list length", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
									}
									if b < 0x80 {
										if i == 4 && b > 1 {
											return nil, errors.New("byte list length overflows a 32-bit integer")
										}
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading byte list contents", "len", x)
										_, err = io.ReadFull(r, buf)
										if err != nil {
											return nil, fmt.Errorf("failed to read byte list contents: %w", err)
										}
										return buf, nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return nil, errors.New("byte length overflows a 32-bit integer")
							}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read ready byte stream contents: %w", err)
						}
						slog.Debug("read ready byte stream contents", "len", len(buf))
						return wrpc.NewCompleteReader(bytes.NewReader(buf)), nil
					default:
						return nil, fmt.Errorf("invalid stream status byte %d", status)
					}
				}(r, append(path, 0)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `body` field: %w", err)
				}
				slog.Debug("reading field", "name", "trailers")
				v.Trailers, err = func(r wrpc.IndexReader, path ...uint32) (wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]], error) {
					slog.Debug("reading future status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read future status byte: %w", err)
					}
					switch status {
					case 0:
						if len(path) > 0 {
							r, err = r.Index(path...)
							if err != nil {
								return nil, fmt.Errorf("failed to index reader: %w", err)
							}
						}
						return wrpc.NewDecodeReceiver(r, func(r wrpc.IndexReader) ([]*wrpc.Tuple2[string, [][]uint8], error) {
							slog.Debug("reading pending future element")
							v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading list length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return nil, fmt.Errorf("failed to read list length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return nil, errors.New("list length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
												for i := range vs {
													slog.Debug("reading list element", "i", i)
													vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
														v := &wrpc.Tuple2[string, [][]uint8]{}
														var err error
														slog.Debug("reading tuple element 0")
														v.V0, err = func(r interface {
															io.ByteReader
															io.Reader
														}) (string, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading string length byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return "", fmt.Errorf("failed to read string length byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return "", errors.New("string length overflows a 32-bit integer")
																	}
																	x = x | uint32(b)<<s
																	buf := make([]byte, x)
																	slog.Debug("reading string bytes", "len", x)
																	_, err = r.Read(buf)
																	if err != nil {
																		return "", fmt.Errorf("failed to read string bytes: %w", err)
																	}
																	if !utf8.Valid(buf) {
																		return string(buf), errors.New("string is not valid UTF-8")
																	}
																	return string(buf), nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return "", errors.New("string length overflows a 32-bit integer")
														}(r)
														if err != nil {
															return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
														}
														slog.Debug("reading tuple element 1")
														v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading list length byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return nil, fmt.Errorf("failed to read list length byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return nil, errors.New("list length overflows a 32-bit integer")
																	}
																	x = x | uint32(b)<<s
																	vs := make([][]uint8, x)
																	for i := range vs {
																		slog.Debug("reading list element", "i", i)
																		vs[i], err = func(r interface {
																			io.ByteReader
																			io.Reader
																		}) ([]byte, error) {
																			var x uint32
																			var s uint
																			for i := 0; i < 5; i++ {
																				slog.Debug("reading byte list length", "i", i)
																				b, err := r.ReadByte()
																				if err != nil {
																					if i > 0 && err == io.EOF {
																						err = io.ErrUnexpectedEOF
																					}
																					return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
																				}
																				if b < 0x80 {
																					if i == 4 && b > 1 {
																						return nil, errors.New("byte list length overflows a 32-bit integer")
																					}
																					x = x | uint32(b)<<s
																					buf := make([]byte, x)
																					slog.Debug("reading byte list contents", "len", x)
																					_, err = io.ReadFull(r, buf)
																					if err != nil {
																						return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																					}
																					return buf, nil
																				}
																				x |= uint32(b&0x7f) << s
																				s += 7
																			}
																			return nil, errors.New("byte length overflows a 32-bit integer")
																		}(r)
																		if err != nil {
																			return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
																		}
																	}
																	return vs, nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return nil, errors.New("list length overflows a 32-bit integer")
														}(r, append(path, 1)...)
														if err != nil {
															return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
														}
														return v, nil
													}(r, append(path, uint32(i))...)
													if err != nil {
														return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
													}
												}
												return vs, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return nil, errors.New("list length overflows a 32-bit integer")
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read pending future element: %w", err)
							}
							return v, nil
						}), nil
					case 1:
						slog.Debug("reading ready future contents")
						v, err :=
							func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
								slog.Debug("reading option status byte")
								status, err := r.ReadByte()
								if err != nil {
									return nil, fmt.Errorf("failed to read option status byte: %w", err)
								}
								switch status {
								case 0:
									return nil, nil
								case 1:
									slog.Debug("reading `option::some` payload")
									v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading list length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return nil, fmt.Errorf("failed to read list length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return nil, errors.New("list length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
												for i := range vs {
													slog.Debug("reading list element", "i", i)
													vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
														v := &wrpc.Tuple2[string, [][]uint8]{}
														var err error
														slog.Debug("reading tuple element 0")
														v.V0, err = func(r interface {
															io.ByteReader
															io.Reader
														}) (string, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading string length byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return "", fmt.Errorf("failed to read string length byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return "", errors.New("string length overflows a 32-bit integer")
																	}
																	x = x | uint32(b)<<s
																	buf := make([]byte, x)
																	slog.Debug("reading string bytes", "len", x)
																	_, err = r.Read(buf)
																	if err != nil {
																		return "", fmt.Errorf("failed to read string bytes: %w", err)
																	}
																	if !utf8.Valid(buf) {
																		return string(buf), errors.New("string is not valid UTF-8")
																	}
																	return string(buf), nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return "", errors.New("string length overflows a 32-bit integer")
														}(r)
														if err != nil {
															return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
														}
														slog.Debug("reading tuple element 1")
														v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading list length byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return nil, fmt.Errorf("failed to read list length byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return nil, errors.New("list length overflows a 32-bit integer")
																	}
																	x = x | uint32(b)<<s
																	vs := make([][]uint8, x)
																	for i := range vs {
																		slog.Debug("reading list element", "i", i)
																		vs[i], err = func(r interface {
																			io.ByteReader
																			io.Reader
																		}) ([]byte, error) {
																			var x uint32
																			var s uint
																			for i := 0; i < 5; i++ {
																				slog.Debug("reading byte list length", "i", i)
																				b, err := r.ReadByte()
																				if err != nil {
																					if i > 0 && err == io.EOF {
																						err = io.ErrUnexpectedEOF
																					}
																					return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
																				}
																				if b < 0x80 {
																					if i == 4 && b > 1 {
																						return nil, errors.New("byte list length overflows a 32-bit integer")
																					}
																					x = x | uint32(b)<<s
																					buf := make([]byte, x)
																					slog.Debug("reading byte list contents", "len", x)
																					_, err = io.ReadFull(r, buf)
																					if err != nil {
																						return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																					}
																					return buf, nil
																				}
																				x |= uint32(b&0x7f) << s
																				s += 7
																			}
																			return nil, errors.New("byte length overflows a 32-bit integer")
																		}(r)
																		if err != nil {
																			return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
																		}
																	}
																	return vs, nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return nil, errors.New("list length overflows a 32-bit integer")
														}(r, append(path, 1)...)
														if err != nil {
															return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
														}
														return v, nil
													}(r, append(path, uint32(i))...)
													if err != nil {
														return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
													}
												}
												return vs, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return nil, errors.New("list length overflows a 32-bit integer")
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
									}
									return v, nil
								default:
									return nil, fmt.Errorf("invalid option status byte %d", status)
								}
							}(r, path...)
						if err != nil {
							return nil, fmt.Errorf("failed to read ready future contents: %w", err)
						}
						return wrpc.NewCompleteReceiver(v), nil
					default:
						return nil, fmt.Errorf("invalid future status byte %d", status)
					}
				}(r, append(path, 1)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `trailers` field: %w", err)
				}
				slog.Debug("reading field", "name", "method")
				v.Method, err = func() (*wrpc__http__types.Method, error) {
					v, err := func() (*wrpc__http__types.WasiMethod, error) {
						v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.Method, error) {
							v := &wasi__http__types.Method{}
							n, err := func(r io.ByteReader) (uint8, error) {
								var x uint8
								var s uint
								for i := 0; i < 2; i++ {
									slog.Debug("reading u8 discriminant byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
									}
									if b < 0x80 {
										if i == 2 && b > 1 {
											return x, errors.New("discriminant overflows an 8-bit integer")
										}
										return x | uint8(b)<<s, nil
									}
									x |= uint8(b&0x7f) << s
									s += 7
								}
								return x, errors.New("discriminant overflows an 8-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read discriminant: %w", err)
							}
							switch wasi__http__types.MethodDiscriminant(n) {
							case wasi__http__types.MethodDiscriminant_Get:
								return v.SetGet(), nil
							case wasi__http__types.MethodDiscriminant_Head:
								return v.SetHead(), nil
							case wasi__http__types.MethodDiscriminant_Post:
								return v.SetPost(), nil
							case wasi__http__types.MethodDiscriminant_Put:
								return v.SetPut(), nil
							case wasi__http__types.MethodDiscriminant_Delete:
								return v.SetDelete(), nil
							case wasi__http__types.MethodDiscriminant_Connect:
								return v.SetConnect(), nil
							case wasi__http__types.MethodDiscriminant_Options:
								return v.SetOptions(), nil
							case wasi__http__types.MethodDiscriminant_Trace:
								return v.SetTrace(), nil
							case wasi__http__types.MethodDiscriminant_Patch:
								return v.SetPatch(), nil
							case wasi__http__types.MethodDiscriminant_Other:
								payload, err := func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if b < 0x80 {
											if i == 4 && b > 1 {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read `other` payload: %w", err)
								}
								return v.SetOther(payload), nil
							default:
								return nil, fmt.Errorf("unknown discriminant value %d", n)
							}
						}(r, append(path, 2)...)
						return (*wrpc__http__types.WasiMethod)(v), err
					}()

					return (*wrpc__http__types.Method)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `method` field: %w", err)
				}
				slog.Debug("reading field", "name", "path-with-query")
				v.PathWithQuery, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
					slog.Debug("reading option status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read option status byte: %w", err)
					}
					switch status {
					case 0:
						return nil, nil
					case 1:
						slog.Debug("reading `option::some` payload")
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
						}
						return &v, nil
					default:
						return nil, fmt.Errorf("invalid option status byte %d", status)
					}
				}(r, append(path, 3)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `path-with-query` field: %w", err)
				}
				slog.Debug("reading field", "name", "scheme")
				v.Scheme, err = func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Scheme, error) {
					slog.Debug("reading option status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read option status byte: %w", err)
					}
					switch status {
					case 0:
						return nil, nil
					case 1:
						slog.Debug("reading `option::some` payload")
						v, err := func() (*wrpc__http__types.Scheme, error) {
							v, err := func() (*wrpc__http__types.WasiScheme, error) {
								v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.Scheme, error) {
									v := &wasi__http__types.Scheme{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if b < 0x80 {
												if i == 2 && b > 1 {
													return x, errors.New("discriminant overflows an 8-bit integer")
												}
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasi__http__types.SchemeDiscriminant(n) {
									case wasi__http__types.SchemeDiscriminant_Http:
										return v.SetHttp(), nil
									case wasi__http__types.SchemeDiscriminant_Https:
										return v.SetHttps(), nil
									case wasi__http__types.SchemeDiscriminant_Other:
										payload, err := func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if b < 0x80 {
													if i == 4 && b > 1 {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													x = x | uint32(b)<<s
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read `other` payload: %w", err)
										}
										return v.SetOther(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*wrpc__http__types.WasiScheme)(v), err
							}()

							return (*wrpc__http__types.Scheme)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
						}
						return v, nil
					default:
						return nil, fmt.Errorf("invalid option status byte %d", status)
					}
				}(r, append(path, 4)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `scheme` field: %w", err)
				}
				slog.Debug("reading field", "name", "authority")
				v.Authority, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
					slog.Debug("reading option status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read option status byte: %w", err)
					}
					switch status {
					case 0:
						return nil, nil
					case 1:
						slog.Debug("reading `option::some` payload")
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
						}
						return &v, nil
					default:
						return nil, fmt.Errorf("invalid option status byte %d", status)
					}
				}(r, append(path, 5)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `authority` field: %w", err)
				}
				slog.Debug("reading field", "name", "headers")
				v.Headers, err = func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading list length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
							for i := range vs {
								slog.Debug("reading list element", "i", i)
								vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
									v := &wrpc.Tuple2[string, [][]uint8]{}
									var err error
									slog.Debug("reading tuple element 0")
									v.V0, err = func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
									}
									slog.Debug("reading tuple element 1")
									v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading list length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return nil, fmt.Errorf("failed to read list length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return nil, errors.New("list length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												vs := make([][]uint8, x)
												for i := range vs {
													slog.Debug("reading list element", "i", i)
													vs[i], err = func(r interface {
														io.ByteReader
														io.Reader
													}) ([]byte, error) {
														var x uint32
														var s uint
														for i := 0; i < 5; i++ {
															slog.Debug("reading byte list length", "i", i)
															b, err := r.ReadByte()
															if err != nil {
																if i > 0 && err == io.EOF {
																	err = io.ErrUnexpectedEOF
																}
																return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
															}
															if b < 0x80 {
																if i == 4 && b > 1 {
																	return nil, errors.New("byte list length overflows a 32-bit integer")
																}
																x = x | uint32(b)<<s
																buf := make([]byte, x)
																slog.Debug("reading byte list contents", "len", x)
																_, err = io.ReadFull(r, buf)
																if err != nil {
																	return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																}
																return buf, nil
															}
															x |= uint32(b&0x7f) << s
															s += 7
														}
														return nil, errors.New("byte length overflows a 32-bit integer")
													}(r)
													if err != nil {
														return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
													}
												}
												return vs, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return nil, errors.New("list length overflows a 32-bit integer")
									}(r, append(path, 1)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
									}
									return v, nil
								}(r, append(path, uint32(i))...)
								if err != nil {
									return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
								}
							}
							return vs, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("list length overflows a 32-bit integer")
				}(r, append(path, 6)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `headers` field: %w", err)
				}
				return v, nil
			}(r, []uint32{0}...)
			return (*Request)(v), err
		}()

		if err != nil {
			return fmt.Errorf("failed to read parameter 0: %w", err)
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReader, path ...uint32) (*RequestOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func() (*RequestOptions, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.RequestOptions, error) {
						v := &wrpc__http__types.RequestOptions{}
						var err error
						slog.Debug("reading field", "name", "connect-timeout")
						v.ConnectTimeout, err = func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Duration, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func() (wrpc__http__types.Duration, error) {
									v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
										v, err := func(r io.ByteReader) (uint64, error) {
											var x uint64
											var s uint
											for i := 0; i < 10; i++ {
												slog.Debug("reading u64 byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return x, fmt.Errorf("failed to read u64 byte: %w", err)
												}
												if b < 0x80 {
													if i == 9 && b > 1 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													return x | uint64(b)<<s, nil
												}
												x |= uint64(b&0x7f) << s
												s += 7
											}
											return x, errors.New("varint overflows a 64-bit integer")
										}(r)
										return (wasi__clocks__monotonic_clock.Duration)(v), err
									}()

									return (wrpc__http__types.Duration)(v), err
								}()

								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, append(path, 0)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `connect-timeout` field: %w", err)
						}
						slog.Debug("reading field", "name", "first-byte-timeout")
						v.FirstByteTimeout, err = func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Duration, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func() (wrpc__http__types.Duration, error) {
									v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
										v, err := func(r io.ByteReader) (uint64, error) {
											var x uint64
											var s uint
											for i := 0; i < 10; i++ {
												slog.Debug("reading u64 byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return x, fmt.Errorf("failed to read u64 byte: %w", err)
												}
												if b < 0x80 {
													if i == 9 && b > 1 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													return x | uint64(b)<<s, nil
												}
												x |= uint64(b&0x7f) << s
												s += 7
											}
											return x, errors.New("varint overflows a 64-bit integer")
										}(r)
										return (wasi__clocks__monotonic_clock.Duration)(v), err
									}()

									return (wrpc__http__types.Duration)(v), err
								}()

								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, append(path, 1)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `first-byte-timeout` field: %w", err)
						}
						slog.Debug("reading field", "name", "between-bytes-timeout")
						v.BetweenBytesTimeout, err = func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Duration, error) {
							slog.Debug("reading option status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read option status byte: %w", err)
							}
							switch status {
							case 0:
								return nil, nil
							case 1:
								slog.Debug("reading `option::some` payload")
								v, err := func() (wrpc__http__types.Duration, error) {
									v, err := func() (wasi__clocks__monotonic_clock.Duration, error) {
										v, err := func(r io.ByteReader) (uint64, error) {
											var x uint64
											var s uint
											for i := 0; i < 10; i++ {
												slog.Debug("reading u64 byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return x, fmt.Errorf("failed to read u64 byte: %w", err)
												}
												if b < 0x80 {
													if i == 9 && b > 1 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													return x | uint64(b)<<s, nil
												}
												x |= uint64(b&0x7f) << s
												s += 7
											}
											return x, errors.New("varint overflows a 64-bit integer")
										}(r)
										return (wasi__clocks__monotonic_clock.Duration)(v), err
									}()

									return (wrpc__http__types.Duration)(v), err
								}()

								if err != nil {
									return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
								}
								return &v, nil
							default:
								return nil, fmt.Errorf("invalid option status byte %d", status)
							}
						}(r, append(path, 2)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `between-bytes-timeout` field: %w", err)
						}
						return v, nil
					}(r, path...)
					return (*RequestOptions)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1: %w", err)
		}
		slog.DebugContext(ctx, "calling `wrpc:http/outgoing-handler@0.1.0.handle` handler")
		r0, err := h.Handle(ctx, p0, p1)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:http/outgoing-handler@0.1.0.handle` invocation: %w", err)
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0, err := func(v *wrpc.Result[Response, ErrorCode], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (*v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (*v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wrpc:http/outgoing-handler@0.1.0.handle` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			return fmt.Errorf("failed to write result: %w", err)
		}
		if len(writes) > 0 {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}
		return nil
	}, wrpc.NewSubscribePath().Index(0).Index(0), wrpc.NewSubscribePath().Index(0).Index(1))
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:http/outgoing-handler@0.1.0.handle`: %w", err)
	}
	stops = append(stops, stop0)
	return stop, nil
}
