// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package types

import (
	bytes "bytes"
	binary "encoding/binary"
	fmt "fmt"
	wasi__clocks__monotonic_clock "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/clocks/monotonic_clock"
	wasi__http__types "github.com/wrpc/wrpc/examples/go/http-outgoing-server/bindings/wasi/http/types"
	wrpc "github.com/wrpc/wrpc/go"
	errgroup "golang.org/x/sync/errgroup"
	io "io"
	slog "log/slog"
	math "math"
)

type WasiErrorCode = wasi__http__types.ErrorCode
type WasiMethod = wasi__http__types.Method
type WasiScheme = wasi__http__types.Scheme
type Duration = wasi__clocks__monotonic_clock.Duration
type ErrorCode = WasiErrorCode
type Method = WasiMethod
type Scheme = WasiScheme
type Fields = []*wrpc.Tuple2[string, [][]uint8]
type RequestOptions struct {
	ConnectTimeout      *Duration
	FirstByteTimeout    *Duration
	BetweenBytesTimeout *Duration
}

func (v *RequestOptions) String() string { return "RequestOptions" }

func (v *RequestOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 3)
	slog.Debug("writing field", "name", "connect-timeout")
	write0, err := func(v *Duration, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ConnectTimeout, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `connect-timeout` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "first-byte-timeout")
	write1, err := func(v *Duration, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.FirstByteTimeout, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `first-byte-timeout` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "between-bytes-timeout")
	write2, err := func(v *Duration, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.BetweenBytesTimeout, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `between-bytes-timeout` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

type Request struct {
	Body          wrpc.ReadCompleter
	Trailers      wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]]
	Method        *wasi__http__types.Method
	PathWithQuery *string
	Scheme        *Scheme
	Authority     *string
	Headers       []*wrpc.Tuple2[string, [][]uint8]
}

func (v *Request) String() string { return "Request" }

func (v *Request) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 7)
	slog.Debug("writing field", "name", "body")
	write0, err := func(v wrpc.ReadCompleter, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		if v.IsComplete() {
			defer func() {
				body, ok := v.(io.Closer)
				if ok {
					if cErr := body.Close(); cErr != nil {
						if err == nil {
							err = fmt.Errorf("failed to close ready byte stream: %w", cErr)
						} else {
							slog.Warn("failed to close ready byte stream", "err", cErr)
						}
					}
				}
			}()
			slog.Debug("writing byte stream `stream::ready` status byte")
			if err = w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `stream::ready` byte: %w", err)
			}
			slog.Debug("reading ready byte stream contents")
			var buf bytes.Buffer
			var n int64
			n, err = io.Copy(&buf, v)
			if err != nil {
				return nil, fmt.Errorf("failed to read ready byte stream contents: %w", err)
			}
			slog.Debug("writing ready byte stream contents", "len", n)
			if err = wrpc.WriteByteList(buf.Bytes(), w); err != nil {
				return nil, fmt.Errorf("failed to write ready byte stream contents: %w", err)
			}
			return nil, nil
		} else {
			slog.Debug("writing byte stream `stream::pending` status byte")
			if err = w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `stream::pending` byte: %w", err)
			}
			return func(w wrpc.IndexWriter) (err error) {
				defer func() {
					body, ok := v.(io.Closer)
					if ok {
						if cErr := body.Close(); cErr != nil {
							if err == nil {
								err = fmt.Errorf("failed to close pending byte stream: %w", cErr)
							} else {
								slog.Warn("failed to close pending byte stream", "err", cErr)
							}
						}
					}
				}()
				chunk := make([]byte, 8096)
				for {
					var end bool
					slog.Debug("reading pending byte stream contents")
					n, err := v.Read(chunk)
					if err == io.EOF {
						end = true
						slog.Debug("pending byte stream reached EOF")
					} else if err != nil {
						return fmt.Errorf("failed to read pending byte stream chunk: %w", err)
					}
					if n > math.MaxUint32 {
						return fmt.Errorf("pending byte stream chunk length of %d overflows a 32-bit integer", n)
					}
					slog.Debug("writing pending byte stream chunk length", "len", n)
					if err := wrpc.WriteUint32(uint32(n), w); err != nil {
						return fmt.Errorf("failed to write pending byte stream chunk length of %d: %w", n, err)
					}
					_, err = w.Write(chunk[:n])
					if err != nil {
						return fmt.Errorf("failed to write pending byte stream chunk contents: %w", err)
					}
					if end {
						if err := w.WriteByte(0); err != nil {
							return fmt.Errorf("failed to write pending byte stream end byte: %w", err)
						}
						return nil
					}
				}
			}, nil
		}
	}(v.Body, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `body` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "trailers")
	write1, err := func(v wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		if v.IsComplete() {
			defer func() {
				body, ok := v.(io.Closer)
				if ok {
					if cErr := body.Close(); cErr != nil {
						if err == nil {
							err = fmt.Errorf("failed to close ready future: %w", cErr)
						} else {
							slog.Warn("failed to close ready future", "err", cErr)
						}
					}
				}
			}()
			slog.Debug("writing future `future::ready` status byte")
			if err = w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `future::ready` byte: %w", err)
			}
			slog.Debug("receiving ready future contents")
			rx, err := v.Receive()
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("failed to receive ready future contents: %w", err)
			}
			slog.Debug("writing ready future contents")
			write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				if v == nil {
					slog.Debug("writing `option::none` status byte")
					if err := w.WriteByte(0); err != nil {
						return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
					}
					return nil, nil
				}
				slog.Debug("writing `option::some` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
				}
				slog.Debug("writing `option::some` payload")
				write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
							io.ByteWriter
							io.Writer
						}) (func(wrpc.IndexWriter) error, error) {
							writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
							slog.Debug("writing tuple element 0")
							write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
								n := len(v)
								if n > math.MaxUint32 {
									return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
								}
								if err = func(v int, w io.Writer) error {
									b := make([]byte, binary.MaxVarintLen32)
									i := binary.PutUvarint(b, uint64(v))
									slog.Debug("writing string byte length", "len", n)
									_, err = w.Write(b[:i])
									return err
								}(n, w); err != nil {
									return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
								}
								slog.Debug("writing string bytes")
								_, err = w.Write([]byte(v))
								if err != nil {
									return fmt.Errorf("failed to write string bytes: %w", err)
								}
								return nil
							}(v.V0, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
							}
							if write0 != nil {
								writes[0] = write0
							}
							slog.Debug("writing tuple element 1")
							write1, err := func(v [][]uint8, w interface {
								io.ByteWriter
								io.Writer
							}) (write func(wrpc.IndexWriter) error, err error) {
								n := len(v)
								if n > math.MaxUint32 {
									return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
								}
								if err = func(v int, w io.Writer) error {
									b := make([]byte, binary.MaxVarintLen32)
									i := binary.PutUvarint(b, uint64(v))
									slog.Debug("writing list length", "len", n)
									_, err = w.Write(b[:i])
									return err
								}(n, w); err != nil {
									return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
								}
								slog.Debug("writing list elements")
								writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
								for i, e := range v {
									write, err := func(v []uint8, w interface {
										io.ByteWriter
										io.Writer
									}) (write func(wrpc.IndexWriter) error, err error) {
										n := len(v)
										if n > math.MaxUint32 {
											return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
										}
										if err = func(v int, w io.Writer) error {
											b := make([]byte, binary.MaxVarintLen32)
											i := binary.PutUvarint(b, uint64(v))
											slog.Debug("writing list length", "len", n)
											_, err = w.Write(b[:i])
											return err
										}(n, w); err != nil {
											return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
										}
										slog.Debug("writing list elements")
										writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
										for i, e := range v {
											write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
												slog.Debug("writing u8 byte")
												return w.WriteByte(v)
											}(e, w)
											if err != nil {
												return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
											}
											if write != nil {
												writes[uint32(i)] = write
											}
										}
										if len(writes) > 0 {
											return func(w wrpc.IndexWriter) error {
												var wg errgroup.Group
												for index, write := range writes {
													w, err := w.Index(index)
													if err != nil {
														return fmt.Errorf("failed to index writer: %w", err)
													}
													write := write
													wg.Go(func() error {
														return write(w)
													})
												}
												return wg.Wait()
											}, nil
										}
										return nil, nil
									}(e, w)
									if err != nil {
										return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
									}
									if write != nil {
										writes[uint32(i)] = write
									}
								}
								if len(writes) > 0 {
									return func(w wrpc.IndexWriter) error {
										var wg errgroup.Group
										for index, write := range writes {
											w, err := w.Index(index)
											if err != nil {
												return fmt.Errorf("failed to index writer: %w", err)
											}
											write := write
											wg.Go(func() error {
												return write(w)
											})
										}
										return wg.Wait()
									}, nil
								}
								return nil, nil
							}(v.V1, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
							}
							if write1 != nil {
								writes[1] = write1
							}
							if len(writes) > 0 {
								return func(w wrpc.IndexWriter) error {
									var wg errgroup.Group
									for index, write := range writes {
										w, err := w.Index(index)
										if err != nil {
											return fmt.Errorf("failed to index writer: %w", err)
										}
										write := write
										wg.Go(func() error {
											return write(w)
										})
									}
									return wg.Wait()
								}, nil
							}
							return nil, nil
						}(e, w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(v, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
				}
				return write, nil
			}(rx, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write ready future contents: %w", err)
			}
			return write, nil
		} else {
			slog.Debug("writing future `future::pending` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `future::pending` byte: %w", err)
			}
			return func(w wrpc.IndexWriter) (err error) {
				defer func() {
					body, ok := v.(io.Closer)
					if ok {
						if cErr := body.Close(); cErr != nil {
							if err == nil {
								err = fmt.Errorf("failed to close pending future: %w", cErr)
							} else {
								slog.Warn("failed to close pending future", "err", cErr)
							}
						}
					}
				}()
				slog.Debug("receiving outgoing pending future contents")
				rx, err := v.Receive()
				if err != nil {
					return fmt.Errorf("failed to receive outgoing pending future: %w", err)
				}
				slog.Debug("writing pending future element")
				write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (func(wrpc.IndexWriter) error, error) {
					if v == nil {
						slog.Debug("writing `option::none` status byte")
						if err := w.WriteByte(0); err != nil {
							return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
						}
						return nil, nil
					}
					slog.Debug("writing `option::some` status byte")
					if err := w.WriteByte(1); err != nil {
						return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
					}
					slog.Debug("writing `option::some` payload")
					write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
						io.ByteWriter
						io.Writer
					}) (write func(wrpc.IndexWriter) error, err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing list length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
						for i, e := range v {
							write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
								io.ByteWriter
								io.Writer
							}) (func(wrpc.IndexWriter) error, error) {
								writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
								slog.Debug("writing tuple element 0")
								write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
									n := len(v)
									if n > math.MaxUint32 {
										return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
									}
									if err = func(v int, w io.Writer) error {
										b := make([]byte, binary.MaxVarintLen32)
										i := binary.PutUvarint(b, uint64(v))
										slog.Debug("writing string byte length", "len", n)
										_, err = w.Write(b[:i])
										return err
									}(n, w); err != nil {
										return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
									}
									slog.Debug("writing string bytes")
									_, err = w.Write([]byte(v))
									if err != nil {
										return fmt.Errorf("failed to write string bytes: %w", err)
									}
									return nil
								}(v.V0, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
								}
								if write0 != nil {
									writes[0] = write0
								}
								slog.Debug("writing tuple element 1")
								write1, err := func(v [][]uint8, w interface {
									io.ByteWriter
									io.Writer
								}) (write func(wrpc.IndexWriter) error, err error) {
									n := len(v)
									if n > math.MaxUint32 {
										return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
									}
									if err = func(v int, w io.Writer) error {
										b := make([]byte, binary.MaxVarintLen32)
										i := binary.PutUvarint(b, uint64(v))
										slog.Debug("writing list length", "len", n)
										_, err = w.Write(b[:i])
										return err
									}(n, w); err != nil {
										return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
									}
									slog.Debug("writing list elements")
									writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
									for i, e := range v {
										write, err := func(v []uint8, w interface {
											io.ByteWriter
											io.Writer
										}) (write func(wrpc.IndexWriter) error, err error) {
											n := len(v)
											if n > math.MaxUint32 {
												return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
											}
											if err = func(v int, w io.Writer) error {
												b := make([]byte, binary.MaxVarintLen32)
												i := binary.PutUvarint(b, uint64(v))
												slog.Debug("writing list length", "len", n)
												_, err = w.Write(b[:i])
												return err
											}(n, w); err != nil {
												return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
											}
											slog.Debug("writing list elements")
											writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
											for i, e := range v {
												write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
													slog.Debug("writing u8 byte")
													return w.WriteByte(v)
												}(e, w)
												if err != nil {
													return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
												}
												if write != nil {
													writes[uint32(i)] = write
												}
											}
											if len(writes) > 0 {
												return func(w wrpc.IndexWriter) error {
													var wg errgroup.Group
													for index, write := range writes {
														w, err := w.Index(index)
														if err != nil {
															return fmt.Errorf("failed to index writer: %w", err)
														}
														write := write
														wg.Go(func() error {
															return write(w)
														})
													}
													return wg.Wait()
												}, nil
											}
											return nil, nil
										}(e, w)
										if err != nil {
											return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
										}
										if write != nil {
											writes[uint32(i)] = write
										}
									}
									if len(writes) > 0 {
										return func(w wrpc.IndexWriter) error {
											var wg errgroup.Group
											for index, write := range writes {
												w, err := w.Index(index)
												if err != nil {
													return fmt.Errorf("failed to index writer: %w", err)
												}
												write := write
												wg.Go(func() error {
													return write(w)
												})
											}
											return wg.Wait()
										}, nil
									}
									return nil, nil
								}(v.V1, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
								}
								if write1 != nil {
									writes[1] = write1
								}
								if len(writes) > 0 {
									return func(w wrpc.IndexWriter) error {
										var wg errgroup.Group
										for index, write := range writes {
											w, err := w.Index(index)
											if err != nil {
												return fmt.Errorf("failed to index writer: %w", err)
											}
											write := write
											wg.Go(func() error {
												return write(w)
											})
										}
										return wg.Wait()
									}, nil
								}
								return nil, nil
							}(e, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
							}
							if write != nil {
								writes[uint32(i)] = write
							}
						}
						if len(writes) > 0 {
							return func(w wrpc.IndexWriter) error {
								var wg errgroup.Group
								for index, write := range writes {
									w, err := w.Index(index)
									if err != nil {
										return fmt.Errorf("failed to index writer: %w", err)
									}
									write := write
									wg.Go(func() error {
										return write(w)
									})
								}
								return wg.Wait()
							}, nil
						}
						return nil, nil
					}(v, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
					}
					return write, nil
				}(rx, w)
				if err != nil {
					return fmt.Errorf("failed to write pending future element: %w", err)
				}
				if write != nil {
					return write(w)
				}
				return nil
			}, nil
		}
	}(v.Trailers, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `trailers` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "method")
	write2, err := (v.Method).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `method` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "path-with-query")
	write3, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.PathWithQuery, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `path-with-query` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "scheme")
	write4, err := func(v *Scheme, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Scheme, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `scheme` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "authority")
	write5, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Authority, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `authority` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "headers")
	write6, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
				slog.Debug("writing tuple element 0")
				write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V0, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
				}
				if write0 != nil {
					writes[0] = write0
				}
				slog.Debug("writing tuple element 1")
				write1, err := func(v [][]uint8, w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := func(v []uint8, w interface {
							io.ByteWriter
							io.Writer
						}) (write func(wrpc.IndexWriter) error, err error) {
							n := len(v)
							if n > math.MaxUint32 {
								return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
							}
							if err = func(v int, w io.Writer) error {
								b := make([]byte, binary.MaxVarintLen32)
								i := binary.PutUvarint(b, uint64(v))
								slog.Debug("writing list length", "len", n)
								_, err = w.Write(b[:i])
								return err
							}(n, w); err != nil {
								return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
							}
							slog.Debug("writing list elements")
							writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
							for i, e := range v {
								write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
									slog.Debug("writing u8 byte")
									return w.WriteByte(v)
								}(e, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
								}
								if write != nil {
									writes[uint32(i)] = write
								}
							}
							if len(writes) > 0 {
								return func(w wrpc.IndexWriter) error {
									var wg errgroup.Group
									for index, write := range writes {
										w, err := w.Index(index)
										if err != nil {
											return fmt.Errorf("failed to index writer: %w", err)
										}
										write := write
										wg.Go(func() error {
											return write(w)
										})
									}
									return wg.Wait()
								}, nil
							}
							return nil, nil
						}(e, w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(v.V1, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
				}
				if write1 != nil {
					writes[1] = write1
				}
				if len(writes) > 0 {
					return func(w wrpc.IndexWriter) error {
						var wg errgroup.Group
						for index, write := range writes {
							w, err := w.Index(index)
							if err != nil {
								return fmt.Errorf("failed to index writer: %w", err)
							}
							write := write
							wg.Go(func() error {
								return write(w)
							})
						}
						return wg.Wait()
					}, nil
				}
				return nil, nil
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg errgroup.Group
				for index, write := range writes {
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index writer: %w", err)
					}
					write := write
					wg.Go(func() error {
						return write(w)
					})
				}
				return wg.Wait()
			}, nil
		}
		return nil, nil
	}(v.Headers, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `headers` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}

type Response struct {
	Body     wrpc.ReadCompleter
	Trailers wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]]
	Status   uint16
	Headers  []*wrpc.Tuple2[string, [][]uint8]
}

func (v *Response) String() string { return "Response" }

func (v *Response) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "body")
	write0, err := func(v wrpc.ReadCompleter, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		if v.IsComplete() {
			defer func() {
				body, ok := v.(io.Closer)
				if ok {
					if cErr := body.Close(); cErr != nil {
						if err == nil {
							err = fmt.Errorf("failed to close ready byte stream: %w", cErr)
						} else {
							slog.Warn("failed to close ready byte stream", "err", cErr)
						}
					}
				}
			}()
			slog.Debug("writing byte stream `stream::ready` status byte")
			if err = w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `stream::ready` byte: %w", err)
			}
			slog.Debug("reading ready byte stream contents")
			var buf bytes.Buffer
			var n int64
			n, err = io.Copy(&buf, v)
			if err != nil {
				return nil, fmt.Errorf("failed to read ready byte stream contents: %w", err)
			}
			slog.Debug("writing ready byte stream contents", "len", n)
			if err = wrpc.WriteByteList(buf.Bytes(), w); err != nil {
				return nil, fmt.Errorf("failed to write ready byte stream contents: %w", err)
			}
			return nil, nil
		} else {
			slog.Debug("writing byte stream `stream::pending` status byte")
			if err = w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `stream::pending` byte: %w", err)
			}
			return func(w wrpc.IndexWriter) (err error) {
				defer func() {
					body, ok := v.(io.Closer)
					if ok {
						if cErr := body.Close(); cErr != nil {
							if err == nil {
								err = fmt.Errorf("failed to close pending byte stream: %w", cErr)
							} else {
								slog.Warn("failed to close pending byte stream", "err", cErr)
							}
						}
					}
				}()
				chunk := make([]byte, 8096)
				for {
					var end bool
					slog.Debug("reading pending byte stream contents")
					n, err := v.Read(chunk)
					if err == io.EOF {
						end = true
						slog.Debug("pending byte stream reached EOF")
					} else if err != nil {
						return fmt.Errorf("failed to read pending byte stream chunk: %w", err)
					}
					if n > math.MaxUint32 {
						return fmt.Errorf("pending byte stream chunk length of %d overflows a 32-bit integer", n)
					}
					slog.Debug("writing pending byte stream chunk length", "len", n)
					if err := wrpc.WriteUint32(uint32(n), w); err != nil {
						return fmt.Errorf("failed to write pending byte stream chunk length of %d: %w", n, err)
					}
					_, err = w.Write(chunk[:n])
					if err != nil {
						return fmt.Errorf("failed to write pending byte stream chunk contents: %w", err)
					}
					if end {
						if err := w.WriteByte(0); err != nil {
							return fmt.Errorf("failed to write pending byte stream end byte: %w", err)
						}
						return nil
					}
				}
			}, nil
		}
	}(v.Body, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `body` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "trailers")
	write1, err := func(v wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		if v.IsComplete() {
			defer func() {
				body, ok := v.(io.Closer)
				if ok {
					if cErr := body.Close(); cErr != nil {
						if err == nil {
							err = fmt.Errorf("failed to close ready future: %w", cErr)
						} else {
							slog.Warn("failed to close ready future", "err", cErr)
						}
					}
				}
			}()
			slog.Debug("writing future `future::ready` status byte")
			if err = w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `future::ready` byte: %w", err)
			}
			slog.Debug("receiving ready future contents")
			rx, err := v.Receive()
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("failed to receive ready future contents: %w", err)
			}
			slog.Debug("writing ready future contents")
			write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				if v == nil {
					slog.Debug("writing `option::none` status byte")
					if err := w.WriteByte(0); err != nil {
						return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
					}
					return nil, nil
				}
				slog.Debug("writing `option::some` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
				}
				slog.Debug("writing `option::some` payload")
				write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
							io.ByteWriter
							io.Writer
						}) (func(wrpc.IndexWriter) error, error) {
							writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
							slog.Debug("writing tuple element 0")
							write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
								n := len(v)
								if n > math.MaxUint32 {
									return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
								}
								if err = func(v int, w io.Writer) error {
									b := make([]byte, binary.MaxVarintLen32)
									i := binary.PutUvarint(b, uint64(v))
									slog.Debug("writing string byte length", "len", n)
									_, err = w.Write(b[:i])
									return err
								}(n, w); err != nil {
									return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
								}
								slog.Debug("writing string bytes")
								_, err = w.Write([]byte(v))
								if err != nil {
									return fmt.Errorf("failed to write string bytes: %w", err)
								}
								return nil
							}(v.V0, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
							}
							if write0 != nil {
								writes[0] = write0
							}
							slog.Debug("writing tuple element 1")
							write1, err := func(v [][]uint8, w interface {
								io.ByteWriter
								io.Writer
							}) (write func(wrpc.IndexWriter) error, err error) {
								n := len(v)
								if n > math.MaxUint32 {
									return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
								}
								if err = func(v int, w io.Writer) error {
									b := make([]byte, binary.MaxVarintLen32)
									i := binary.PutUvarint(b, uint64(v))
									slog.Debug("writing list length", "len", n)
									_, err = w.Write(b[:i])
									return err
								}(n, w); err != nil {
									return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
								}
								slog.Debug("writing list elements")
								writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
								for i, e := range v {
									write, err := func(v []uint8, w interface {
										io.ByteWriter
										io.Writer
									}) (write func(wrpc.IndexWriter) error, err error) {
										n := len(v)
										if n > math.MaxUint32 {
											return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
										}
										if err = func(v int, w io.Writer) error {
											b := make([]byte, binary.MaxVarintLen32)
											i := binary.PutUvarint(b, uint64(v))
											slog.Debug("writing list length", "len", n)
											_, err = w.Write(b[:i])
											return err
										}(n, w); err != nil {
											return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
										}
										slog.Debug("writing list elements")
										writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
										for i, e := range v {
											write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
												slog.Debug("writing u8 byte")
												return w.WriteByte(v)
											}(e, w)
											if err != nil {
												return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
											}
											if write != nil {
												writes[uint32(i)] = write
											}
										}
										if len(writes) > 0 {
											return func(w wrpc.IndexWriter) error {
												var wg errgroup.Group
												for index, write := range writes {
													w, err := w.Index(index)
													if err != nil {
														return fmt.Errorf("failed to index writer: %w", err)
													}
													write := write
													wg.Go(func() error {
														return write(w)
													})
												}
												return wg.Wait()
											}, nil
										}
										return nil, nil
									}(e, w)
									if err != nil {
										return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
									}
									if write != nil {
										writes[uint32(i)] = write
									}
								}
								if len(writes) > 0 {
									return func(w wrpc.IndexWriter) error {
										var wg errgroup.Group
										for index, write := range writes {
											w, err := w.Index(index)
											if err != nil {
												return fmt.Errorf("failed to index writer: %w", err)
											}
											write := write
											wg.Go(func() error {
												return write(w)
											})
										}
										return wg.Wait()
									}, nil
								}
								return nil, nil
							}(v.V1, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
							}
							if write1 != nil {
								writes[1] = write1
							}
							if len(writes) > 0 {
								return func(w wrpc.IndexWriter) error {
									var wg errgroup.Group
									for index, write := range writes {
										w, err := w.Index(index)
										if err != nil {
											return fmt.Errorf("failed to index writer: %w", err)
										}
										write := write
										wg.Go(func() error {
											return write(w)
										})
									}
									return wg.Wait()
								}, nil
							}
							return nil, nil
						}(e, w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(v, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
				}
				return write, nil
			}(rx, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write ready future contents: %w", err)
			}
			return write, nil
		} else {
			slog.Debug("writing future `future::pending` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `future::pending` byte: %w", err)
			}
			return func(w wrpc.IndexWriter) (err error) {
				defer func() {
					body, ok := v.(io.Closer)
					if ok {
						if cErr := body.Close(); cErr != nil {
							if err == nil {
								err = fmt.Errorf("failed to close pending future: %w", cErr)
							} else {
								slog.Warn("failed to close pending future", "err", cErr)
							}
						}
					}
				}()
				slog.Debug("receiving outgoing pending future contents")
				rx, err := v.Receive()
				if err != nil {
					return fmt.Errorf("failed to receive outgoing pending future: %w", err)
				}
				slog.Debug("writing pending future element")
				write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (func(wrpc.IndexWriter) error, error) {
					if v == nil {
						slog.Debug("writing `option::none` status byte")
						if err := w.WriteByte(0); err != nil {
							return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
						}
						return nil, nil
					}
					slog.Debug("writing `option::some` status byte")
					if err := w.WriteByte(1); err != nil {
						return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
					}
					slog.Debug("writing `option::some` payload")
					write, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
						io.ByteWriter
						io.Writer
					}) (write func(wrpc.IndexWriter) error, err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing list length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
						for i, e := range v {
							write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
								io.ByteWriter
								io.Writer
							}) (func(wrpc.IndexWriter) error, error) {
								writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
								slog.Debug("writing tuple element 0")
								write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
									n := len(v)
									if n > math.MaxUint32 {
										return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
									}
									if err = func(v int, w io.Writer) error {
										b := make([]byte, binary.MaxVarintLen32)
										i := binary.PutUvarint(b, uint64(v))
										slog.Debug("writing string byte length", "len", n)
										_, err = w.Write(b[:i])
										return err
									}(n, w); err != nil {
										return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
									}
									slog.Debug("writing string bytes")
									_, err = w.Write([]byte(v))
									if err != nil {
										return fmt.Errorf("failed to write string bytes: %w", err)
									}
									return nil
								}(v.V0, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
								}
								if write0 != nil {
									writes[0] = write0
								}
								slog.Debug("writing tuple element 1")
								write1, err := func(v [][]uint8, w interface {
									io.ByteWriter
									io.Writer
								}) (write func(wrpc.IndexWriter) error, err error) {
									n := len(v)
									if n > math.MaxUint32 {
										return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
									}
									if err = func(v int, w io.Writer) error {
										b := make([]byte, binary.MaxVarintLen32)
										i := binary.PutUvarint(b, uint64(v))
										slog.Debug("writing list length", "len", n)
										_, err = w.Write(b[:i])
										return err
									}(n, w); err != nil {
										return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
									}
									slog.Debug("writing list elements")
									writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
									for i, e := range v {
										write, err := func(v []uint8, w interface {
											io.ByteWriter
											io.Writer
										}) (write func(wrpc.IndexWriter) error, err error) {
											n := len(v)
											if n > math.MaxUint32 {
												return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
											}
											if err = func(v int, w io.Writer) error {
												b := make([]byte, binary.MaxVarintLen32)
												i := binary.PutUvarint(b, uint64(v))
												slog.Debug("writing list length", "len", n)
												_, err = w.Write(b[:i])
												return err
											}(n, w); err != nil {
												return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
											}
											slog.Debug("writing list elements")
											writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
											for i, e := range v {
												write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
													slog.Debug("writing u8 byte")
													return w.WriteByte(v)
												}(e, w)
												if err != nil {
													return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
												}
												if write != nil {
													writes[uint32(i)] = write
												}
											}
											if len(writes) > 0 {
												return func(w wrpc.IndexWriter) error {
													var wg errgroup.Group
													for index, write := range writes {
														w, err := w.Index(index)
														if err != nil {
															return fmt.Errorf("failed to index writer: %w", err)
														}
														write := write
														wg.Go(func() error {
															return write(w)
														})
													}
													return wg.Wait()
												}, nil
											}
											return nil, nil
										}(e, w)
										if err != nil {
											return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
										}
										if write != nil {
											writes[uint32(i)] = write
										}
									}
									if len(writes) > 0 {
										return func(w wrpc.IndexWriter) error {
											var wg errgroup.Group
											for index, write := range writes {
												w, err := w.Index(index)
												if err != nil {
													return fmt.Errorf("failed to index writer: %w", err)
												}
												write := write
												wg.Go(func() error {
													return write(w)
												})
											}
											return wg.Wait()
										}, nil
									}
									return nil, nil
								}(v.V1, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
								}
								if write1 != nil {
									writes[1] = write1
								}
								if len(writes) > 0 {
									return func(w wrpc.IndexWriter) error {
										var wg errgroup.Group
										for index, write := range writes {
											w, err := w.Index(index)
											if err != nil {
												return fmt.Errorf("failed to index writer: %w", err)
											}
											write := write
											wg.Go(func() error {
												return write(w)
											})
										}
										return wg.Wait()
									}, nil
								}
								return nil, nil
							}(e, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
							}
							if write != nil {
								writes[uint32(i)] = write
							}
						}
						if len(writes) > 0 {
							return func(w wrpc.IndexWriter) error {
								var wg errgroup.Group
								for index, write := range writes {
									w, err := w.Index(index)
									if err != nil {
										return fmt.Errorf("failed to index writer: %w", err)
									}
									write := write
									wg.Go(func() error {
										return write(w)
									})
								}
								return wg.Wait()
							}, nil
						}
						return nil, nil
					}(v, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
					}
					return write, nil
				}(rx, w)
				if err != nil {
					return fmt.Errorf("failed to write pending future element: %w", err)
				}
				if write != nil {
					return write(w)
				}
				return nil
			}, nil
		}
	}(v.Trailers, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `trailers` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "status")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint16, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen16)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u16")
		_, err = w.Write(b[:i])
		return err
	}(v.Status, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `status` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "headers")
	write3, err := func(v []*wrpc.Tuple2[string, [][]uint8], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := func(v *wrpc.Tuple2[string, [][]uint8], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
				slog.Debug("writing tuple element 0")
				write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V0, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
				}
				if write0 != nil {
					writes[0] = write0
				}
				slog.Debug("writing tuple element 1")
				write1, err := func(v [][]uint8, w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := func(v []uint8, w interface {
							io.ByteWriter
							io.Writer
						}) (write func(wrpc.IndexWriter) error, err error) {
							n := len(v)
							if n > math.MaxUint32 {
								return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
							}
							if err = func(v int, w io.Writer) error {
								b := make([]byte, binary.MaxVarintLen32)
								i := binary.PutUvarint(b, uint64(v))
								slog.Debug("writing list length", "len", n)
								_, err = w.Write(b[:i])
								return err
							}(n, w); err != nil {
								return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
							}
							slog.Debug("writing list elements")
							writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
							for i, e := range v {
								write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
									slog.Debug("writing u8 byte")
									return w.WriteByte(v)
								}(e, w)
								if err != nil {
									return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
								}
								if write != nil {
									writes[uint32(i)] = write
								}
							}
							if len(writes) > 0 {
								return func(w wrpc.IndexWriter) error {
									var wg errgroup.Group
									for index, write := range writes {
										w, err := w.Index(index)
										if err != nil {
											return fmt.Errorf("failed to index writer: %w", err)
										}
										write := write
										wg.Go(func() error {
											return write(w)
										})
									}
									return wg.Wait()
								}, nil
							}
							return nil, nil
						}(e, w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg errgroup.Group
							for index, write := range writes {
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								wg.Go(func() error {
									return write(w)
								})
							}
							return wg.Wait()
						}, nil
					}
					return nil, nil
				}(v.V1, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
				}
				if write1 != nil {
					writes[1] = write1
				}
				if len(writes) > 0 {
					return func(w wrpc.IndexWriter) error {
						var wg errgroup.Group
						for index, write := range writes {
							w, err := w.Index(index)
							if err != nil {
								return fmt.Errorf("failed to index writer: %w", err)
							}
							write := write
							wg.Go(func() error {
								return write(w)
							})
						}
						return wg.Wait()
					}, nil
				}
				return nil, nil
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg errgroup.Group
				for index, write := range writes {
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index writer: %w", err)
					}
					write := write
					wg.Go(func() error {
						return write(w)
					})
				}
				return wg.Wait()
			}, nil
		}
		return nil, nil
	}(v.Headers, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `headers` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg errgroup.Group
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				wg.Go(func() error {
					return write(w)
				})
			}
			return wg.Wait()
		}, nil
	}
	return nil, nil
}
