// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package store

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

// The set of errors which may be raised by functions in this package
type Error struct {
	payload      any
	discriminant ErrorDiscriminant
}

func (v *Error) Discriminant() ErrorDiscriminant { return v.discriminant }

type ErrorDiscriminant uint8

const (
	// The host does not recognize the store identifier requested.
	ErrorNoSuchStore ErrorDiscriminant = 0
	// The requesting component does not have access to the specified store
	// (which may or may not exist).
	ErrorAccessDenied ErrorDiscriminant = 1
	// Some implementation-specific error has occurred (e.g. I/O)
	ErrorOther ErrorDiscriminant = 2
)

func (v *Error) String() string {
	switch v.discriminant {
	case ErrorNoSuchStore:
		return "no-such-store"
	case ErrorAccessDenied:
		return "access-denied"
	case ErrorOther:
		return "other"
	default:
		panic("invalid variant")
	}
}

// The host does not recognize the store identifier requested.
func (v *Error) GetNoSuchStore() (ok bool) {
	if ok = (v.discriminant == ErrorNoSuchStore); !ok {
		return
	}
	return
}

// The host does not recognize the store identifier requested.
func (v *Error) SetNoSuchStore() *Error {
	v.discriminant = ErrorNoSuchStore
	v.payload = nil
	return v
}

// The host does not recognize the store identifier requested.
func NewErrorNoSuchStore() *Error {
	return (&Error{}).SetNoSuchStore()
}

// The requesting component does not have access to the specified store
// (which may or may not exist).
func (v *Error) GetAccessDenied() (ok bool) {
	if ok = (v.discriminant == ErrorAccessDenied); !ok {
		return
	}
	return
}

// The requesting component does not have access to the specified store
// (which may or may not exist).
func (v *Error) SetAccessDenied() *Error {
	v.discriminant = ErrorAccessDenied
	v.payload = nil
	return v
}

// The requesting component does not have access to the specified store
// (which may or may not exist).
func NewErrorAccessDenied() *Error {
	return (&Error{}).SetAccessDenied()
}

// Some implementation-specific error has occurred (e.g. I/O)
func (v *Error) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorOther); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Some implementation-specific error has occurred (e.g. I/O)
func (v *Error) SetOther(payload string) *Error {
	v.discriminant = ErrorOther
	v.payload = payload
	return v
}

// Some implementation-specific error has occurred (e.g. I/O)
func NewErrorOther(payload string) *Error {
	return (&Error{}).SetOther(
		payload)
}
func (v *Error) Error() string { return v.String() }
func (v *Error) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorNoSuchStore:
	case ErrorAccessDenied:
	case ErrorOther:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(2)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// A response to a `list-keys` operation.
type KeyResponse struct {
	// The list of keys returned by the query.
	Keys []string
	// The continuation token to use to fetch the next page of keys. If this is `null`, then
	// there are no more keys to fetch.
	Cursor *string
}

func (v *KeyResponse) String() string { return "KeyResponse" }

func (v *KeyResponse) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "keys")
	write0, err := func(v []string, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				if err = func(v int, w io.Writer) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing string byte length", "len", n)
					_, err = w.Write(b[:i])
					return err
				}(n, w); err != nil {
					return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err = w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index nested list writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(v.Keys, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `keys` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "cursor")
	write1, err := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Cursor, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cursor` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
// bucket, and the bucket itself acts as a collection of all these entries.
//
// It is worth noting that the exact terminology for bucket in key-value stores can very
// depending on the specific implementation. For example:
//
// 1. Amazon DynamoDB calls a collection of key-value pairs a table
// 2. Redis has hashes, sets, and sorted sets as different types of collections
// 3. Cassandra calls a collection of key-value pairs a column family
// 4. MongoDB calls a collection of key-value pairs a collection
// 5. Riak calls a collection of key-value pairs a bucket
// 6. Memcached calls a collection of key-value pairs a slab
// 7. Azure Cosmos DB calls a collection of key-value pairs a container
//
// In this interface, we use the term `bucket` to refer to a collection of key-value pairs
type Bucket interface{}

// Get the bucket with the specified identifier.
//
// `identifier` must refer to a bucket provided by the host.
//
// `error::no-such-store` will be raised if the `identifier` is not recognized.
func Open(ctx__ context.Context, wrpc__ wrpc.Invoker, identifier string) (r0__ *wrpc.Result[wrpc.Own[Bucket], Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(identifier, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `identifier` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `identifier` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "open", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `open`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "open", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "open", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[wrpc.Own[Bucket], Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (wrpc.Own[Bucket], error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading owned resource handle length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read owned resource handle length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("owned resource handle length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading owned resource handle bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read owned resource handle bytes: %w", err)
						}
						return wrpc.Own[Bucket](buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("owned resource handle length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[wrpc.Own[Bucket], Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[wrpc.Own[Bucket], Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Get the value associated with the specified `key`
//
// The value is returned as an option. If the key-value pair exists in the
// store, it returns `Ok(value)`. If the key does not exist in the
// store, it returns `Ok(none)`.
//
// If any other error occurs, it returns an `Err(error)`.
func Bucket_Get(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Bucket], key string) (r0__ *wrpc.Result[[]uint8, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(key, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `key` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `key` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "bucket.get", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]bucket.get`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.get", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.get", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[[]uint8, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) ([]uint8, error) {
				slog.Debug("reading option status byte")
				status, err := r.ReadByte()
				if err != nil {
					return nil, fmt.Errorf("failed to read option status byte: %w", err)
				}
				switch status {
				case 0:
					return nil, nil
				case 1:
					slog.Debug("reading `option::some` payload")
					v, err := func(r interface {
						io.ByteReader
						io.Reader
					}) ([]byte, error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading byte list length", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								buf := make([]byte, x)
								slog.Debug("reading byte list contents", "len", x)
								_, err = io.ReadFull(r, buf)
								if err != nil {
									return nil, fmt.Errorf("failed to read byte list contents: %w", err)
								}
								return buf, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("byte length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
					}
					return v, nil
				default:
					return nil, fmt.Errorf("invalid option status byte %d", status)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[[]uint8, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[[]uint8, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Set the value associated with the key in the store. If the key already
// exists in the store, it overwrites the value.
//
// If the key does not exist in the store, it creates a new key-value pair.
//
// If any other error occurs, it returns an `Err(error)`.
func Bucket_Set(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Bucket], key string, value []uint8) (r0__ *wrpc.Result[struct{}, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(key, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `key` parameter: %w", err__)
		return
	}
	write2__, err__ := func(v []uint8, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
				slog.Debug("writing u8 byte")
				return w.WriteByte(v)
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index nested list writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(value, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `value` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `key` parameter")
		return
	}
	if write2__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `value` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "bucket.set", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]bucket.set`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.set", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.set", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			var v struct{}
			return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[struct{}, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Delete the key-value pair associated with the key in the store.
//
// If the key does not exist in the store, it does nothing.
//
// If any other error occurs, it returns an `Err(error)`.
func Bucket_Delete(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Bucket], key string) (r0__ *wrpc.Result[struct{}, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(key, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `key` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `key` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "bucket.delete", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]bucket.delete`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.delete", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.delete", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			var v struct{}
			return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[struct{}, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Check if the key exists in the store.
//
// If the key exists in the store, it returns `Ok(true)`. If the key does
// not exist in the store, it returns `Ok(false)`.
//
// If any other error occurs, it returns an `Err(error)`.
func Bucket_Exists(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Bucket], key string) (r0__ *wrpc.Result[bool, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(key, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `key` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `key` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "bucket.exists", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]bucket.exists`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.exists", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.exists", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[bool, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r io.ByteReader) (bool, error) {
				slog.Debug("reading bool byte")
				v, err := r.ReadByte()
				if err != nil {
					slog.Debug("reading bool", "value", false)
					return false, fmt.Errorf("failed to read bool byte: %w", err)
				}
				switch v {
				case 0:
					return false, nil
				case 1:
					return true, nil
				default:
					return false, fmt.Errorf("invalid bool value %d", v)
				}
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[bool, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[bool, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Get all the keys in the store with an optional cursor (for use in pagination). It
// returns a list of keys. Please note that for most KeyValue implementations, this is a
// can be a very expensive operation and so it should be used judiciously. Implementations
// can return any number of keys in a single response, but they should never attempt to
// send more data than is reasonable (i.e. on a small edge device, this may only be a few
// KB, while on a large machine this could be several MB). Any response should also return
// a cursor that can be used to fetch the next page of keys. See the `key-response` record
// for more information.
//
// Note that the keys are not guaranteed to be returned in any particular order.
//
// If the store is empty, it returns an empty list.
//
// MAY show an out-of-date list of keys if there are concurrent writes to the store.
//
// If any error occurs, it returns an `Err(error)`.
func Bucket_ListKeys(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Bucket], cursor *string) (r0__ *wrpc.Result[KeyResponse, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	write1__, err__ := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(cursor, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `cursor` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `cursor` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:keyvalue/store@0.2.0-draft2", "bucket.list-keys", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]bucket.list-keys`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.list-keys", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:keyvalue/store@0.2.0-draft2", "name", "[method]bucket.list-keys", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[KeyResponse, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*KeyResponse, error) {
				v := &KeyResponse{}
				var err error
				slog.Debug("reading field", "name", "keys")
				v.Keys, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]string, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading list length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read list length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return nil, errors.New("list length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return nil, nil
							}
							vs := make([]string, x)
							for i := range vs {
								slog.Debug("reading list element", "i", i)
								vs[i], err = func(r interface {
									io.ByteReader
									io.Reader
								}) (string, error) {
									var x uint32
									var s uint8
									for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if s == 28 && b > 0x0f {
											return "", errors.New("string length overflows a 32-bit integer")
										}
										if b < 0x80 {
											x = x | uint32(b)<<s
											if x == 0 {
												return "", nil
											}
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}
									return "", errors.New("string length overflows a 32-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
								}
							}
							return vs, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("list length overflows a 32-bit integer")
				}(r, append(path, 0)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `keys` field: %w", err)
				}
				slog.Debug("reading field", "name", "cursor")
				v.Cursor, err = func(r wrpc.IndexReadCloser, path ...uint32) (*string, error) {
					slog.Debug("reading option status byte")
					status, err := r.ReadByte()
					if err != nil {
						return nil, fmt.Errorf("failed to read option status byte: %w", err)
					}
					switch status {
					case 0:
						return nil, nil
					case 1:
						slog.Debug("reading `option::some` payload")
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
						}
						return &v, nil
					default:
						return nil, fmt.Errorf("invalid option status byte %d", status)
					}
				}(r, append(path, 1)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `cursor` field: %w", err)
				}
				return v, nil
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[KeyResponse, Error]{Ok: v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*Error, error) {
				v := &Error{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch ErrorDiscriminant(n) {
				case ErrorNoSuchStore:
					return v.SetNoSuchStore(), nil
				case ErrorAccessDenied:
					return v.SetAccessDenied(), nil
				case ErrorOther:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `other` payload: %w", err)
					}
					return v.SetOther(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[KeyResponse, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
