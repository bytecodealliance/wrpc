// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package outgoing_handler

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	wasi__http__types "github.com/wrpc/wrpc/examples/go/http-outgoing-client/bindings/wasi/http/types"
	wrpc__http__types "github.com/wrpc/wrpc/examples/go/http-outgoing-client/bindings/wrpc/http/types"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	utf8 "unicode/utf8"
)

type Request = wrpc__http__types.Request
type Response = wrpc__http__types.Response
type ErrorCode = wrpc__http__types.ErrorCode
type RequestOptions = wrpc__http__types.RequestOptions

func Handle(ctx__ context.Context, wrpc__ wrpc.Client, request *wrpc__http__types.Request, options *RequestOptions) (r0__ *wrpc.Result[Response, ErrorCode], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wrpc:http/outgoing-handler@0.1.0", "handle", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (request).WriteToIndex(&buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `request` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v *RequestOptions, w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
			if v == nil {
				slog.Debug("writing `option::none` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
				}
				return nil, nil
			}
			slog.Debug("writing `option::some` status byte")
			if err := w.WriteByte(1); err != nil {
				return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
			}
			slog.Debug("writing `option::some` payload")
			write, err := (*v).WriteToIndex(w)
			if err != nil {
				return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
			}
			return write, nil
		}(options, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `options` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[Response, ErrorCode], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func() (*Response, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__http__types.Response, error) {
						v := &wrpc__http__types.Response{}
						var err error
						slog.Debug("reading field", "name", "body")
						v.Body, err = func(r wrpc.IndexReader, path ...uint32) (wrpc.ReadCompleter, error) {
							slog.Debug("reading byte stream status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read byte stream status byte: %w", err)
							}
							switch status {
							case 0:
								if len(path) > 0 {
									r, err = r.Index(path...)
									if err != nil {
										return nil, fmt.Errorf("failed to index reader: %w", err)
									}
								}
								return wrpc.NewByteStreamReader(wrpc.NewPendingByteReader(r)), nil
							case 1:
								slog.Debug("reading ready byte stream contents")
								buf, err :=
									func(r interface {
										io.ByteReader
										io.Reader
									}) ([]byte, error) {
										var x uint32
										var s uint
										for i := 0; i < 5; i++ {
											slog.Debug("reading byte list length", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
											}
											if b < 0x80 {
												if i == 4 && b > 1 {
													return nil, errors.New("byte list length overflows a 32-bit integer")
												}
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading byte list contents", "len", x)
												_, err = io.ReadFull(r, buf)
												if err != nil {
													return nil, fmt.Errorf("failed to read byte list contents: %w", err)
												}
												return buf, nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return nil, errors.New("byte length overflows a 32-bit integer")
									}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read ready byte stream contents: %w", err)
								}
								slog.Debug("read ready byte stream contents", "len", len(buf))
								return wrpc.NewCompleteReader(bytes.NewReader(buf)), nil
							default:
								return nil, fmt.Errorf("invalid stream status byte %d", status)
							}
						}(r, append(path, 0)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `body` field: %w", err)
						}
						slog.Debug("reading field", "name", "trailers")
						v.Trailers, err = func(r wrpc.IndexReader, path ...uint32) (wrpc.ReceiveCompleter[[]*wrpc.Tuple2[string, [][]uint8]], error) {
							slog.Debug("reading future status byte")
							status, err := r.ReadByte()
							if err != nil {
								return nil, fmt.Errorf("failed to read future status byte: %w", err)
							}
							switch status {
							case 0:
								if len(path) > 0 {
									r, err = r.Index(path...)
									if err != nil {
										return nil, fmt.Errorf("failed to index reader: %w", err)
									}
								}
								return wrpc.NewDecodeReceiver(r, func(r wrpc.IndexReader) ([]*wrpc.Tuple2[string, [][]uint8], error) {
									slog.Debug("reading pending future element")
									v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading list length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return nil, fmt.Errorf("failed to read list length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return nil, errors.New("list length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
														for i := range vs {
															slog.Debug("reading list element", "i", i)
															vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
																v := &wrpc.Tuple2[string, [][]uint8]{}
																var err error
																slog.Debug("reading tuple element 0")
																v.V0, err = func(r interface {
																	io.ByteReader
																	io.Reader
																}) (string, error) {
																	var x uint32
																	var s uint
																	for i := 0; i < 5; i++ {
																		slog.Debug("reading string length byte", "i", i)
																		b, err := r.ReadByte()
																		if err != nil {
																			if i > 0 && err == io.EOF {
																				err = io.ErrUnexpectedEOF
																			}
																			return "", fmt.Errorf("failed to read string length byte: %w", err)
																		}
																		if b < 0x80 {
																			if i == 4 && b > 1 {
																				return "", errors.New("string length overflows a 32-bit integer")
																			}
																			x = x | uint32(b)<<s
																			buf := make([]byte, x)
																			slog.Debug("reading string bytes", "len", x)
																			_, err = r.Read(buf)
																			if err != nil {
																				return "", fmt.Errorf("failed to read string bytes: %w", err)
																			}
																			if !utf8.Valid(buf) {
																				return string(buf), errors.New("string is not valid UTF-8")
																			}
																			return string(buf), nil
																		}
																		x |= uint32(b&0x7f) << s
																		s += 7
																	}
																	return "", errors.New("string length overflows a 32-bit integer")
																}(r)
																if err != nil {
																	return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
																}
																slog.Debug("reading tuple element 1")
																v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
																	var x uint32
																	var s uint
																	for i := 0; i < 5; i++ {
																		slog.Debug("reading list length byte", "i", i)
																		b, err := r.ReadByte()
																		if err != nil {
																			if i > 0 && err == io.EOF {
																				err = io.ErrUnexpectedEOF
																			}
																			return nil, fmt.Errorf("failed to read list length byte: %w", err)
																		}
																		if b < 0x80 {
																			if i == 4 && b > 1 {
																				return nil, errors.New("list length overflows a 32-bit integer")
																			}
																			x = x | uint32(b)<<s
																			vs := make([][]uint8, x)
																			for i := range vs {
																				slog.Debug("reading list element", "i", i)
																				vs[i], err = func(r interface {
																					io.ByteReader
																					io.Reader
																				}) ([]byte, error) {
																					var x uint32
																					var s uint
																					for i := 0; i < 5; i++ {
																						slog.Debug("reading byte list length", "i", i)
																						b, err := r.ReadByte()
																						if err != nil {
																							if i > 0 && err == io.EOF {
																								err = io.ErrUnexpectedEOF
																							}
																							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
																						}
																						if b < 0x80 {
																							if i == 4 && b > 1 {
																								return nil, errors.New("byte list length overflows a 32-bit integer")
																							}
																							x = x | uint32(b)<<s
																							buf := make([]byte, x)
																							slog.Debug("reading byte list contents", "len", x)
																							_, err = io.ReadFull(r, buf)
																							if err != nil {
																								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																							}
																							return buf, nil
																						}
																						x |= uint32(b&0x7f) << s
																						s += 7
																					}
																					return nil, errors.New("byte length overflows a 32-bit integer")
																				}(r)
																				if err != nil {
																					return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
																				}
																			}
																			return vs, nil
																		}
																		x |= uint32(b&0x7f) << s
																		s += 7
																	}
																	return nil, errors.New("list length overflows a 32-bit integer")
																}(r, append(path, 1)...)
																if err != nil {
																	return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
																}
																return v, nil
															}(r, append(path, uint32(i))...)
															if err != nil {
																return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
															}
														}
														return vs, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return nil, errors.New("list length overflows a 32-bit integer")
											}(r, path...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read pending future element: %w", err)
									}
									return v, nil
								}), nil
							case 1:
								slog.Debug("reading ready future contents")
								v, err :=
									func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading list length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return nil, fmt.Errorf("failed to read list length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return nil, errors.New("list length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
														for i := range vs {
															slog.Debug("reading list element", "i", i)
															vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
																v := &wrpc.Tuple2[string, [][]uint8]{}
																var err error
																slog.Debug("reading tuple element 0")
																v.V0, err = func(r interface {
																	io.ByteReader
																	io.Reader
																}) (string, error) {
																	var x uint32
																	var s uint
																	for i := 0; i < 5; i++ {
																		slog.Debug("reading string length byte", "i", i)
																		b, err := r.ReadByte()
																		if err != nil {
																			if i > 0 && err == io.EOF {
																				err = io.ErrUnexpectedEOF
																			}
																			return "", fmt.Errorf("failed to read string length byte: %w", err)
																		}
																		if b < 0x80 {
																			if i == 4 && b > 1 {
																				return "", errors.New("string length overflows a 32-bit integer")
																			}
																			x = x | uint32(b)<<s
																			buf := make([]byte, x)
																			slog.Debug("reading string bytes", "len", x)
																			_, err = r.Read(buf)
																			if err != nil {
																				return "", fmt.Errorf("failed to read string bytes: %w", err)
																			}
																			if !utf8.Valid(buf) {
																				return string(buf), errors.New("string is not valid UTF-8")
																			}
																			return string(buf), nil
																		}
																		x |= uint32(b&0x7f) << s
																		s += 7
																	}
																	return "", errors.New("string length overflows a 32-bit integer")
																}(r)
																if err != nil {
																	return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
																}
																slog.Debug("reading tuple element 1")
																v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
																	var x uint32
																	var s uint
																	for i := 0; i < 5; i++ {
																		slog.Debug("reading list length byte", "i", i)
																		b, err := r.ReadByte()
																		if err != nil {
																			if i > 0 && err == io.EOF {
																				err = io.ErrUnexpectedEOF
																			}
																			return nil, fmt.Errorf("failed to read list length byte: %w", err)
																		}
																		if b < 0x80 {
																			if i == 4 && b > 1 {
																				return nil, errors.New("list length overflows a 32-bit integer")
																			}
																			x = x | uint32(b)<<s
																			vs := make([][]uint8, x)
																			for i := range vs {
																				slog.Debug("reading list element", "i", i)
																				vs[i], err = func(r interface {
																					io.ByteReader
																					io.Reader
																				}) ([]byte, error) {
																					var x uint32
																					var s uint
																					for i := 0; i < 5; i++ {
																						slog.Debug("reading byte list length", "i", i)
																						b, err := r.ReadByte()
																						if err != nil {
																							if i > 0 && err == io.EOF {
																								err = io.ErrUnexpectedEOF
																							}
																							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
																						}
																						if b < 0x80 {
																							if i == 4 && b > 1 {
																								return nil, errors.New("byte list length overflows a 32-bit integer")
																							}
																							x = x | uint32(b)<<s
																							buf := make([]byte, x)
																							slog.Debug("reading byte list contents", "len", x)
																							_, err = io.ReadFull(r, buf)
																							if err != nil {
																								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																							}
																							return buf, nil
																						}
																						x |= uint32(b&0x7f) << s
																						s += 7
																					}
																					return nil, errors.New("byte length overflows a 32-bit integer")
																				}(r)
																				if err != nil {
																					return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
																				}
																			}
																			return vs, nil
																		}
																		x |= uint32(b&0x7f) << s
																		s += 7
																	}
																	return nil, errors.New("list length overflows a 32-bit integer")
																}(r, append(path, 1)...)
																if err != nil {
																	return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
																}
																return v, nil
															}(r, append(path, uint32(i))...)
															if err != nil {
																return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
															}
														}
														return vs, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return nil, errors.New("list length overflows a 32-bit integer")
											}(r, path...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
								if err != nil {
									return nil, fmt.Errorf("failed to read ready future contents: %w", err)
								}
								return wrpc.NewCompleteReceiver(v), nil
							default:
								return nil, fmt.Errorf("invalid future status byte %d", status)
							}
						}(r, append(path, 1)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `trailers` field: %w", err)
						}
						slog.Debug("reading field", "name", "status")
						v.Status, err = func(r io.ByteReader) (uint16, error) {
							var x uint16
							var s uint
							for i := 0; i < 3; i++ {
								slog.Debug("reading u16 byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u16 byte: %w", err)
								}
								if b < 0x80 {
									if i == 2 && b > 1 {
										return x, errors.New("varint overflows a 16-bit integer")
									}
									return x | uint16(b)<<s, nil
								}
								x |= uint16(b&0x7f) << s
								s += 7
							}
							return x, errors.New("varint overflows a 16-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `status` field: %w", err)
						}
						slog.Debug("reading field", "name", "headers")
						v.Headers, err = func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, [][]uint8], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading list length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return nil, fmt.Errorf("failed to read list length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return nil, errors.New("list length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									vs := make([]*wrpc.Tuple2[string, [][]uint8], x)
									for i := range vs {
										slog.Debug("reading list element", "i", i)
										vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, [][]uint8], error) {
											v := &wrpc.Tuple2[string, [][]uint8]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r wrpc.IndexReader, path ...uint32) ([][]uint8, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading list length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return nil, fmt.Errorf("failed to read list length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return nil, errors.New("list length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														vs := make([][]uint8, x)
														for i := range vs {
															slog.Debug("reading list element", "i", i)
															vs[i], err = func(r interface {
																io.ByteReader
																io.Reader
															}) ([]byte, error) {
																var x uint32
																var s uint
																for i := 0; i < 5; i++ {
																	slog.Debug("reading byte list length", "i", i)
																	b, err := r.ReadByte()
																	if err != nil {
																		if i > 0 && err == io.EOF {
																			err = io.ErrUnexpectedEOF
																		}
																		return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
																	}
																	if b < 0x80 {
																		if i == 4 && b > 1 {
																			return nil, errors.New("byte list length overflows a 32-bit integer")
																		}
																		x = x | uint32(b)<<s
																		buf := make([]byte, x)
																		slog.Debug("reading byte list contents", "len", x)
																		_, err = io.ReadFull(r, buf)
																		if err != nil {
																			return nil, fmt.Errorf("failed to read byte list contents: %w", err)
																		}
																		return buf, nil
																	}
																	x |= uint32(b&0x7f) << s
																	s += 7
																}
																return nil, errors.New("byte length overflows a 32-bit integer")
															}(r)
															if err != nil {
																return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
															}
														}
														return vs, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return nil, errors.New("list length overflows a 32-bit integer")
											}(r, append(path, 1)...)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, append(path, uint32(i))...)
										if err != nil {
											return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
										}
									}
									return vs, nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return nil, errors.New("list length overflows a 32-bit integer")
						}(r, append(path, 3)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `headers` field: %w", err)
						}
						return v, nil
					}(r, path...)
					return (*Response)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[Response, ErrorCode]{Ok: v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (*ErrorCode, error) {
					v, err := func() (*wrpc__http__types.ErrorCode, error) {
						v, err := func() (*wrpc__http__types.WasiErrorCode, error) {
							v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.ErrorCode, error) {
								v := &wasi__http__types.ErrorCode{}
								n, err := func(r io.ByteReader) (uint8, error) {
									var x uint8
									var s uint
									for i := 0; i < 2; i++ {
										slog.Debug("reading u8 discriminant byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
										}
										if b < 0x80 {
											if i == 2 && b > 1 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											return x | uint8(b)<<s, nil
										}
										x |= uint8(b&0x7f) << s
										s += 7
									}
									return x, errors.New("discriminant overflows an 8-bit integer")
								}(r)
								if err != nil {
									return nil, fmt.Errorf("failed to read discriminant: %w", err)
								}
								switch wasi__http__types.ErrorCodeDiscriminant(n) {
								case wasi__http__types.ErrorCodeDiscriminant_DnsTimeout:
									return v.SetDnsTimeout(), nil
								case wasi__http__types.ErrorCodeDiscriminant_DnsError:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.DnsErrorPayload, error) {
										v := &wasi__http__types.DnsErrorPayload{}
										var err error
										slog.Debug("reading field", "name", "rcode")
										v.Rcode, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 0)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `rcode` field: %w", err)
										}
										slog.Debug("reading field", "name", "info-code")
										v.InfoCode, err = func(r wrpc.IndexReader, path ...uint32) (*uint16, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint16, error) {
													var x uint16
													var s uint
													for i := 0; i < 3; i++ {
														slog.Debug("reading u16 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u16 byte: %w", err)
														}
														if b < 0x80 {
															if i == 2 && b > 1 {
																return x, errors.New("varint overflows a 16-bit integer")
															}
															return x | uint16(b)<<s, nil
														}
														x |= uint16(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 16-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 1)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `info-code` field: %w", err)
										}
										return v, nil
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `DNS-error` payload: %w", err)
									}
									return v.SetDnsError(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_DestinationNotFound:
									return v.SetDestinationNotFound(), nil
								case wasi__http__types.ErrorCodeDiscriminant_DestinationUnavailable:
									return v.SetDestinationUnavailable(), nil
								case wasi__http__types.ErrorCodeDiscriminant_DestinationIpProhibited:
									return v.SetDestinationIpProhibited(), nil
								case wasi__http__types.ErrorCodeDiscriminant_DestinationIpUnroutable:
									return v.SetDestinationIpUnroutable(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionRefused:
									return v.SetConnectionRefused(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionTerminated:
									return v.SetConnectionTerminated(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionTimeout:
									return v.SetConnectionTimeout(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionReadTimeout:
									return v.SetConnectionReadTimeout(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionWriteTimeout:
									return v.SetConnectionWriteTimeout(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConnectionLimitReached:
									return v.SetConnectionLimitReached(), nil
								case wasi__http__types.ErrorCodeDiscriminant_TlsProtocolError:
									return v.SetTlsProtocolError(), nil
								case wasi__http__types.ErrorCodeDiscriminant_TlsCertificateError:
									return v.SetTlsCertificateError(), nil
								case wasi__http__types.ErrorCodeDiscriminant_TlsAlertReceived:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.TlsAlertReceivedPayload, error) {
										v := &wasi__http__types.TlsAlertReceivedPayload{}
										var err error
										slog.Debug("reading field", "name", "alert-id")
										v.AlertId, err = func(r wrpc.IndexReader, path ...uint32) (*uint8, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint8, error) {
													slog.Debug("reading u8 byte")
													v, err := r.ReadByte()
													if err != nil {
														return 0, fmt.Errorf("failed to read u8 byte: %w", err)
													}
													return v, nil
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 0)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `alert-id` field: %w", err)
										}
										slog.Debug("reading field", "name", "alert-message")
										v.AlertMessage, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 1)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `alert-message` field: %w", err)
										}
										return v, nil
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `TLS-alert-received` payload: %w", err)
									}
									return v.SetTlsAlertReceived(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestDenied:
									return v.SetHttpRequestDenied(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestLengthRequired:
									return v.SetHttpRequestLengthRequired(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestBodySize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if b < 0x80 {
														if i == 9 && b > 1 {
															return x, errors.New("varint overflows a 64-bit integer")
														}
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-request-body-size` payload: %w", err)
									}
									return v.SetHttpRequestBodySize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestMethodInvalid:
									return v.SetHttpRequestMethodInvalid(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestUriInvalid:
									return v.SetHttpRequestUriInvalid(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestUriTooLong:
									return v.SetHttpRequestUriTooLong(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestHeaderSectionSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-request-header-section-size` payload: %w", err)
									}
									return v.SetHttpRequestHeaderSectionSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestHeaderSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.FieldSizePayload, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.FieldSizePayload, error) {
												v := &wasi__http__types.FieldSizePayload{}
												var err error
												slog.Debug("reading field", "name", "field-name")
												v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
													slog.Debug("reading option status byte")
													status, err := r.ReadByte()
													if err != nil {
														return nil, fmt.Errorf("failed to read option status byte: %w", err)
													}
													switch status {
													case 0:
														return nil, nil
													case 1:
														slog.Debug("reading `option::some` payload")
														v, err := func(r interface {
															io.ByteReader
															io.Reader
														}) (string, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading string length byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return "", fmt.Errorf("failed to read string length byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return "", errors.New("string length overflows a 32-bit integer")
																	}
																	x = x | uint32(b)<<s
																	buf := make([]byte, x)
																	slog.Debug("reading string bytes", "len", x)
																	_, err = r.Read(buf)
																	if err != nil {
																		return "", fmt.Errorf("failed to read string bytes: %w", err)
																	}
																	if !utf8.Valid(buf) {
																		return string(buf), errors.New("string is not valid UTF-8")
																	}
																	return string(buf), nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return "", errors.New("string length overflows a 32-bit integer")
														}(r)
														if err != nil {
															return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
														}
														return &v, nil
													default:
														return nil, fmt.Errorf("invalid option status byte %d", status)
													}
												}(r, append(path, 0)...)
												if err != nil {
													return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
												}
												slog.Debug("reading field", "name", "field-size")
												v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
													slog.Debug("reading option status byte")
													status, err := r.ReadByte()
													if err != nil {
														return nil, fmt.Errorf("failed to read option status byte: %w", err)
													}
													switch status {
													case 0:
														return nil, nil
													case 1:
														slog.Debug("reading `option::some` payload")
														v, err := func(r io.ByteReader) (uint32, error) {
															var x uint32
															var s uint
															for i := 0; i < 5; i++ {
																slog.Debug("reading u32 byte", "i", i)
																b, err := r.ReadByte()
																if err != nil {
																	if i > 0 && err == io.EOF {
																		err = io.ErrUnexpectedEOF
																	}
																	return x, fmt.Errorf("failed to read u32 byte: %w", err)
																}
																if b < 0x80 {
																	if i == 4 && b > 1 {
																		return x, errors.New("varint overflows a 32-bit integer")
																	}
																	return x | uint32(b)<<s, nil
																}
																x |= uint32(b&0x7f) << s
																s += 7
															}
															return x, errors.New("varint overflows a 32-bit integer")
														}(r)
														if err != nil {
															return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
														}
														return &v, nil
													default:
														return nil, fmt.Errorf("invalid option status byte %d", status)
													}
												}(r, append(path, 1)...)
												if err != nil {
													return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
												}
												return v, nil
											}(r, path...)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-request-header-size` payload: %w", err)
									}
									return v.SetHttpRequestHeaderSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestTrailerSectionSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-request-trailer-section-size` payload: %w", err)
									}
									return v.SetHttpRequestTrailerSectionSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpRequestTrailerSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.FieldSizePayload, error) {
										v := &wasi__http__types.FieldSizePayload{}
										var err error
										slog.Debug("reading field", "name", "field-name")
										v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 0)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
										}
										slog.Debug("reading field", "name", "field-size")
										v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 1)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
										}
										return v, nil
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-request-trailer-size` payload: %w", err)
									}
									return v.SetHttpRequestTrailerSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseIncomplete:
									return v.SetHttpResponseIncomplete(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseHeaderSectionSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-header-section-size` payload: %w", err)
									}
									return v.SetHttpResponseHeaderSectionSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseHeaderSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.FieldSizePayload, error) {
										v := &wasi__http__types.FieldSizePayload{}
										var err error
										slog.Debug("reading field", "name", "field-name")
										v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 0)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
										}
										slog.Debug("reading field", "name", "field-size")
										v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 1)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
										}
										return v, nil
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-header-size` payload: %w", err)
									}
									return v.SetHttpResponseHeaderSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseBodySize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint64, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if b < 0x80 {
														if i == 9 && b > 1 {
															return x, errors.New("varint overflows a 64-bit integer")
														}
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-body-size` payload: %w", err)
									}
									return v.SetHttpResponseBodySize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseTrailerSectionSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (uint32, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading u32 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u32 byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return x, errors.New("varint overflows a 32-bit integer")
														}
														return x | uint32(b)<<s, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-trailer-section-size` payload: %w", err)
									}
									return v.SetHttpResponseTrailerSectionSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseTrailerSize:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__http__types.FieldSizePayload, error) {
										v := &wasi__http__types.FieldSizePayload{}
										var err error
										slog.Debug("reading field", "name", "field-name")
										v.FieldName, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r interface {
													io.ByteReader
													io.Reader
												}) (string, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading string length byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return "", fmt.Errorf("failed to read string length byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return "", errors.New("string length overflows a 32-bit integer")
															}
															x = x | uint32(b)<<s
															buf := make([]byte, x)
															slog.Debug("reading string bytes", "len", x)
															_, err = r.Read(buf)
															if err != nil {
																return "", fmt.Errorf("failed to read string bytes: %w", err)
															}
															if !utf8.Valid(buf) {
																return string(buf), errors.New("string is not valid UTF-8")
															}
															return string(buf), nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return "", errors.New("string length overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 0)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-name` field: %w", err)
										}
										slog.Debug("reading field", "name", "field-size")
										v.FieldSize, err = func(r wrpc.IndexReader, path ...uint32) (*uint32, error) {
											slog.Debug("reading option status byte")
											status, err := r.ReadByte()
											if err != nil {
												return nil, fmt.Errorf("failed to read option status byte: %w", err)
											}
											switch status {
											case 0:
												return nil, nil
											case 1:
												slog.Debug("reading `option::some` payload")
												v, err := func(r io.ByteReader) (uint32, error) {
													var x uint32
													var s uint
													for i := 0; i < 5; i++ {
														slog.Debug("reading u32 byte", "i", i)
														b, err := r.ReadByte()
														if err != nil {
															if i > 0 && err == io.EOF {
																err = io.ErrUnexpectedEOF
															}
															return x, fmt.Errorf("failed to read u32 byte: %w", err)
														}
														if b < 0x80 {
															if i == 4 && b > 1 {
																return x, errors.New("varint overflows a 32-bit integer")
															}
															return x | uint32(b)<<s, nil
														}
														x |= uint32(b&0x7f) << s
														s += 7
													}
													return x, errors.New("varint overflows a 32-bit integer")
												}(r)
												if err != nil {
													return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
												}
												return &v, nil
											default:
												return nil, fmt.Errorf("invalid option status byte %d", status)
											}
										}(r, append(path, 1)...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `field-size` field: %w", err)
										}
										return v, nil
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-trailer-size` payload: %w", err)
									}
									return v.SetHttpResponseTrailerSize(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseTransferCoding:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-transfer-coding` payload: %w", err)
									}
									return v.SetHttpResponseTransferCoding(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseContentCoding:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `HTTP-response-content-coding` payload: %w", err)
									}
									return v.SetHttpResponseContentCoding(payload), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpResponseTimeout:
									return v.SetHttpResponseTimeout(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpUpgradeFailed:
									return v.SetHttpUpgradeFailed(), nil
								case wasi__http__types.ErrorCodeDiscriminant_HttpProtocolError:
									return v.SetHttpProtocolError(), nil
								case wasi__http__types.ErrorCodeDiscriminant_LoopDetected:
									return v.SetLoopDetected(), nil
								case wasi__http__types.ErrorCodeDiscriminant_ConfigurationError:
									return v.SetConfigurationError(), nil
								case wasi__http__types.ErrorCodeDiscriminant_InternalError:
									payload, err := func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return "", errors.New("string length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, path...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `internal-error` payload: %w", err)
									}
									return v.SetInternalError(payload), nil
								default:
									return nil, fmt.Errorf("unknown discriminant value %d", n)
								}
							}(r, path...)
							return (*wrpc__http__types.WasiErrorCode)(v), err
						}()

						return (*wrpc__http__types.ErrorCode)(v), err
					}()

					return (*ErrorCode)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[Response, ErrorCode]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}, wrpc.NewSubscribePath().Index(0).Index(0), wrpc.NewSubscribePath().Index(0).Index(1)); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `handle`: %w", err__)
		return
	}
	return
}
