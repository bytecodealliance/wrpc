// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package streams

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasi__io__error "github.com/wrpc/wrpc/examples/go/http-outgoing-client/bindings/wasi/io/error"
	wasi__io__poll "github.com/wrpc/wrpc/examples/go/http-outgoing-client/bindings/wasi/io/poll"
	wrpc "github.com/wrpc/wrpc/go"
	errgroup "golang.org/x/sync/errgroup"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
)

type Error = wasi__io__error.Error
type Pollable = wasi__io__poll.Pollable

// An error for input-stream and output-stream operations.
type StreamError struct {
	payload      any
	discriminant StreamErrorDiscriminant
}

func (v *StreamError) Discriminant() StreamErrorDiscriminant { return v.discriminant }

type StreamErrorDiscriminant uint8

const (
	// The last operation (a write or flush) failed before completion.
	//
	// More information is available in the `error` payload.
	StreamErrorLastOperationFailed StreamErrorDiscriminant = 0
	// The stream is closed: no more input will be accepted by the
	// stream. A closed output-stream will return this error on all
	// future operations.
	StreamErrorClosed StreamErrorDiscriminant = 1
)

func (v *StreamError) String() string {
	switch v.discriminant {
	case StreamErrorLastOperationFailed:
		return "last-operation-failed"
	case StreamErrorClosed:
		return "closed"
	default:
		panic("invalid variant")
	}
}

// The last operation (a write or flush) failed before completion.
//
// More information is available in the `error` payload.
func (v *StreamError) GetLastOperationFailed() (payload wrpc.Own[Error], ok bool) {
	if ok = (v.discriminant == StreamErrorLastOperationFailed); !ok {
		return
	}
	payload, ok = v.payload.(wrpc.Own[Error])
	return
}

// The last operation (a write or flush) failed before completion.
//
// More information is available in the `error` payload.
func (v *StreamError) SetLastOperationFailed(payload wrpc.Own[Error]) *StreamError {
	v.discriminant = StreamErrorLastOperationFailed
	v.payload = payload
	return v
}

// The last operation (a write or flush) failed before completion.
//
// More information is available in the `error` payload.
func NewStreamErrorLastOperationFailed(payload wrpc.Own[Error]) *StreamError {
	return (&StreamError{}).SetLastOperationFailed(
		payload)
}

// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
func (v *StreamError) GetClosed() (ok bool) {
	if ok = (v.discriminant == StreamErrorClosed); !ok {
		return
	}
	return
}

// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
func (v *StreamError) SetClosed() *StreamError {
	v.discriminant = StreamErrorClosed
	v.payload = nil
	return v
}

// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
func NewStreamErrorClosed() *StreamError {
	return (&StreamError{}).SetClosed()
}
func (v *StreamError) Error() string { return v.String() }
func (v *StreamError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case StreamErrorLastOperationFailed:
		payload, ok := v.payload.(wrpc.Own[Error])
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(payload), w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(0)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case StreamErrorClosed:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Perform a non-blocking read from the stream.
//
// When the source of a `read` is binary data, the bytes from the source
// are returned verbatim. When the source of a `read` is known to the
// implementation to be text, bytes containing the UTF-8 encoding of the
// text are returned.
//
// This function returns a list of bytes containing the read data,
// when successful. The returned list will contain up to `len` bytes;
// it may return fewer than requested, but not more. The list is
// empty when no bytes are available for reading at this time. The
// pollable given by `subscribe` will be ready when more bytes are
// available.
//
// This function fails with a `stream-error` when the operation
// encounters an error, giving `last-operation-failed`, or when the
// stream is closed, giving `closed`.
//
// When the caller gives a `len` of 0, it represents a request to
// read 0 bytes. If the stream is still open, this call should
// succeed and return an empty list, or otherwise fail with `closed`.
//
// The `len` parameter is a `u64`, which could represent a list of u8 which
// is not possible to allocate in wasm32, or not desirable to allocate as
// as a return value by the callee. The callee may return a list of bytes
// less than `len` in size while more bytes are available for reading.
func InputStreamRead(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[[]uint8, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "read", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[[]uint8, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[[]uint8, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[[]uint8, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]input-stream.read`: %w", err__)
		return
	}
	return
}

// Read bytes from a stream, after blocking until at least one byte can
// be read. Except for blocking, behavior is identical to `read`.
func InputStreamBlockingRead(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[[]uint8, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-read", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[[]uint8, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[[]uint8, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[[]uint8, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]input-stream.blocking-read`: %w", err__)
		return
	}
	return
}

// Skip bytes from a stream. Returns number of bytes skipped.
//
// Behaves identical to `read`, except instead of returning a list
// of bytes, returns the number of bytes consumed from the stream.
func InputStreamSkip(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[uint64, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "skip", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[uint64, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading u64 byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u64 byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]input-stream.skip`: %w", err__)
		return
	}
	return
}

// Skip bytes from a stream, after blocking until at least one byte
// can be skipped. Except for blocking behavior, identical to `skip`.
func InputStreamBlockingSkip(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[uint64, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-skip", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[uint64, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading u64 byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u64 byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]input-stream.blocking-skip`: %w", err__)
		return
	}
	return
}

// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
// The created `pollable` is a child resource of the `input-stream`.
// Implementations may trap if the `input-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
func InputStreamSubscribe(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[InputStream]) (r0__ wrpc.Own[Pollable], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "subscribe", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Pollable], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Pollable](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]input-stream.subscribe`: %w", err__)
		return
	}
	return
}

// Check readiness for writing. This function never blocks.
//
// Returns the number of bytes permitted for the next call to `write`,
// or an error. Calling `write` with more bytes than this function has
// permitted will trap.
//
// When this function returns 0 bytes, the `subscribe` pollable will
// become ready when this function will report at least 1 byte, or an
// error.
func OutputStreamCheckWrite(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream]) (r0__ *wrpc.Result[uint64, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "check-write", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[uint64, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading u64 byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u64 byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.check-write`: %w", err__)
		return
	}
	return
}

// Perform a write. This function never blocks.
//
// When the destination of a `write` is binary data, the bytes from
// `contents` are written verbatim. When the destination of a `write` is
// known to the implementation to be text, the bytes of `contents` are
// transcoded from UTF-8 into the encoding of the destination and then
// written.
//
// Precondition: check-write gave permit of Ok(n) and contents has a
// length of less than or equal to n. Otherwise, this function will trap.
//
// returns Err(closed) without writing if the stream has closed since
// the last call to check-write provided a permit.
func OutputStreamWrite(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], contents []uint8) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "write", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []uint8, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
					slog.Debug("writing u8 byte")
					return w.WriteByte(v)
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(contents, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `contents` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.write`: %w", err__)
		return
	}
	return
}

// Perform a write of up to 4096 bytes, and then flush the stream. Block
// until all of these operations are complete, or an error occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write`, and `flush`, and is implemented with the
// following pseudo-code:
//
// ```text
// let pollable = this.subscribe();
// while !contents.is_empty() {
// // Wait for the stream to become writable
// pollable.block();
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, contents.len());
// let (chunk, rest) = contents.split_at(len);
// this.write(chunk  );            // eliding error handling
// contents = rest;
// }
// this.flush();
// // Wait for completion of `flush`
// pollable.block();
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
func OutputStreamBlockingWriteAndFlush(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], contents []uint8) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-write-and-flush", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []uint8, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
					slog.Debug("writing u8 byte")
					return w.WriteByte(v)
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg errgroup.Group
					for index, write := range writes {
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						wg.Go(func() error {
							return write(w)
						})
					}
					return wg.Wait()
				}, nil
			}
			return nil, nil
		}(contents, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `contents` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.blocking-write-and-flush`: %w", err__)
		return
	}
	return
}

// Request to flush buffered output. This function never blocks.
//
// This tells the output-stream that the caller intends any buffered
// output to be flushed. the output which is expected to be flushed
// is all that has been passed to `write` prior to this call.
//
// Upon calling this function, the `output-stream` will not accept any
// writes (`check-write` will return `ok(0)`) until the flush has
// completed. The `subscribe` pollable will become ready when the
// flush has completed and the stream can accept more writes.
func OutputStreamFlush(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream]) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "flush", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.flush`: %w", err__)
		return
	}
	return
}

// Request to flush buffered output, and block until flush completes
// and stream is ready for writing again.
func OutputStreamBlockingFlush(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream]) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-flush", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.blocking-flush`: %w", err__)
		return
	}
	return
}

// Create a `pollable` which will resolve once the output-stream
// is ready for more writing, or an error has occured. When this
// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
// error.
//
// If the stream is closed, this pollable is always ready immediately.
//
// The created `pollable` is a child resource of the `output-stream`.
// Implementations may trap if the `output-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
func OutputStreamSubscribe(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream]) (r0__ wrpc.Own[Pollable], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "subscribe", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[Pollable], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[Pollable](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.subscribe`: %w", err__)
		return
	}
	return
}

// Write zeroes to a stream.
//
// This should be used precisely like `write` with the exact same
// preconditions (must use check-write first), but instead of
// passing a list of bytes, you simply pass the number of zero-bytes
// that should be written.
func OutputStreamWriteZeroes(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], len_ uint64) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "write-zeroes", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.write-zeroes`: %w", err__)
		return
	}
	return
}

// Perform a write of up to 4096 zeroes, and then flush the stream.
// Block until all of these operations are complete, or an error
// occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
// the following pseudo-code:
//
// ```text
// let pollable = this.subscribe();
// while num_zeroes != 0 {
// // Wait for the stream to become writable
// pollable.block();
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, num_zeroes);
// this.write-zeroes(len);         // eliding error handling
// num_zeroes -= len;
// }
// this.flush();
// // Wait for completion of `flush`
// pollable.block();
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
func OutputStreamBlockingWriteZeroesAndFlush(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], len_ uint64) (r0__ *wrpc.Result[struct{}, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-write-zeroes-and-flush", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.blocking-write-zeroes-and-flush`: %w", err__)
		return
	}
	return
}

// Read from one stream and write to another.
//
// The behavior of splice is equivelant to:
// 1. calling `check-write` on the `output-stream`
// 2. calling `read` on the `input-stream` with the smaller of the
// `check-write` permitted length and the `len` provided to `splice`
// 3. calling `write` on the `output-stream` with that read data.
//
// Any error reported by the call to `check-write`, `read`, or
// `write` ends the splice and reports that error.
//
// This function returns the number of bytes transferred; it may be less
// than `len`.
func OutputStreamSplice(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], src wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[uint64, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "splice", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 3)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(src), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `src` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[uint64, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading u64 byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u64 byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.splice`: %w", err__)
		return
	}
	return
}

// Read from one stream and write to another, with blocking.
//
// This is similar to `splice`, except that it blocks until the
// `output-stream` is ready for writing, and the `input-stream`
// is ready for reading, before performing the `splice`.
func OutputStreamBlockingSplice(ctx__ context.Context, wrpc__ wrpc.Client, self wrpc.Borrow[OutputStream], src wrpc.Borrow[InputStream], len_ uint64) (r0__ *wrpc.Result[uint64, StreamError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "blocking-splice", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 3)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(src), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `src` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[uint64, StreamError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading u64 byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u64 byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*StreamError, error) {
					v := &StreamError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if b < 0x80 {
								if i == 2 && b > 1 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch StreamErrorDiscriminant(n) {
					case StreamErrorLastOperationFailed:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (wrpc.Own[Error], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading owned resource ID length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
								}
								if b < 0x80 {
									if i == 4 && b > 1 {
										return "", errors.New("owned resource ID length overflows a 32-bit integer")
									}
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading owned resource ID bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return "", errors.New("owned resource ID is not valid UTF-8")
									}
									return wrpc.Own[Error](buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("owned resource ID length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `last-operation-failed` payload: %w", err)
						}
						return v.SetLastOperationFailed(payload), nil
					case StreamErrorClosed:
						return v.SetClosed(), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[uint64, StreamError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]output-stream.blocking-splice`: %w", err__)
		return
	}
	return
}

type InputStream interface {
	// Perform a non-blocking read from the stream.
	//
	// When the source of a `read` is binary data, the bytes from the source
	// are returned verbatim. When the source of a `read` is known to the
	// implementation to be text, bytes containing the UTF-8 encoding of the
	// text are returned.
	//
	// This function returns a list of bytes containing the read data,
	// when successful. The returned list will contain up to `len` bytes;
	// it may return fewer than requested, but not more. The list is
	// empty when no bytes are available for reading at this time. The
	// pollable given by `subscribe` will be ready when more bytes are
	// available.
	//
	// This function fails with a `stream-error` when the operation
	// encounters an error, giving `last-operation-failed`, or when the
	// stream is closed, giving `closed`.
	//
	// When the caller gives a `len` of 0, it represents a request to
	// read 0 bytes. If the stream is still open, this call should
	// succeed and return an empty list, or otherwise fail with `closed`.
	//
	// The `len` parameter is a `u64`, which could represent a list of u8 which
	// is not possible to allocate in wasm32, or not desirable to allocate as
	// as a return value by the callee. The callee may return a list of bytes
	// less than `len` in size while more bytes are available for reading.
	Read(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[[]uint8, StreamError], func() error, error)
	// Read bytes from a stream, after blocking until at least one byte can
	// be read. Except for blocking, behavior is identical to `read`.
	BlockingRead(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[[]uint8, StreamError], func() error, error)
	// Skip bytes from a stream. Returns number of bytes skipped.
	//
	// Behaves identical to `read`, except instead of returning a list
	// of bytes, returns the number of bytes consumed from the stream.
	Skip(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[uint64, StreamError], func() error, error)
	// Skip bytes from a stream, after blocking until at least one byte
	// can be skipped. Except for blocking behavior, identical to `skip`.
	BlockingSkip(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[uint64, StreamError], func() error, error)
	// Create a `pollable` which will resolve once either the specified stream
	// has bytes available to read or the other end of the stream has been
	// closed.
	// The created `pollable` is a child resource of the `input-stream`.
	// Implementations may trap if the `input-stream` is dropped before
	// all derived `pollable`s created with this function are dropped.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Pollable], func() error, error)
}
type OutputStream interface {
	// Check readiness for writing. This function never blocks.
	//
	// Returns the number of bytes permitted for the next call to `write`,
	// or an error. Calling `write` with more bytes than this function has
	// permitted will trap.
	//
	// When this function returns 0 bytes, the `subscribe` pollable will
	// become ready when this function will report at least 1 byte, or an
	// error.
	CheckWrite(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[uint64, StreamError], func() error, error)
	// Perform a write. This function never blocks.
	//
	// When the destination of a `write` is binary data, the bytes from
	// `contents` are written verbatim. When the destination of a `write` is
	// known to the implementation to be text, the bytes of `contents` are
	// transcoded from UTF-8 into the encoding of the destination and then
	// written.
	//
	// Precondition: check-write gave permit of Ok(n) and contents has a
	// length of less than or equal to n. Otherwise, this function will trap.
	//
	// returns Err(closed) without writing if the stream has closed since
	// the last call to check-write provided a permit.
	Write(ctx__ context.Context, wrpc__ wrpc.Client, contents []uint8) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Perform a write of up to 4096 bytes, and then flush the stream. Block
	// until all of these operations are complete, or an error occurs.
	//
	// This is a convenience wrapper around the use of `check-write`,
	// `subscribe`, `write`, and `flush`, and is implemented with the
	// following pseudo-code:
	//
	// ```text
	// let pollable = this.subscribe();
	// while !contents.is_empty() {
	// // Wait for the stream to become writable
	// pollable.block();
	// let Ok(n) = this.check-write(); // eliding error handling
	// let len = min(n, contents.len());
	// let (chunk, rest) = contents.split_at(len);
	// this.write(chunk  );            // eliding error handling
	// contents = rest;
	// }
	// this.flush();
	// // Wait for completion of `flush`
	// pollable.block();
	// // Check for any errors that arose during `flush`
	// let _ = this.check-write();         // eliding error handling
	// ```
	BlockingWriteAndFlush(ctx__ context.Context, wrpc__ wrpc.Client, contents []uint8) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Request to flush buffered output. This function never blocks.
	//
	// This tells the output-stream that the caller intends any buffered
	// output to be flushed. the output which is expected to be flushed
	// is all that has been passed to `write` prior to this call.
	//
	// Upon calling this function, the `output-stream` will not accept any
	// writes (`check-write` will return `ok(0)`) until the flush has
	// completed. The `subscribe` pollable will become ready when the
	// flush has completed and the stream can accept more writes.
	Flush(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Request to flush buffered output, and block until flush completes
	// and stream is ready for writing again.
	BlockingFlush(ctx__ context.Context, wrpc__ wrpc.Client) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Create a `pollable` which will resolve once the output-stream
	// is ready for more writing, or an error has occured. When this
	// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
	// error.
	//
	// If the stream is closed, this pollable is always ready immediately.
	//
	// The created `pollable` is a child resource of the `output-stream`.
	// Implementations may trap if the `output-stream` is dropped before
	// all derived `pollable`s created with this function are dropped.
	Subscribe(ctx__ context.Context, wrpc__ wrpc.Client) (wrpc.Own[Pollable], func() error, error)
	// Write zeroes to a stream.
	//
	// This should be used precisely like `write` with the exact same
	// preconditions (must use check-write first), but instead of
	// passing a list of bytes, you simply pass the number of zero-bytes
	// that should be written.
	WriteZeroes(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Perform a write of up to 4096 zeroes, and then flush the stream.
	// Block until all of these operations are complete, or an error
	// occurs.
	//
	// This is a convenience wrapper around the use of `check-write`,
	// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
	// the following pseudo-code:
	//
	// ```text
	// let pollable = this.subscribe();
	// while num_zeroes != 0 {
	// // Wait for the stream to become writable
	// pollable.block();
	// let Ok(n) = this.check-write(); // eliding error handling
	// let len = min(n, num_zeroes);
	// this.write-zeroes(len);         // eliding error handling
	// num_zeroes -= len;
	// }
	// this.flush();
	// // Wait for completion of `flush`
	// pollable.block();
	// // Check for any errors that arose during `flush`
	// let _ = this.check-write();         // eliding error handling
	// ```
	BlockingWriteZeroesAndFlush(ctx__ context.Context, wrpc__ wrpc.Client, len_ uint64) (*wrpc.Result[struct{}, StreamError], func() error, error)
	// Read from one stream and write to another.
	//
	// The behavior of splice is equivelant to:
	// 1. calling `check-write` on the `output-stream`
	// 2. calling `read` on the `input-stream` with the smaller of the
	// `check-write` permitted length and the `len` provided to `splice`
	// 3. calling `write` on the `output-stream` with that read data.
	//
	// Any error reported by the call to `check-write`, `read`, or
	// `write` ends the splice and reports that error.
	//
	// This function returns the number of bytes transferred; it may be less
	// than `len`.
	Splice(ctx__ context.Context, wrpc__ wrpc.Client, src wrpc.Borrow[InputStream], len_ uint64) (*wrpc.Result[uint64, StreamError], func() error, error)
	// Read from one stream and write to another, with blocking.
	//
	// This is similar to `splice`, except that it blocks until the
	// `output-stream` is ready for writing, and the `input-stream`
	// is ready for reading, before performing the `splice`.
	BlockingSplice(ctx__ context.Context, wrpc__ wrpc.Client, src wrpc.Borrow[InputStream], len_ uint64) (*wrpc.Result[uint64, StreamError], func() error, error)
}
