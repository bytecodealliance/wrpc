// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package store

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
)

// The set of errors which may be raised by functions in this package
type Error struct {
	payload      any
	discriminant ErrorDiscriminant
}

func (v *Error) Discriminant() ErrorDiscriminant { return v.discriminant }

type ErrorDiscriminant uint8

const (
	// The host does not recognize the store identifier requested.
	ErrorDiscriminant_NoSuchStore ErrorDiscriminant = 0
	// The requesting component does not have access to the specified store
	// (which may or may not exist).
	ErrorDiscriminant_AccessDenied ErrorDiscriminant = 1
	// Some implementation-specific error has occurred (e.g. I/O)
	ErrorDiscriminant_Other ErrorDiscriminant = 2
)

func (v *Error) String() string {
	switch v.discriminant {
	case ErrorDiscriminant_NoSuchStore:
		return "no-such-store"
	case ErrorDiscriminant_AccessDenied:
		return "access-denied"
	case ErrorDiscriminant_Other:
		return "other"
	default:
		panic("invalid variant")
	}
}

// The host does not recognize the store identifier requested.
func (v *Error) GetNoSuchStore() (ok bool) {
	if ok = (v.discriminant == ErrorDiscriminant_NoSuchStore); !ok {
		return
	}
	return
}

// The host does not recognize the store identifier requested.
func NewError_NoSuchStore() *Error {
	return &Error{
		nil, ErrorDiscriminant_NoSuchStore}
}

// The requesting component does not have access to the specified store
// (which may or may not exist).
func (v *Error) GetAccessDenied() (ok bool) {
	if ok = (v.discriminant == ErrorDiscriminant_AccessDenied); !ok {
		return
	}
	return
}

// The requesting component does not have access to the specified store
// (which may or may not exist).
func NewError_AccessDenied() *Error {
	return &Error{
		nil, ErrorDiscriminant_AccessDenied}
}

// Some implementation-specific error has occurred (e.g. I/O)
func (v *Error) GetOther() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorDiscriminant_Other); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Some implementation-specific error has occurred (e.g. I/O)
func NewError_Other(payload string) *Error {
	return &Error{
		payload, ErrorDiscriminant_Other}
}
func (v *Error) Error() string { return v.String() }
func (v *Error) WriteTo(w wrpc.ByteWriter) error {
	if err := func(v uint8, w wrpc.ByteWriter) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorDiscriminant_NoSuchStore:
	case ErrorDiscriminant_AccessDenied:
	case ErrorDiscriminant_Other:
		payload, ok := v.payload.(string)
		if !ok {
			return errors.New("invalid payload")
		}
		if err := func(v string, w wrpc.ByteWriter) error {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			slog.Debug("writing string byte length", "len", n)
			if err := func(v uint32, w wrpc.ByteWriter) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u32")
				_, err := w.Write(b[:i])
				return err
			}(uint32(n), w); err != nil {
				return fmt.Errorf("failed to write string length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err := w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w); err != nil {
			return fmt.Errorf("failed to write payload: %w", err)
		}
	default:
		panic("invalid variant")
	}
	return nil
}
func ReadError(r wrpc.ByteReader) (*Error, error) {
	disc, err := func(r wrpc.ByteReader) (uint8, error) {
		var x uint8
		var s uint
		for i := 0; i < 2; i++ {
			slog.Debug("reading `uint8` byte", "i", i)
			b, err := r.ReadByte()
			if err != nil {
				if i > 0 && err == io.EOF {
					err = io.ErrUnexpectedEOF
				}
				return x, fmt.Errorf("failed to read `uint8` byte: %w", err)
			}
			if b < 0x80 {
				if i == 2 && b > 1 {
					return x, errors.New("varint overflows a 8-bit integer")
				}
				return x | uint8(b)<<s, nil
			}
			x |= uint8(b&0x7f) << s
			s += 7
		}
		return x, errors.New("varint overflows a 8-bit integer")
	}(r)
	if err != nil {
		return nil, fmt.Errorf("failed to read discriminant: %w", err)
	}
	switch ErrorDiscriminant(disc) {
	case ErrorDiscriminant_NoSuchStore:
		return NewError_NoSuchStore(), nil
	case ErrorDiscriminant_AccessDenied:
		return NewError_AccessDenied(), nil
	case ErrorDiscriminant_Other:
		payload, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return nil, fmt.Errorf("failed to read `other` payload: %w", err)
		}
		return NewError_Other(payload), nil
	default:
		return nil, fmt.Errorf("unknown discriminant value %d", disc)
	}
}

// A response to a `list-keys` operation.
type KeyResponse struct {
	// The list of keys returned by the query.
	Keys []string
	// The continuation token to use to fetch the next page of keys. If this is `null`, then
	// there are no more keys to fetch.
	Cursor *uint64
}

func (v *KeyResponse) String() string { return "KeyResponse" }

func (v *KeyResponse) WriteTo(w wrpc.ByteWriter) error {
	slog.Debug("writing field", "name", "keys")
	if err := func(v []string, w wrpc.ByteWriter) error {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		slog.Debug("writing list length", "len", n)
		if err := func(v uint32, w wrpc.ByteWriter) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u32")
			_, err := w.Write(b[:i])
			return err
		}(uint32(n), w); err != nil {
			return fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		for i, e := range v {
			if err := func(v string, w wrpc.ByteWriter) error {
				n := len(v)
				if n > math.MaxUint32 {
					return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
				}
				slog.Debug("writing string byte length", "len", n)
				if err := func(v uint32, w wrpc.ByteWriter) error {
					b := make([]byte, binary.MaxVarintLen32)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing u32")
					_, err := w.Write(b[:i])
					return err
				}(uint32(n), w); err != nil {
					return fmt.Errorf("failed to write string length of %d: %w", n, err)
				}
				slog.Debug("writing string bytes")
				_, err := w.Write([]byte(v))
				if err != nil {
					return fmt.Errorf("failed to write string bytes: %w", err)
				}
				return nil
			}(e, w); err != nil {
				return fmt.Errorf("failed to write list element %d: %w", i, err)
			}
		}
		return nil
	}(v.Keys, w); err != nil {
		return fmt.Errorf("failed to write `keys` field: %w", err)
	}
	slog.Debug("writing field", "name", "cursor")
	if err := func(v *uint64, w wrpc.ByteWriter) error {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		if err := func(v uint64, w wrpc.ByteWriter) error {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err := w.Write(b[:i])
			return err
		}(*v, w); err != nil {
			return fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return nil
	}(v.Cursor, w); err != nil {
		return fmt.Errorf("failed to write `cursor` field: %w", err)
	}
	return nil
}
func ReadKeyResponse(r wrpc.ByteReader) (*KeyResponse, error) {
	v := &KeyResponse{}
	var err error
	slog.Debug("reading field", "name", "keys")
	v.Keys, err = func(r wrpc.ByteReader) ([]string, error) {
		var x uint32
		var s uint
		for i := 0; i < 5; i++ {
			slog.Debug("reading list length byte", "i", i)
			b, err := r.ReadByte()
			if err != nil {
				if i > 0 && err == io.EOF {
					err = io.ErrUnexpectedEOF
				}
				return nil, fmt.Errorf("failed to read list length byte: %w", err)
			}
			if b < 0x80 {
				if i == 4 && b > 1 {
					return nil, errors.New("list length overflows a 32-bit integer")
				}
				x = x | uint32(b)<<s
				vs := make([]string, x)
				for i := range vs {
					slog.Debug("reading list element", "i", i)
					vs[i], err = func(r wrpc.ByteReader) (string, error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if b < 0x80 {
								if i == 4 && b > 1 {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
					}
				}
				return vs, nil
			}
			x |= uint32(b&0x7f) << s
			s += 7
		}
		return nil, errors.New("list length overflows a 32-bit integer")
	}(r)
	if err != nil {
		return nil, fmt.Errorf("failed to read `keys` field: %w", err)
	}
	slog.Debug("reading field", "name", "cursor")
	v.Cursor, err = func(r wrpc.ByteReader) (*uint64, error) {
		slog.Debug("reading option status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read option status byte: %w", err)
		}
		switch status {
		case 0:
			return nil, nil
		case 1:
			slog.Debug("reading `option::some` payload")
			v, err := func(r wrpc.ByteReader) (uint64, error) {
				var x uint64
				var s uint
				for i := 0; i < 10; i++ {
					slog.Debug("reading `uint64` byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return x, fmt.Errorf("failed to read `uint64` byte: %w", err)
					}
					if b < 0x80 {
						if i == 9 && b > 1 {
							return x, errors.New("varint overflows a 64-bit integer")
						}
						return x | uint64(b)<<s, nil
					}
					x |= uint64(b&0x7f) << s
					s += 7
				}
				return x, errors.New("varint overflows a 64-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
			}
			return &v, nil
		default:
			return nil, fmt.Errorf("invalid option status byte %d", status)
		}
	}(r)
	if err != nil {
		return nil, fmt.Errorf("failed to read `cursor` field: %w", err)
	}
	return v, nil
}

type Handler interface {
	// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
	// bucket, and the bucket itself acts as a collection of all these entries.
	//
	// It is worth noting that the exact terminology for bucket in key-value stores can very
	// depending on the specific implementation. For example:
	//
	// 1. Amazon DynamoDB calls a collection of key-value pairs a table
	// 2. Redis has hashes, sets, and sorted sets as different types of collections
	// 3. Cassandra calls a collection of key-value pairs a column family
	// 4. MongoDB calls a collection of key-value pairs a collection
	// 5. Riak calls a collection of key-value pairs a bucket
	// 6. Memcached calls a collection of key-value pairs a slab
	// 7. Azure Cosmos DB calls a collection of key-value pairs a container
	//
	// In this interface, we use the term `bucket` to refer to a collection of key-value pairs
	// Get the value associated with the specified `key`
	//
	// The value is returned as an option. If the key-value pair exists in the
	// store, it returns `Ok(value)`. If the key does not exist in the
	// store, it returns `Ok(none)`.
	//
	// If any other error occurs, it returns an `Err(error)`.
	Get(ctx__ context.Context, bucket string, key string) (r0__ *wrpc.Result[[]uint8, Error], err__ error)

	// Set the value associated with the key in the store. If the key already
	// exists in the store, it overwrites the value.
	//
	// If the key does not exist in the store, it creates a new key-value pair.
	//
	// If any other error occurs, it returns an `Err(error)`.
	Set(ctx__ context.Context, bucket string, key string, value []uint8) (r0__ *wrpc.Result[struct{}, Error], err__ error)

	// Delete the key-value pair associated with the key in the store.
	//
	// If the key does not exist in the store, it does nothing.
	//
	// If any other error occurs, it returns an `Err(error)`.
	Delete(ctx__ context.Context, bucket string, key string) (r0__ *wrpc.Result[struct{}, Error], err__ error)

	// Check if the key exists in the store.
	//
	// If the key exists in the store, it returns `Ok(true)`. If the key does
	// not exist in the store, it returns `Ok(false)`.
	//
	// If any other error occurs, it returns an `Err(error)`.
	Exists(ctx__ context.Context, bucket string, key string) (r0__ *wrpc.Result[bool, Error], err__ error)

	// Get all the keys in the store with an optional cursor (for use in pagination). It
	// returns a list of keys. Please note that for most KeyValue implementations, this is a
	// can be a very expensive operation and so it should be used judiciously. Implementations
	// can return any number of keys in a single response, but they should never attempt to
	// send more data than is reasonable (i.e. on a small edge device, this may only be a few
	// KB, while on a large machine this could be several MB). Any response should also return
	// a cursor that can be used to fetch the next page of keys. See the `key-response` record
	// for more information.
	//
	// Note that the keys are not guaranteed to be returned in any particular order.
	//
	// If the store is empty, it returns an empty list.
	//
	// MAY show an out-of-date list of keys if there are concurrent writes to the store.
	//
	// If any error occurs, it returns an `Err(error)`.
	ListKeys(ctx__ context.Context, bucket string, cursor *uint64) (r0__ *wrpc.Result[KeyResponse, Error], err__ error)
}

func ServeInterface(c wrpc.Client, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 5)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}
	stop0, err := c.Serve("wrpc:keyvalue/store@0.2.0-draft", "get", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/store@0.2.0-draft.get` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()
		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/store@0.2.0-draft.get` handler")
		r0, err := h.Get(ctx, p0, p1)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/store@0.2.0-draft.get` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[[]uint8, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				if err := func(v []uint8, w wrpc.ByteWriter) error {
					if v == nil {
						slog.Debug("writing `option::none` status byte")
						if err := w.WriteByte(0); err != nil {
							return fmt.Errorf("failed to write `option::none` byte: %w", err)
						}
						return nil
					}
					slog.Debug("writing `option::some` status byte")
					if err := w.WriteByte(1); err != nil {
						return fmt.Errorf("failed to write `option::some` status byte: %w", err)
					}
					slog.Debug("writing `option::some` payload")
					if err := func(v []uint8, w wrpc.ByteWriter) error {
						n := len(v)
						if n > math.MaxUint32 {
							return fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						slog.Debug("writing list length", "len", n)
						if err := func(v uint32, w wrpc.ByteWriter) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing u32")
							_, err := w.Write(b[:i])
							return err
						}(uint32(n), w); err != nil {
							return fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						for i, e := range v {
							if err := func(v uint8, w wrpc.ByteWriter) error {
								slog.Debug("writing u8 byte")
								return w.WriteByte(v)
							}(e, w); err != nil {
								return fmt.Errorf("failed to write list element %d: %w", i, err)
							}
						}
						return nil
					}(v, w); err != nil {
						return fmt.Errorf("failed to write `option::some` payload: %w", err)
					}
					return nil
				}(*v.Ok, w); err != nil {
					return fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/store@0.2.0-draft.get` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/store@0.2.0-draft.get`: %w", err)
	}
	stops = append(stops, stop0)
	stop1, err := c.Serve("wrpc:keyvalue/store@0.2.0-draft", "set", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/store@0.2.0-draft.set` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()
		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func(r wrpc.ByteReader) ([]uint8, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading list length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return nil, fmt.Errorf("failed to read list length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return nil, errors.New("list length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					vs := make([]uint8, x)
					for i := range vs {
						slog.Debug("reading list element", "i", i)
						vs[i], err = func(r wrpc.ByteReader) (uint8, error) {
							slog.Debug("reading `u8` byte")
							v, err := r.ReadByte()
							if err != nil {
								return 0, fmt.Errorf("failed to read `u8` byte: %w", err)
							}
							return v, nil
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
						}
					}
					return vs, nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return nil, errors.New("list length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 2")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/store@0.2.0-draft.set` handler")
		r0, err := h.Set(ctx, p0, p1, p2)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/store@0.2.0-draft.set` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[struct{}, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/store@0.2.0-draft.set` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/store@0.2.0-draft.set`: %w", err)
	}
	stops = append(stops, stop1)
	stop2, err := c.Serve("wrpc:keyvalue/store@0.2.0-draft", "delete", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/store@0.2.0-draft.delete` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()
		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/store@0.2.0-draft.delete` handler")
		r0, err := h.Delete(ctx, p0, p1)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/store@0.2.0-draft.delete` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[struct{}, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/store@0.2.0-draft.delete` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/store@0.2.0-draft.delete`: %w", err)
	}
	stops = append(stops, stop2)
	stop3, err := c.Serve("wrpc:keyvalue/store@0.2.0-draft", "exists", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/store@0.2.0-draft.exists` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()
		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/store@0.2.0-draft.exists` handler")
		r0, err := h.Exists(ctx, p0, p1)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/store@0.2.0-draft.exists` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[bool, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				if err := func(v bool, w wrpc.ByteWriter) error {
					if !v {
						slog.Debug("writing `false` byte")
						return w.WriteByte(0)
					}
					slog.Debug("writing `true` byte")
					return w.WriteByte(1)
				}(*v.Ok, w); err != nil {
					return fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/store@0.2.0-draft.exists` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/store@0.2.0-draft.exists`: %w", err)
	}
	stops = append(stops, stop3)
	stop4, err := c.Serve("wrpc:keyvalue/store@0.2.0-draft", "list-keys", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/store@0.2.0-draft.list-keys` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()
		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (*uint64, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.ByteReader) (uint64, error) {
					var x uint64
					var s uint
					for i := 0; i < 10; i++ {
						slog.Debug("reading `uint64` byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read `uint64` byte: %w", err)
						}
						if b < 0x80 {
							if i == 9 && b > 1 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							return x | uint64(b)<<s, nil
						}
						x |= uint64(b&0x7f) << s
						s += 7
					}
					return x, errors.New("varint overflows a 64-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return &v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/store@0.2.0-draft.list-keys` handler")
		r0, err := h.ListKeys(ctx, p0, p1)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/store@0.2.0-draft.list-keys` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[KeyResponse, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				if err := (*v.Ok).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/store@0.2.0-draft.list-keys` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/store@0.2.0-draft.list-keys`: %w", err)
	}
	stops = append(stops, stop4)
	return stop, nil
}
