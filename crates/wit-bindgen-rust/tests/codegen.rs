#![allow(unused_macros)]
#![allow(dead_code, unused_variables)]

mod codegen_tests {
    macro_rules! codegen_test {
        (wasi_cli $name:tt $test:tt) => {};
        (wasi_http $name:tt $test:tt) => {};
        ($id:ident $name:tt $test:tt) => {
            mod $id {
                wit_bindgen_wrpc::generate!({
                    path: $test,
                    generate_all
                });

                // This empty module named 'core' is here to catch module path
                // conflicts with 'core' modules used in code generated by the
                // wit_bindgen_wrpc::generate macro.
                // Ref: https://github.com/bytecodealliance/wit-bindgen/pull/568
                mod core {}

                #[test]
                fn works() {}

                mod borrowed {
                    wit_bindgen_wrpc::generate!({
                        path: $test,
                        generate_all
                    });

                    #[test]
                    fn works() {}
                }

                mod duplicate {
                    wit_bindgen_wrpc::generate!({
                        path: $test,
                        generate_all
                    });

                    #[test]
                    fn works() {}
                }
            }

        };
    }
    test_helpers::codegen_tests!();
}

mod strings {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:strings;

            world not-used-name {
                import cat: interface {
                    foo: func(x: string);
                    bar: func() -> string;
                }
            }
        ",
    });

    #[allow(dead_code)]
    async fn test(
        wrpc: &impl wit_bindgen_wrpc::wrpc_transport::Invoke<Context = ()>,
    ) -> anyhow::Result<()> {
        // Test the argument is `&str`.
        cat::foo(wrpc, (), "hello").await?;

        // Test the return type is `String`.
        let _t: String = cat::bar(wrpc, ()).await?;

        Ok(())
    }
}

mod skip {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            world baz {
                export exports: interface {
                    foo: func();
                    bar: func();
                }
            }
        ",
        skip: ["foo"],
    });

    #[derive(Clone)]
    struct Component;

    impl<Ctx: Send> exports::exports::Handler<Ctx> for Component {
        async fn bar(&self, cx: Ctx) -> anyhow::Result<()> {
            Ok(())
        }
    }

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        serve(wrpc, Component, async {}).await.unwrap();
    }
}

mod symbol_does_not_conflict {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            interface foo1 {
                foo: func();
            }

            interface foo2 {
                foo: func();
            }

            interface bar1 {
                bar: func() -> string;
            }

            interface bar2 {
                bar: func() -> string;
            }

            world foo {
                export foo1;
                export foo2;
                export bar1;
                export bar2;
            }
        ",
    });

    #[derive(Clone)]
    struct Component;

    impl<Ctx: Send> exports::my::inline::foo1::Handler<Ctx> for Component {
        async fn foo(&self, cx: Ctx) -> anyhow::Result<()> {
            Ok(())
        }
    }

    impl<Ctx: Send> exports::my::inline::foo2::Handler<Ctx> for Component {
        async fn foo(&self, cx: Ctx) -> anyhow::Result<()> {
            Ok(())
        }
    }

    impl<Ctx: Send> exports::my::inline::bar1::Handler<Ctx> for Component {
        async fn bar(&self, cx: Ctx) -> anyhow::Result<String> {
            Ok(String::new())
        }
    }

    impl<Ctx: Send> exports::my::inline::bar2::Handler<Ctx> for Component {
        async fn bar(&self, cx: Ctx) -> anyhow::Result<String> {
            Ok(String::new())
        }
    }

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        serve(wrpc, Component, async {}).await.unwrap();
    }
}

mod alternative_bitflags_path {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;
            world foo {
                flags bar {
                    foo,
                    bar,
                    baz
                }
                export get-flag: func() -> bar;
            }
        ",
        bitflags_path: my_bitflags,
    });

    pub(crate) use wit_bindgen_wrpc::bitflags as my_bitflags;

    #[derive(Clone)]
    struct Component;

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        serve(wrpc, Component, async {}).await.unwrap();
    }

    impl<Ctx: Send> Handler<Ctx> for Component {
        async fn get_flag(&self, cx: Ctx) -> anyhow::Result<Bar> {
            Ok(Bar::BAZ)
        }
    }
}

mod owned_resource_deref_mut {
    use exports::my::inline::foo::Bar;
    use wit_bindgen_wrpc::bytes::Bytes;
    use wrpc_transport::{ResourceBorrow, ResourceOwn};

    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            interface foo {
                resource bar {
                    constructor(data: u32);
                    get-data: func() -> u32;
                    consume: static func(%self: bar) -> u32;
                }
            }

            world baz {
                export foo;
            }
        ",
    });

    pub struct MyResource {
        data: u32,
    }

    impl<Ctx: Send> exports::my::inline::foo::HandlerBar<Ctx> for Component {
        async fn new(&self, cx: Ctx, data: u32) -> anyhow::Result<ResourceOwn<Bar>> {
            Ok(ResourceOwn::from(Bytes::default()))
        }

        async fn get_data(&self, cx: Ctx, self_: ResourceBorrow<Bar>) -> anyhow::Result<u32> {
            Ok(42)
        }

        async fn consume(&self, cx: Ctx, mut _this: ResourceOwn<Bar>) -> anyhow::Result<u32> {
            Ok(42)
        }
    }

    #[derive(Clone)]
    struct Component;

    impl<Ctx: Send> exports::my::inline::foo::Handler<Ctx> for Component {}

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        // TODO: Support resources
        serve(wrpc, Component, async {}).await.unwrap();
    }
}

mod package_with_versions {
    use exports::my::inline::foo::Bar;
    use wit_bindgen_wrpc::bytes::Bytes;
    use wrpc_transport::ResourceOwn;

    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline@0.0.0;

            interface foo {
                resource bar {
                    constructor();
                }
            }

            world baz {
                export foo;
            }
        ",
    });

    pub struct MyResource;

    impl<Ctx: Send> exports::my::inline::foo::HandlerBar<Ctx> for Component {
        async fn new(&self, cx: Ctx) -> anyhow::Result<ResourceOwn<Bar>> {
            Ok(ResourceOwn::from(Bytes::default()))
        }
    }

    #[derive(Clone)]
    struct Component;

    impl<Ctx: Send> exports::my::inline::foo::Handler<Ctx> for Component {}

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        serve(wrpc, Component, async {}).await.unwrap();
    }
}

mod custom_derives {
    use std::collections::{hash_map::RandomState, HashSet};

    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            interface blah {
                record foo {
                    field1: string,
                    field2: list<u32>
                }

                bar: func(cool: foo);
            }

            world baz {
                export blah;
            }
        ",

        // Clone is included by default almost everywhere, so include it here to make sure it
        // doesn't conflict
        additional_derives: [serde::Serialize, serde::Deserialize, ::core::hash::Hash, core::clone::Clone, ::core::cmp::PartialEq, ::core::cmp::Eq],
    });

    use exports::my::inline::blah::Foo;

    #[derive(Clone)]
    struct Component;

    impl<Ctx: Send> exports::my::inline::blah::Handler<Ctx> for Component {
        async fn bar(&self, cx: Ctx, cool: Foo) -> anyhow::Result<()> {
            // Check that built in derives that I've added actually work by seeing that this hashes
            let _blah: HashSet<Foo, RandomState> = HashSet::from_iter([Foo {
                field1: "hello".to_string(),
                field2: vec![1, 2, 3],
            }]);

            // Check that the attributes from an external crate actually work. If they don't work,
            // compilation will fail here
            let _ = serde_json::to_string(&cool);
            Ok(())
        }
    }

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) {
        serve(wrpc, Component, async {}).await.unwrap();
    }
}

mod with {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            interface foo {
                record msg {
                    field: string,
                }
            }

            interface bar {
                use foo.{msg};

                bar: func(m: msg);
            }

            world baz {
                import bar;
            }
        ",
        with: {
            "my:inline/foo": other::my::inline::foo,
        },
    });

    pub mod other {
        wit_bindgen_wrpc::generate!({
            inline: "
                package my:inline;

                interface foo {
                    record msg {
                        field: string,
                    }
                }

                world dummy {
                    use foo.{msg};
                    import bar: func(m: msg);
                }
            ",
        });
    }

    #[allow(dead_code)]
    async fn test(
        wrpc: &impl wit_bindgen_wrpc::wrpc_transport::Invoke<Context = ()>,
    ) -> anyhow::Result<()> {
        let msg = other::my::inline::foo::Msg {
            field: "hello".to_string(),
        };
        my::inline::bar::bar(wrpc, (), &msg).await?;
        Ok(())
    }
}

mod with_and_resources {
    wit_bindgen_wrpc::generate!({
        inline: "
            package my:inline;

            interface foo {
                resource a;
            }

            interface bar {
                use foo.{a};

                bar: func(m: a) -> list<a>;
            }

            world baz {
                import bar;
            }
        ",
        with: {
            "my:inline/foo": other::my::inline::foo,
        },
    });

    pub mod other {
        wit_bindgen_wrpc::generate!({
            inline: "
                package my:inline;

                interface foo {
                    resource a;
                }

                world dummy {
                    use foo.{a};
                    import bar: func(m: a);
                }
            ",
        });
    }
}

#[allow(unused)]
mod generate_unused_types {
    use exports::foo::bar::component::UnusedEnum;
    use exports::foo::bar::component::UnusedRecord;
    use exports::foo::bar::component::UnusedVariant;

    wit_bindgen_wrpc::generate!({
        inline: "
            package foo:bar;

            world bindings {
                export component;
            }

            interface component {
                variant unused-variant {
                    %enum(unused-enum),
                    %record(unused-record)
                }
                enum unused-enum {
                    unused
                }
                record unused-record {
                    x: u32
                }
            }
        ",
        generate_unused_types: true,
    });
}

#[allow(unused)]
mod gated_features {
    wit_bindgen_wrpc::generate!({
        inline: r#"
            package foo:bar;

            world bindings {
                @unstable(feature = x)
                import x: func();
                @unstable(feature = y)
                import y: func();
                @since(version = 1.2.3)
                import z: func();
            }
        "#,
        features: ["y"],
    });

    fn _foo(wrpc: &impl wit_bindgen_wrpc::wrpc_transport::Invoke<Context = ()>) {
        y(wrpc, ());
        z(wrpc, ());
    }
}

#[allow(unused)]
mod interface_export_example {
    wit_bindgen_wrpc::generate!({
        inline: r#"
         package my:test;

         interface a {
             type my-type = u32;
         }

         world my-world {
             export b: interface {
                 use a.{my-type};

                 foo: func() -> my-type;
             }
         }
     "#,
    });

    #[derive(Clone)]
    struct MyComponent;

    impl<Ctx: Send> exports::b::Handler<Ctx> for MyComponent {
        async fn foo(&self, cx: Ctx) -> anyhow::Result<u32> {
            Ok(42)
        }
    }

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) -> anyhow::Result<()> {
        serve(wrpc, MyComponent, async {}).await
    }
}

#[allow(unused)]
mod resource_example {
    use std::sync::RwLock;

    wit_bindgen_wrpc::generate!({
     inline: r#"
         package my:test;

         interface logging {
             enum level {
                 debug,
                 info,
                 error,
             }

             resource logger {
                 constructor(level: level);
                 log: func(level: level, msg: string);
                 level: func() -> level;
                 set-level: func(level: level);
             }
         }

         world my-world {
             export logging;
         }
     "#,
    });

    use exports::my::test::logging::{Handler, HandlerLogger, Level, Logger};
    use wrpc_transport::{ResourceBorrow, ResourceOwn};

    #[derive(Clone)]
    struct MyComponent;

    // Note that the `logging` interface has no methods of its own but a trait
    // is required to be implemented here to specify the type of `Logger`.
    impl<Ctx: Send> Handler<Ctx> for MyComponent {}

    struct MyLogger {
        level: RwLock<Level>,
        contents: RwLock<String>,
    }

    impl<Ctx: Send> HandlerLogger<Ctx> for MyComponent {
        async fn new(&self, cx: Ctx, level: Level) -> anyhow::Result<ResourceOwn<Logger>> {
            todo!();

            // Ok(MyLogger {
            //     level: RwLock::new(level),
            //     contents: RwLock::new(String::new()),
            // })
        }

        async fn log(
            &self,
            cx: Ctx,
            self_: ResourceBorrow<Logger>,
            level: Level,
            msg: String,
        ) -> anyhow::Result<()> {
            todo!();

            // if level as u32 <= *self.level.read().unwrap() as u32 {
            //     self.contents.write().unwrap().push_str(&msg);
            //     self.contents.write().unwrap().push('\n');
            // }
            // Ok(())
        }

        async fn level(&self, cx: Ctx, self_: ResourceBorrow<Logger>) -> anyhow::Result<Level> {
            todo!();
            // Ok(*self.level.read().unwrap())
        }

        async fn set_level(
            &self,
            cx: Ctx,
            self_: ResourceBorrow<Logger>,
            level: Level,
        ) -> anyhow::Result<()> {
            todo!();

            // *self.level.write().unwrap() = level;
            // Ok(())
        }
    }

    async fn serve_exports(wrpc: &impl wrpc_transport::Serve) -> anyhow::Result<()> {
        serve(wrpc, MyComponent, async {}).await
    }
}

#[allow(unused)]
mod example_4 {
    wit_bindgen_wrpc::generate!({
        inline: r#"
        package example:exported-resources;

        world import-some-resources {
            export logging;
        }

        interface logging {
            enum level {
                debug,
                info,
                warn,
                error,
            }
            resource logger {
                constructor(max-level: level);

                get-max-level: func() -> level;
                set-max-level: func(level: level);

                log: func(level: level, msg: string);
            }
        }
    "#,
    });
}

#[allow(unused)]
mod async_test {
    wit_bindgen_wrpc::generate!({
        inline: r#"
        package wrpc-test:async;

        world async {
            import handler;
            export handler;
        }

        interface handler {
            use types.{request, response};

            handle: func(request: request) -> result<response, string>;
        }

        interface types {
            type fields = list<tuple<string, list<list<u8>>>>;

            record request {
                body: stream<u8>,
                trailers: future<option<fields>>,
                path-with-query: option<string>,
                authority: option<string>,
                headers: fields,
            }

            record response {
                body: stream<u8>,
                trailers: future<option<fields>>,
                status: u16,
                headers: fields,
            }
        }
    "#,
    });
}
